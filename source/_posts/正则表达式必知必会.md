---
title: 正则表达式必知必会
catalog: true
date: 2019-08-30 14:11:43
subtitle:
header-img:
tags: javascript
---

## 规则说明

- \n 回车
- \t 制表符
- \r 换行符
- \s 空格
- \u4e00-\u9fa5 中文
- \w 大小写字母\_数字
- \b : 独立的部分 （ 起始，结束，空格 ）
- {n, m} 至少出现 n 次 最多 m 次
- {n,} 至少 n 次
- \. 任意次
- \+ 至少一次
- {n} 至少 n 次
- () 子表达式，分组符号
- [\s\S] 任意字符
- ^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。
- [] 表示某个集合中的任意一个
- [^a] 排除 a
- ?=   向前查找
- ?<=  向后查找
- ?!   负向前查找
- ?<!  负向后查找（不包含）

## 常用匹配规则

- 匹配中文: [\u4e00-\u9fa5]
- 任意字符：.\*（贪婪型） .\*?（懒惰型）

```javascript
//去掉a标签
a =
 '度假：原价购页面<a href="jumpType:22,jumplink:273" style="font-size:16px">sss</a>'

//  .*? 是一个组合 尽可能匹配少的内容 即不会贪婪匹配到</a>结束
a.replace(/<\/?a.*?>/g, '')
```

例如：

```javascript
var str = '2013-6-7';
// 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-
var re1 = /\d-+/g;
// 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-
var re1 = /(\d-)+/g;
// 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-
var re2  = /(\d+)(-)/g;

var str = '2013-6-7';
var re = /(\d+)(-)/g;

str = str.replace(re,function($0,$1,$2){

    //replace()中如果有子项，
    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,
    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\d   2013, 6)
    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )

    return $1 + '.';  //分别返回2013.   6.

});


// var re = /\bclassname\b/;

// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会
// 把classname当做一个字符串去匹配。

var re = new RegExp('\\b'+classname+'\\b');

// 匹配的时候，classname前面必须是起始或者空格，后面也是。

默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。

```

## 回溯引用：前后一致匹配

背景

```javascript
// 测试文本
var str1 = `
<Body>
    <H1>Welcome to my Homepage</H1>
    Content is divided into two sections: <BR>
    <H2>ColdFusion</H2>
    Information about Macromedia ColdFusion.
    <H2>Wireless</H2>
    Information about Bluetooth, 802.11, and more.
</Body>
`

// 注意 .*? （懒惰型） 而不是.*（贪婪型），
// 如果是.*有可能会存在从H1一直匹配到H6的情况出现
const a = /<[Hh][1-6]>.*?<\/[Hh][1-6]>/g
```

缺点

```javascript
// 测试文本
var str1 = `
<Body>
    <H1>Welcome to my Homepage</H1>
    Content is divided into two sections: <BR>
    <H2>ColdFusion</H2>
    Information about Macromedia ColdFusion.
    <H2>Wireless</H3>
    Information about Bluetooth, 802.11, and more.
</Body>
`

// 注意 .*? （懒惰型） 而不是.*（贪婪型），
// 如果是.*有可能会存在从H1一直匹配到H6的情况出现
const a = /<[Hh][1-6]>.*?<\/[Hh][1-6]>/g
```

此时使用上述匹配会匹配到不合法的字符（\<H2>Wireless\</H3>），在这种情况下只能求助于回溯引用。

### 回溯引用

指得是模式的后半部分引用在前半部分中定义的*子表达式*。

回溯引用匹配通常从1开始计数（\1、\2等）。在许多实现里，第0个匹配（\0）可以用来代表整个正则表达式

与字符串的replace方法的回调使用$0, $1, $2等参数类似

其他一些元字符

元字符|说明
--|:--:
\E|结束\L或\U转换
\l|把下一个字符转换为小写
\L|把\L到\E之间的字符全部转换为小写
\u|把下一个字符转换为大写
\U|把\U到\E之间的字符全部转换为大写

```javascript
const b = '313-555-123'.replace(/(\d{3})(-)(\d{3})-(\d{3})/g, ($0, $1, $2, $3, $4) => `(${$1}) ${$3}-${$4}`) // (313) 555-123
```

解决

```javascript
// 测试文本
var str1 = `
<Body>
    <H1>Welcome to my Homepage</H1>
    Content is divided into two sections: <BR>
    <H2>ColdFusion</H2>
    Information about Macromedia ColdFusion.
    <H2>Wireless</H3>
    Information about Bluetooth, 802.11, and more.
    <H2>Wireless</h2>
</Body>
`

const a = /<([Hh][1-6])>.*?<\/\1>/g
```

## 前后查找

### 概括

从结果中排除最终不需要的辅助查找的字符

### 背景

比如有一些字符串\<h1>ssss\</h1>，我们只需要其中的ssss，不需要在返回的结果中包含\<h1>等标签字符，一般做法是先想办法把他们检索出来，在以手动形式排除，这既浪费时间，又容易招致不必要的后患。这时候就需要一种模式，包含匹配的本身并不返回，而是用于确定正确的匹配位置，他并不是匹配结果的一部分。换句话说，我们需要进行**前后查找**。

```javascript
// 测试文本
var str = `
http://www.forta.com/
https://www.forta.com/
ftp://www.forta.com/
`

// 向前查找   匹配字符直到:停止（不包含:）
var a = /.+(?=:)/g   // http https ftp
// 包含:
var b = /.+(:)/g     // http: https: ftp:


// 获取物品价格
var str1 = `
ABCD: $23.25
HFG1: $5.3
XTC99: $69.1
Total items found: 4
`

// 结果会有多余的$
var a1 = /\$\d+\.\d+/g // $23.25 $5.3 $69.1

// 向后查找 结果不会返回多余的$  
var b1 = /(?<=\$)\.\d+/g // 23.25 5.3 69.1


// 获取购买物品的数量
var str2 = `
I paid $30 for 100 apples, 50 oranges, and 60 pears. I saved $5 on this order.
`

var a2 = `/\b(?<!\$)\d+/g`

```
