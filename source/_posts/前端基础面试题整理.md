---
title: 前端基础面试题整理
catalog: true
date: 2019-11-12 10:15:59
subtitle:
header-img:
tags: 前端
---

## js 基础

- 闭包
- 作用域
- 原型链
- 变量提升
- 函数参数值传递
- this 指向问题
- 函数提升以及优先级问题
- new 操作符做了什么？

```javascript
function A(id) {
  this.id = id;
}

A.prototype.showId = function() {
  console.log(this.id);
};

// new内部实现
function myNew() {
  var o = new Object();
  // 取得外部传入的构造器，默认第一个参数是构造函数
  var Constructor = Array.prototype.shift.call(arguments);
  // 实现继承，实例可以访问构造器的属性
  o.__proto__ = Constructor.prototype;
  // 调用构造器，并改变其 this 指向到实例
  var ret = Constructor.call(o, arguments);
  // 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象
  return typeof ret === "object" && ret !== null ? ret : obj;
}

var a = myNew(A, 10);
```

- 用 ES5 实现一个继承（有哪些方式）
- 0.2+0.1 不等于 0.3 问题（浮点数精度）
- 堆、栈、队列是什么？都有什么区别？有什么应用？
- 深拷贝、浅拷贝问题（immutable 是怎么实现的？）
- typed array 问题
- es6 箭头函数问题
- let var const 区别与原理

1. var 存在变量提升，执行时已经完成声明与初始化，全局作用域|函数作用域；
2. let const 不能重复定义，存在暂时性死区，没有变量提升，块作用域；
3. var 在栈内存预分配空间，等执行时候再讲变量值存在空间里，let const 不会

- 什么是 iterator？for of 用过吗？
- call、apply、bind 区别，bind 怎么实现的？

- promise 实现，Promise.all 实现， Promise.race，Promise.finally 实现

```javascript
_Promise.all = arr => {
  let aResult = []; //用于存放每次执行后返回结果
  return new _Promise(function(resolve, reject) {
    let i = 0;
    next(); // 开始逐次执行数组中的函数(重要)
    function next() {
      arr[i].then(function(res) {
        aResult.push(res); // 存储每次得到的结果
        i++;
        if (i == arr.length) {
          // 如果函数数组中的函数都执行完，便resolve
          resolve(aResult);
        } else {
          next();
        }
      });
    }
  });
};

const race = (_Promise.race = function(iterable) {
  return new Promise(function(resolve, reject) {
    for (const i in iterable) {
      const v = iterable[i];
      if (typeof v === "object" && typeof v.then === "function") {
        v.then(resolve, reject);
      } else {
        resolve(v);
      }
    }
  });
});

_Promise.finally = function(callback) {
  const P = this.constructor; // 获取当前实例构造函数的引用
  return this.then(
    value => P.resolve(callback()).then(() => value),
    reason =>
      P.resolve(callback()).then(() => {
        throw reason;
      })
  );
};

const p1 = new Promise(function(resolve) {
  setTimeout(resolve, 200, 1);
});
const p2 = new Promise(function(resolve) {
  setTimeout(resolve, 100, 2);
});
race([p1, p2]).then(function(res) {
  console.log(res);
});
```

- caller、callee 了解吗？什么时候会用到？建议用吗？

```javascript
function factorial(x) {
  return x <= 1 ? 1 : x * factorial(x - 1);
}

// callee
// callee是arguments对象的一个属性，指向 arguments 对象的函数
// 利用callee
function factorial(x) {
  return x <= 1 ? 1 : x * arguments.callee(x - 1);
}

// caller
// 函数对象的一个属性，指向调用当前函数的函数。比如 A() 调用 B()， 则在B()中 B.caller 指向A()

// 1 这个属性只有当函数在执行时才有用

// 2 如果在JavaScript程序中，函数是由顶层调用的，则返回null

function B() {
  console.log(B.caller); // B
}

(function A() {
  B(); // A
})();
```

- async await 知识点（await 的作用，async 返回的是什么）

很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。

```javascript
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}

// 等价于

async function async1() {
  console.log("async1 start");
  Promise.resolve(async2()).then(() => {
    console.log("async1 end");
  });
}
```

- Async/Await 如何通过同步的方式实现异步?

Async/Await 就是一个自执行的 generate 函数。利用 generate 函数的特性把异步的代码写成“同步”的形式，generate 函数本身实现思想来源于单向链表。

- generator 又是什么？

生成器 generator 函数执行时返回这个生成器的迭代对象，当这个迭代对象的 next 方法被调用时，遇到 yield 的位置停止，yield 后返回的值就是迭代器要返回的值。如果用的是 yield\*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行），调用 next() （再启动）方法时，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值，例如：

```javascript
function* another() {
  yield "人月神话";
}
function* gen() {
  yield* another(); // 移交执行权
  const a = yield "hello";
  const b = yield a; // a='world' 是 next('world') 传参赋值给了上一个 yidle 'hello' 的左值
  yield b; // b=！ 是 next('！') 传参赋值给了上一个 yidle a 的左值
}
const g = gen();
g.next(); // {value: "人月神话", done: false}
g.next(); // {value: "hello", done: false}
g.next("world"); // {value: "world", done: false} 将 'world' 赋给上一条 yield 'hello' 的左值，即执行 a='world'，
g.next("!"); // {value: "!", done: false} 将 '!' 赋给上一条 yield a 的左值，即执行 b='!'，返回 b
g.next(); // {value: undefined, done: false}
```

- v8 线程模型、event loop（async、promise、nextTick、setTimeout、- setImmediate 经典问题变着花样考）
- 进程和线程是什么？有什么区别？
- v8 垃圾回收机制
- 输入 URL，浏览器的执行过程又是怎么样的？（浏览器解析方式、顺序，async、- defer 等）
- 了解前端模块化吗？有几种规范？（commonjs 和 es module 都是怎么实现- 的？有啥区别？）

- 按需加载实现

- ['1', '2', '3'].map(parseInt) parseInt(100, 2) = 4
- 防抖节流

1. 防抖
   > 高频事件 n 秒内执行一次，如果 n 秒内再次触发，重新计时

```javascript
function debonce(fn, time) {
  let timeout = null;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn.apply(this, arguments);
    }, time);
  };
}
```

2. 节流
   > 高频事件 n 秒内执行一次

```javascript
function debonce(fn, time) {
  let startTime = 0;
  return function() {
    let nowTime = Date.now();
    if (nowTime - startTime >= time) {
      fn.apply(this, arguments);
      startTime = Date.now();
    }
  };
}
```

- Set WeaksSet 和 Map WeakMap 各自区别

  Set 无序类似数组的数据结构

  WeakSet

  1. 只能是对象引用；
  2. 未使用会被 GC 收集

  Map 字典结构，以`value:value`形式存储

  WeakMap

  1. 建的对象引用只能是对象引用；
  2. 未使用的建对象会被 GC 收集

- es5 和 es6 类的区别

  1. class 会提升，但不会赋值，会进入暂时性死区（TDZ）；
  2. class 内部默认启用严格模式；
  3. class 的所有方法、属性不能枚举；
  4. class 所有方法没有 prototype，也没有[[constructor]]，不能实例化；
  5. 必须使用`new`来实例化；
  6. class 无法重写类名；

- es5 和 es6 的继承区别

  1. es5 的继承是先实例化子类，再通过父类构造函数修饰子类实例，而 es6 的继承是通过`super`方法先实例化父类，再通过子类构造函数修饰父类实例；
  2. es6 的子类可以通过`__proto__`找到父类，而 es5 中通过`__proto__`只能找到`Function.prototype`

- 箭头函数和普通函数区别

1. 箭头函数本身没有 this，需要通过原型向上级对象查找，即 this 对象是指向定义是所在作用域的 this 对象（因此无法使用 call、apply、bind 绑定 this 值），普通函数指向调用时的对象；
2. 箭头函数没有 arguments，可以用 rest 参数代替；
3. 箭头函数不能使用 new 命令，

- 因为没有 this，无法调用 call；
- 没有 prototype

4. 箭头函数没有原型 prototype；

---

## 网络

- http 1.0 1.1 2.0 协议特性与区别

  **http 1.0**

  1. 无状态

  需要 cookie/session 做身份认证和登录

  2. 无连接

  a. 每次连接结束都会关闭连接，再重新创建连接 tcp 三次连接与四次挥手，效率很低；

  b. 在上一个请求到达结束之前无法发送下一个请求；

  **http 1.1**

  1. 长连接 keep-alive
  2. 管道机制 不必等待上一个请求返回就能发送下一个请求，返回的结果还是按照顺序，但是为了保持响应顺序，还是存在队头阻塞问题；
  3. 缓存 cache-control；
  4. 断点传输

  **http 2.0**

  1. 二进制分帧；
  2. 多路复用 在共享 TCP 链接的基础上同时发送请求和响应；
  3. 头部压缩；
  4. 服务器推送；

- 简单讲解一下 http2 的多路复用

http1.0 一个请求建立一个链接，请求结束就关闭，依次往复，可开启'keep-alive'，让链接不关闭复用

http1.1 默认允许一个连接发送多个请求，浏览器为了控制资源一般控制在 6 个左右，虽然建立多个连接，但需要等待前一个请求结束，服务器才会响应后面的请求；

http2 采用二进制传输数据，更高效，有两个非常重要的概念，帧和流，帧是最小数据单位，帧会标识属于哪个流，可以在一个连接中发送并行发送多个请求，避免了 1.1 中队头阻塞的问题，极大提高性能。

- TCP 三次握手和四次挥手的理解

![示意图](https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png)

TCP 三次握手：

其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的 ACK 都会对这个 seq 进行加一来进行确认

三次握手之所以是三次是保证 client 和 server 均让对方知道自己的接收和发送能力没问题而保证的最小次数，三次是最少的安全次数，两次不安全，四次浪费资源。

四次挥手：

TCP 是全双工信道，何为全双工就是客户端与服务端建立两条通道，

通道 1:客户端的输出连接服务端的输入；

通道 2:客户端的输入连接服务端的输出。

两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：

客户端：我要关闭输入通道了。 服务端：好的，你关闭吧，我这边也关闭这个通道。

服务端：我也要关闭输入通道了。 客户端：好的你关闭吧，我也把这个通道关闭。

- rpc 协议和 tcp 协议的区别

tcp

1. tcp 协议需要 DNS 寻址；
2. tcp 协议是单工通信；

rpc

1. 二进制数据传输，更小的体积，更快编解码速率；
2. 不一定是 DNS 寻址，可能是内部服务寻址；
3. 单工/半双工/双工通信方式支持；

---

## 浏览器

1. 说说浏览器和 Node 事件循环的区别

微任务和宏任务在 Node 的执行顺序

Node 10 及以前：

执行完一个阶段（timers、I/O、poll 等）的任务
就会去执行 nextTick 队列里面的内容
然后再执行完微任务队列的内容

Node 11 以后： 和浏览器的行为统一了，都是每执行完一个宏任务就会执行微任务队列。

![Node的Event Loop](https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```javascript
function test() {
  console.log("start");
  setTimeout(() => {
    console.log("children2");
    Promise.resolve().then(() => {
      console.log("children2-1");
    });
  }, 0);
  setTimeout(() => {
    console.log("children3");
    Promise.resolve().then(() => {
      console.log("children3-1");
    });
  }, 0);
  Promise.resolve().then(() => {
    console.log("children1");
  });
  console.log("end");
}

test();

// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)
// start
// end
// children1
// children2
// children3
// children2-1
// children3-1

// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)
// start
// end
// children1
// children2
// children2-1
// children3
// children3-1
```

2. 重绘与回流

几何属性 样式变化会引起 重绘

几何形状 位置变化引起 回流

---

### 前端内功

1. 模块化理解；

> 模块化是为了处理全局污染、隔离作用域、抽离公共代码等问题

| 名称         | 特点                                                             |
| ------------ | ---------------------------------------------------------------- |
| `iife`       | 自执行 函数作用域                                                |
| `amd`        | 浏览器端（requirejs） 依赖前置                                   |
| `cmd`        | 浏览器端（seajs） 运行时加载依赖 后面也支持依赖前置              |
| `commonjs`   | 浏览器、服务器通用 运行时加载 第一次运行加载，缓存值，值的浅拷贝 |
| `es6 module` | 浏览器、服务器通用 静态编译，编译时输出接口 值的引用             |

2. 工程化理解；
3. 组件化理解;
4. 性能优化；

---

### 框架

1. React 中的 setState 何时是同步的，何时是异步的？

在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理，生命周期函数等），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。

**原因：** 在 React 的 setState 函数实现中，会根据一个变量`isBatchingUpdate`·判断是直接更新 this.state 还是放到队列中回头再说，而`isBatchingUpdates`默认是`false`，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。

2. vue 父组件和子组件创建的生命周期顺序

- 加载渲染过程 父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount->子 mounted->父 mounted

- 子组件更新过程 父 beforeUpdate->子 beforeUpdate->子 updated->父 updated

- 父组件更新过程 父 beforeUpdate->父 updated

- 销毁过程 父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed

---

### CSS

1. 介绍下 BFC 及其应用

BFC 块级格式上下文， 是指一个独立的渲染区域或者说是一个隔离的独立容器。

形成条件：

1、浮动元素，float 除 none 以外的值；

2、定位元素，position（absolute，fixed）；

3、display 为以下其中之一的值 inline-block，table-cell，table-caption；

4、overflow 除了 visible 以外的值（hidden，auto，scroll）；

特点：

1.内部的 Box 会在垂直方向上一个接一个的放置。

2.垂直方向上的距离由 margin 决定，垂直外边距会重叠即两个盒子中间距离以 margin 最大的值决定；

3.bfc 的区域不会与 float 的元素区域重叠。

4.计算 bfc 的高度时，浮动元素也参与计算

5.bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。

参考：[CSS 中的 BFC 详解](https://www.cnblogs.com/chen-cong/p/7862832.html)
