---
title: 前端基础面试题整理
catalog: true
date: 2019-11-12 10:15:59
subtitle:
header-img:
tags: 前端
---

## js 基础

- 闭包

一个函数内部返回一个能访问外部变量的函数

- 作用域
- 原型链
- 变量提升
- 函数参数值传递
- this 指向问题
- 函数提升以及优先级问题
- new 操作符做了什么？

1. 创建一个空对象，作为将要返回的对象实例；
2. 将这个空对象的原型对象指向构造函数的 prototype 属性对象；
3. 调用构造器， 将这个实例对象的值赋值给函数内部的 this 对象；
4. 执行构造函数内的逻辑；
5. 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象；

```javascript
function A(id) {
  this.id = id;
}

A.prototype.showId = function() {
  console.log(this.id);
};

// new内部实现
function myNew() {
  var o = new Object();

  var Constructor = Array.prototype.shift.call(arguments);
  // 实现继承，实例可以访问构造器的属性
  o.__proto__ = Constructor.prototype;
  // 调用构造器，并改变其 this 指向到实例
  var ret = Constructor.call(o, arguments);

  return typeof ret === "object" && ret !== null ? ret : o;
}

var a = myNew(A, 10);
```

- 用 ES5 实现一个继承（有哪些方式）

1. 类继承
2. 原型继承
3. 组合继承
4. 寄生继承

- 0.2+0.1 不等于 0.3 问题（浮点数精度）
- 堆、栈、队列是什么？都有什么区别？有什么应用？
- 深拷贝、浅拷贝问题（immutable 是怎么实现的？）
- typed array 问题
- es6 箭头函数问题
- let var const 区别与原理

1. var 存在变量提升，执行时已经完成声明与初始化，全局作用域|函数作用域；
2. let const 不能重复定义，存在暂时性死区，没有变量提升，块作用域；
3. var 在栈内存预分配空间，等执行时候再将变量值存在空间里，let const 不会

- 什么是 iterator？for of 用过吗？
- call、apply、bind 区别，bind 怎么实现的？

参考链接：

1. [JavaScript 深入之 bind 的模拟实现](https://juejin.im/post/59093b1fa0bb9f006517b906)

- promise 实现，Promise.all 实现， Promise.race，Promise.finally 实现

```javascript
function _Promise(handle) {
  this.status = "pending";
  // 存放成功的值
  this.value = undefined;
  // 存放失败的值
  this.reason = undefined;

  this.successStore = []
  this.failStore = []

  const resolve = (value) => {
    if (this.status === "pending") {
      this.value = value;
      this.status = "resolved";

      this.successStore.forEach(fnc => fnc())
    }
  }

  const reject = (reason) => {
    if (this.status === "pending") {
      this.reason = reason;
      this.status = "rejected";

      this.failStore.forEach(fnc => fnc())
    }
  }

  try {
    handle(resolve, reject);
  } catch (e) {
    reject(e);
  }
}

_Promise.prototype.then = function (onFulfilled, onRejected) {
  // 处理异步的情况（如setTimeout）
  if (this.status === 'pending') {
    this.successStore.push(() => onFulfilled(this.value))

    this.failStore.push(() => onRejected(this.value))
  }

  if (this.status === "resolved") {
    return onFulfilled(this.value);
  }
  if (this.status === "rejected") {
    return onRejected(this.reason);
  }
};


// TODO  then链式调用




_Promise.prototype.all = arr => {
  let len = arr.length - 1
  let resultArr = []
  // 记录成功的数量
  let count = 0;

  return new Promise(resolve => {
  	let i = 0

  	for (let i = 0; i < arr.length; i++) {
      arr[i].then(res => {
      	resultArr[i] = res

        if (count == len) {
        	resolve(resultArr)
        }
        count++
      })
    }
  })
};

_Promise.prototype.race = = function(iterable) {
  return new Promise(function(resolve, reject) {
    for (const i in iterable) {
      const v = iterable[i];
      if (typeof v === "object" && typeof v.then === "function") {
        v.then(resolve, reject);
      } else {
        resolve(v);
      }
    }
  });
};

_Promise.prototype.finally = function(callback) {
  const P = this.constructor; // 获取当前实例构造函数的引用
  return this.then(
    value => P.resolve(callback()).then(() => value),
    reason =>
      P.resolve(callback()).then(() => {
        throw reason;
      })
  );
};

const p1 = new Promise(function(resolve) {
  setTimeout(resolve, 200, 1);
});
const p2 = new Promise(function(resolve) {
  setTimeout(resolve, 100, 2);
});
race([p1, p2]).then(function(res) {
  console.log(res);
});
```

参考资料：
[前端工程师必知之 Promise 的实现](https://juejin.im/post/5afd2ff26fb9a07aaa11786c)

- caller、callee 了解吗？什么时候会用到？建议用吗？

```javascript
function factorial(x) {
  return x <= 1 ? 1 : x * factorial(x - 1);
}

// callee
// callee是arguments对象的一个属性，指向 arguments 对象的函数
// 利用callee
function factorial(x) {
  return x <= 1 ? 1 : x * arguments.callee(x - 1);
}

// caller
// 函数对象的一个属性，指向调用当前函数的函数。比如 A() 调用 B()， 则在B()中 B.caller 指向A()

// 1 这个属性只有当函数在执行时才有用

// 2 如果在JavaScript程序中，函数是由顶层调用的，则返回null

function B() {
  console.log(B.caller); // B
}

(function A() {
  B(); // A
})();
```

- async await 知识点（await 的作用，async 返回的是什么）

很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。

```javascript
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}

// 等价于

async function async1() {
  console.log("async1 start");
  Promise.resolve(async2()).then(() => {
    console.log("async1 end");
  });
}
```

- Async/Await 如何通过同步的方式实现异步?

Async/Await 就是一个自执行的 generate 函数。利用 generate 函数的特性把异步的代码写成“同步”的形式，generate 函数本身实现思想来源于单向链表。

- generator 又是什么？

生成器 generator 函数执行时返回这个生成器的迭代对象，当这个迭代对象的 next 方法被调用时，遇到 yield 的位置停止，yield 后返回的值就是迭代器要返回的值。如果用的是 yield \*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行），调用 next() （再启动）方法时，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值，例如：

```javascript
function* another() {
  yield "人月神话";
}
function* gen() {
  yield* another(); // 移交执行权
  const a = yield "hello";
  const b = yield a; // a='world' 是 next('world') 传参赋值给了上一个 yidle 'hello' 的左值
  yield b; // b=！ 是 next('！') 传参赋值给了上一个 yidle a 的左值
}
const g = gen();
g.next(); // {value: "人月神话", done: false}
g.next(); // {value: "hello", done: false}
g.next("world"); // {value: "world", done: false} 将 'world' 赋给上一条 yield 'hello' 的左值，即执行 a='world'，
g.next("!"); // {value: "!", done: false} 将 '!' 赋给上一条 yield a 的左值，即执行 b='!'，返回 b
g.next(); // {value: undefined, done: false}
```

- v8 线程模型、event loop（async、promise、nextTick、setTimeout、- setImmediate 经典问题变着花样考）
- 进程和线程是什么？有什么区别？
- v8 垃圾回收机制
- 输入 URL，浏览器的执行过程又是怎么样的？（浏览器解析方式、顺序，async、- defer 等）

- 了解前端模块化吗？有几种规范？（commonjs 和 es module 都是怎么实现- 的？有啥区别？）

* 按需加载实现

* ['1', '2', '3'].map(parseInt) parseInt(100, 2) = 4
* 防抖节流

1. 防抖
   > 高频事件 n 秒内执行一次，如果 n 秒内再次触发，重新计时

```javascript
function debonce(fn, time) {
  let timeout = null;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn.apply(this, arguments);
    }, time);
  };
}
```

2. 节流
   > 高频事件 n 秒内执行一次

```javascript
function debonce(fn, time) {
  let startTime = 0;
  return function() {
    let nowTime = Date.now();
    if (nowTime - startTime >= time) {
      fn.apply(this, arguments);
      startTime = Date.now();
    }
  };
}
```

- Set WeaksSet 和 Map WeakMap 各自区别

  Set 无序类似数组的数据结构

  WeakSet

  1. 只能是对象引用；
  2. 未使用会被 GC 收集

  Map 字典结构，以`value:value`形式存储

  WeakMap

  1. 建的对象引用只能是对象引用；
  2. 未使用的建对象会被 GC 收集

- es5 和 es6 类的区别

  1. class 会提升，但不会赋值，会进入暂时性死区（TDZ）；
  2. class 内部默认启用严格模式；
  3. class 的所有方法、属性不能枚举；
  4. class 所有方法没有 prototype，也没有[[constructor]]，不能实例化；
  5. 必须使用`new`来实例化；
  6. class 无法重写类名；

- es5 和 es6 的继承区别

  1. es5 的继承是先实例化子类，再通过父类构造函数修饰子类实例，而 es6 的继承是通过`super`方法先实例化父类，再通过子类构造函数修饰父类实例；
  2. es6 的子类可以通过`__proto__`找到父类，而 es5 中通过`__proto__`只能找到`Function.prototype`

- 箭头函数和普通函数区别

1. 箭头函数本身没有 this，需要通过原型向上级对象查找，即 this 对象是指向定义是所在作用域的 this 对象（因此无法使用 call、apply、bind 绑定 this 值），普通函数指向调用时的对象；
2. 箭头函数没有 arguments，可以用 rest 参数代替；
3. 箭头函数不能使用 new 命令，

- 因为没有 this，无法调用 call；
- 没有 prototype

4. 箭头函数没有原型 prototype；

---

## 浏览器

1. 说说浏览器和 Node 事件循环的区别

微任务和宏任务在 Node 的执行顺序

Node 10 及以前：

执行完一个阶段（timers、I/O、poll 等）的宏任务
才会去执行 nextTick 队列里面的内容
然后再执行完微任务队列的内容

Node 11 以后： 和浏览器的行为统一了，都是每执行完一个宏任务就会执行微任务队列。

![Node的Event Loop](https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```javascript
function test() {
  console.log("start");
  setTimeout(() => {
    console.log("children2");
    Promise.resolve().then(() => {
      console.log("children2-1");
    });
  }, 0);
  setTimeout(() => {
    console.log("children3");
    Promise.resolve().then(() => {
      console.log("children3-1");
    });
  }, 0);
  Promise.resolve().then(() => {
    console.log("children1");
  });
  console.log("end");
}

test();

// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)
// start
// end
// children1
// children2
// children3
// children2-1
// children3-1

// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)
// start
// end
// children1
// children2
// children2-1
// children3
// children3-1
```

2. 重绘与回流

几何属性 样式变化会引起 重绘

几何形状 位置变化引起 回流

---

### 前端内功

1. 模块化理解；

> 模块化是为了处理全局污染、隔离作用域、抽离公共代码等问题

| 名称         | 特点                                                             |
| ------------ | ---------------------------------------------------------------- |
| `iife`       | 自执行 函数作用域                                                |
| `amd`        | 浏览器端（requirejs） 依赖前置                                   |
| `cmd`        | 浏览器端（seajs） 运行时加载依赖 后面也支持依赖前置              |
| `commonjs`   | 浏览器、服务器通用 运行时加载 第一次运行加载，缓存值，值的浅拷贝 |
| `es6 module` | 浏览器、服务器通用 静态编译，编译时输出接口 值的引用             |

2. 工程化理解；
3. 组件化理解;
4. 性能优化；

---

### 框架

1. React 中的 setState 何时是同步的，何时是异步的？

在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理，生命周期函数等），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。

**原因：** 在 React 的 setState 函数实现中，会根据一个变量`isBatchingUpdate`·判断是直接更新 this.state 还是放到队列中回头再说，而`isBatchingUpdates`默认是`false`，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。

2. vue 父组件和子组件创建的生命周期顺序

- 加载渲染过程 父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount->子 mounted->父 mounted

- 子组件更新过程 父 beforeUpdate->子 beforeUpdate->子 updated->父 updated

- 父组件更新过程 父 beforeUpdate->父 updated

- 销毁过程 父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed

---

## CSS

### 介绍下 BFC 及其应用

BFC 块级格式上下文， 是指一个独立的渲染区域或者说是一个隔离的独立容器。

形成条件：

1、浮动元素，float 除 none 以外的值；

2、定位元素，position（absolute，fixed）；

3、display 为以下其中之一的值 inline-block，table-cell，table-caption；

4、overflow 除了 visible 以外的值（hidden，auto，scroll）；

特点：

1.内部的 Box 会在垂直方向上一个接一个的放置。

2.垂直方向上的距离由 margin 决定，垂直外边距会重叠即两个盒子中间距离以 margin 最大的值决定；

3.bfc 的区域不会与 float 的元素区域重叠。

4.计算 bfc 的高度时，浮动元素也参与计算

5.bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。

参考：[CSS 中的 BFC 详解](https://www.cnblogs.com/chen-cong/p/7862832.html)

### position 几种属性

- relative 相对定位

不脱离文档流
设置定位
层级

- absolute 绝对定位

脱离文档流
设置定位
层级

- fixed 浏览器窗口定位

- sticky

页面滑动距离未超过指定距离为相对定位，超过为 fixed 定位

- static 默认定位

- inherit 继承定位

从父元素继承 position 属性的值

### 相邻的两个 inline-block 节点为什么会出现间隔，该如何解决？

元素被当成行内元素排版的时候，原来 HTML 代码中的回车换行被转成一个空白符，在字体不为 0 的情况下，空白符占据一定宽度，所以 inline-block 的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素 font-size:16px 时，间距为 8px。

解决办法如下：

- font-size
- html 不换行
- word-spacing
