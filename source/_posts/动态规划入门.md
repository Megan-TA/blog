---
title: 动态规划入门
catalog: true
date: 2020-08-27 11:18:54
subtitle:
header-img:
tags: javascript
categories: 前端
---

假设有数字1，5， 11，那么凑出数字n最少需要多少个数字？

函数f(n) 表明凑出n需要的数字个数

说明：

- 假设最后一个数字是1, 那么凑出n-1最少需要多少个数字？  min = f(n-1) + 1
- 假设最后一个数字是5, 那么凑出n-5最少需要多少个数字？  min = f(n-5) + 1
- 假设最后一个数字是11, 那么凑出n-11最少需要多少个数字？ min = f(n - 11) + 1

所以最小需要的数字就是上述三种情况下的最小值 min{f(n - 1), f(n-5), f(n-11)}，再加上固定的最后一位1

公式：
f(n) = min{f(n - 1), f(n-5), f(n-11)} + 1

代码实现：

## 递归

```javascript

function f(n) {
  if (n <= 0) return 0
  let min = Infinity

  if (n >= 1) {
    min = Math.min(f(n - 1) + 1, min)
  }

  if (n >= 5) {
    min = Math.min(f(n - 5) + 1, min)
  }

  if (n >= 11) {
    min = Math.min(f(n - 11) + 1, min)
  }

  return min
}

f(70)

// 比如凑出数字15
f(15) => 3
f(14) => 4
f(12) => 2

```

## 递归的弊端

1、数字大的一定量的时候耗时越来越长；

2、数字过大时候会爆栈；

比如f(70)这情况

![递归](https://user-gold-cdn.xitu.io/2020/4/3/1713e9f158144d68?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

计算f(70)分为三种情况，三种情况下的递归又依次分为三种情况，以此类推算法复杂度O(3^n)

其中上图红色部分代表重复计算的数字，一般原则就是利用空间换时间的原则，维护一份备忘录，备忘录中有对应值直接取，不用再次计算

处理问题1相关代码实现：

```javascript
function f(amount) {
    function start(n) {
        if (n <= 0) return 0
        if (cache[n]) return cache[n]
        let min = Infinity

        if (n >= 1) {
            min = Math.min(start(n - 1) + 1, min)
        }

        if (n >= 5) {
            min = Math.min(start(n - 5) + 1, min)
        }

        if (n >= 11) {
            min = Math.min(start(n - 11) + 1, min)
        }

        cache[n] = min
        return min
    }

    let cache = []

    return start(amount)
}
```

## 动态规划

上述递归的实现是`从上到下`的计算思路，即f(70)f(69)...f(1)逐步分解，这个思路这里并不完全适用，我们需要一种`从下到上`的计算思路，即f(1)f(2)...f(70)的方式来解决大规模问题，动态规划通常是用`迭代`取代递归来解决问题。

除此之外，递归+备忘录 的另一个缺陷就是再没有优化空间了，因为在最坏的情况下，递归的最大深度为O(n)，换成迭代之后根本不需要如此多的存储空间。

## 动态转移方程

分析上述备忘录缓存的节点形式如下

amount | n
-- | --|
0  | 0
1 | 1
2 |  2
3 |  3
4 |  4
5 |  1
6 |    2
7 |  3
8 |  4
9 |  5
10 |  2
11 |  1
12 |  2
13 |  3

f[1] = min(f[0], f[-5], f[-11]) + 1 = 1
f[5] = min(f[0], f[4], f[-6]) + 1 = 1

得出公式为：

> f[n] = min(f[n - 1], f[n- 5], f[n - 11]) + 1

代码实现：

```javascript
function makeChange(coins = [], amount = 0) {
  // 初始化备忘录 Infinity填充 位数根据传入的数值动态决定位数 第0位默认0占位
  const dp = new Array(amount + 1).fill(Infinity)

  dp[0] = 0

  for (let i = 1; i <= amount; i++) {
    for(let coin of coins) {
      if (coin < i) {
        dp[i] = Math.min(dp[i - coin] + 1, dp[i])
      }
    }
  }

  // dp[amount] === Infinity 说明没有最优解返回-1
  return dp[amount] === Infinity ? -1 : dp[amount]
}
```
