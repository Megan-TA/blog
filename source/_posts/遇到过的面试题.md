---
title: 遇到过的面试题
catalog: true
date: 2020-03-17 15:19:07
subtitle:
header-img:
tags: javascript
---

## 头条面试题

### 什么是闭包？应用？优缺点？如何释放？

### Event Loop

### Promise 介绍？api？缺点？

### let const var

### 如何实现 let

### vue 的 v-model 实现

### 虚拟 DOM 实现？优点？

### 同源策略？跨域？

### koa 中间件实现原理

### webpack 大概流程

### webpack plugin loader 区别

### mock 模拟真实增删改查

### typescript 的 pick emit

### 链表和数组区别

链表是动态分配内存，数组是静态分配内存

链表是内存中不连续的组合，数组在内存中连续

链表查找复杂度 O(n)，增删改 O(1) 数组查找复杂度 O(1)，增删改 O（n）

示例：

React 的 fiber 架构就是利用链表，先执行一段逻辑之后处理其他逻辑，再去处理后续逻辑

### 不固定高度的弹窗垂直居中

### flex 1 是有哪些组成

flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。

flex-grow：项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。

flex-shrink：项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。

### 如何解决盒子高度塌陷问题

BFC

### 发布订阅实现

```javascript
class Emitter {
  constuctor() {
    this.queue = [];
  }

  on(obj) {
    this.queue.push(obj);
  }

  notify() {
    this.queue.forEach(obj => obj.fn());
  }

  off(name) {
    const index = this.queue.indexOf(obj => obj.name === name);
    this.queue.splice(index, 1);
  }
}

const emitter = new Emitter();
emitter.on({
  name: "test1",
  fn: () => {}
});

emitter.on({
  name: "test2",
  fn: () => {}
});

emitter.notify();
emitter.off("test2");
```

## 代码题

连续多次触发只会执行一次

```javascript
function singlePipe(promiseFunc) {
  // TODO实现   start
  let status = 0;
  if (status === 1) return Promise.reject();
  return data =>
    new Promise(resolve => {
      status = 1;
      resolve(promiseFunc(data));
    }).then(() => (status = 0));

  // TODO实现   end
}
var promiseFunc = function(data) {
  return new Promise(resolve => {
    window.setTimeout(() => resolve(data), 1000);
  });
};

var request = singlePipe(promiseFunc);
request(1).then(data => console.log(data)); // 1
request(2).then(data => console.log(data)); // 无反应
window.setTimeout(() => {
  request(3).then(data => console.log(data)); // 3
}, 1000);
```

## 二面

### 中台项目遇到的难点

### 介绍一个比较复杂的项目

### 左右两个盒子宽度固定，中间盒子宽度自适应

### 算法题 1

```javascript
// 一本书的目录会有很多章节，每个章节下又会有一些子章节，由此可以形成一个章节树，实现一个序列化函数serialize，输出包含所有章节名称的一维数组，同时根据每个章节所在的层级，在章节名称前面加上该章节所在的层级结构
var chapterTree = {
  name: "总章节",
  children: [
    {
      name: "章节一",
      children: [
        {
          name: "第一节",
          children: [{ name: "第一小节" }, { name: "第二小节" }]
        },
        { name: "第二节" }
      ]
    },
    {
      name: "章节二",
      children: [{ name: "第三节" }, { name: "第四节" }]
    }
  ]
};

function serialize(tree) {
  // TODO
}

// 测试
const result = serialize(chapterTree);
console.log(result); // ["总章节", "(1)章节一", "(1.1)第一节", "(1.1.1)第一小节", "(1.1.2)第二小节", "(1.2)第二节", "(2)章节二", "(2.1)第三节", "(2.2)第四节"]
```

### 算法题 2

多维数组平铺为一维数组

```javascript
let finalArr = [];
function flattenArr(arr) {
  // 代码实现
  for (let i = 0; i < arr.length - 1; i++) {
    const item = arr[i];

    if (item instanceof Array) {
      flattenArr(item);
    } else {
      finalArr.push(item);
    }
  }
  return arr;
}

var arr = [1, [2, [3, 4]], [5, 6], 7];
var newArr = flattenArr(arr);
console.log(newArr);
```

## 三面

### url 输入经历过什么过程

### 前端优化

### 图片有哪些格式，各个格式有什么特点

### 算法题

- 对一个单向链表反转

- 一个无序数组，要求一次遍历得到第二大元素

```javascript
function find(arr) {
  let maxItem = arr[0];
  let seconditem = arr[1];

  if (maxItem < seconditem) {
    let temp = seconditem;
    seconditem = maxItem;
    maxItem = temp;
  }

  for (let i = 2; i < arr.length - 1; i++) {
    const item = arr[i];
    if (item > maxItem) {
      let temp = maxItem;
      maxItem = item;
      seconditem = maxItem;
    } else if (item > seconditem) {
      seconditem = item;
    }
  }

  return seconditem;
}
```

---

## teambition 面试题

### 完整的 CI/CD 流程设计

### Git commit 规范

### 如何理解中台对前台的价值

### 写过的 webpack|babel 等插件？

### webpack loader 和 plugin 区别

### 跨域

### typescript 泛型？泛型约束？

### typescript 联合类型还有啥类型？？？

### aop 和 ait？

### 组件单测流程？如何判断 state 表现？如何判断回调是否触发？

### vdom 介绍？优点？

### Event loop

---

## Bilibili

### new 过程

---
