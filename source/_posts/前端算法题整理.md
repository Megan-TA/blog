---
title: 前端算法题整理
catalog: true
date: 2019-12-16 18:52:54
subtitle:
header-img:
tags: 算法
---

## 两个有序数组合并成一个有序数组

```javascript
var a = [1, 7, 10];
var b = [2, 4, 12, 16];

function merge(arg1, arg2) {
  var m = arg1.length;
  var n = arg2.length;

  while (n > 0) {
    // 原数组的数比插入的数组数大 则将最大的数往后移动到 n+m-1位置
    // 对应的数组索引减一，继续和两一个数组的值比较
    // 一定是要用插入的数组的值和待插入的值去做判断
    if (arg1[m - 1] > arg2[n - 1]) {
      arg1[n + m - 1] = arg1[m - 1];
      m--;
    } else {
      arg1[n + m - 1] = arg2[n - 1];
      n--;
    }
  }

  return arg1;
}
```

## 斐波那契数列

斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N\*）

```javascript
// 第一版本 非递归 数值过大存在栈溢出问题 fib(30) => 0.36ms
function fib(nMonth) {
  return nMonth <= 2
    ? 1
    : arguments.callee(nMonth - 1) + arguments.callee(nMonth - 2);
}

// 第二版本

// 严格模式下 利用尾递归优化 即只会有一个调用帧 永远不会存在栈溢出问题  // fib(30) => 0.02ms
function fib(n, ac1 = 0, ac2 = 1) {
  if (nMonth <= 1) return ac2;

  return fib(n - 1, ac2, ac1 + ac2);
}

// 正常模式 借助蹦床函数
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}

function fib(n, ac1 = 0, ac2 = 1) {
  if (n <= 1) return ac2;
  // bind 不让函数立刻执行
  return fib.bind(null, n - 1, ac2, ac1 + ac2);
}

trampoline(fib(5));

参考资料：

[es6尾调用优化](https://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96)

```

## 冒泡排序

1、比较相邻的两个元素，如果前一个比后一个大，则交换位置。
2、比较完第一轮的时候，最后一个元素是最大的元素。
3、这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。

```javascript
function pop(arr) {
  for (let i = 0; i <= arr.length - 1; i++) {
    for (let j = 0; j <= arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}
```

## 快速排序

```javascript
// 递归版本实现
function quick(arr) {
  if (arr.length === 0) return arr;
  let p = arr[0];
  let leftArr = [];
  let rightArr = [];
  for (let i = 1; i <= arr.length - 2; i++) {
    if (arr[i] > p) {
      rightArr.push(arr[i]);
    } else {
      leftArr.push(arr[i]);
    }
  }

  return quick(leftArr).concat(p, quick(rightArr));
}

/**
 * 非递归
 * 默认选取第一个为基数
 * 从起点往后寻找比基数大的，记录为下标 i；再从终点往前寻找比基数小的，记录为下标 j，当 i <= j时，原地交换数值
 */

function quickSort(num) {
  _quickSort(num, 0, num.length - 1);
}
/**
 * 快速排序(递归)
 * @param num 待排序数组
 * @param left 左指针
 * @param right 右指针
 */
function _quickSort(num, left, right) {
  if (left >= right) return; // 若左右指针相遇，待排序数组长度小宇1，即递归的终点，return(注意不能写成left==right，这里left是有可能大于right的)。
  var i = left,
    j = right,
    flag = left;
  while (i < j) {
    // 在i<j时不断循环，i一旦与j碰头，则跳出循环。
    while (num[j] >= num[flag] && j > flag) j--; // j不断左移，找到在num[flag]右侧且比它大的数。
    if (i >= j) {
      break; // 由于j可能已被改变，需再次判断i与j是否碰头。
    }
    while (num[i] <= num[flag] && i < j) i++; // i不断右移，找到且比基数小的数，且i不能与j碰头。(由于两次交换已合并，此处不需要使得i在flag左侧)
    // num[flag] num[j] num[i]三者换位，可用ES6语法糖[num[flag],num[j],num[i]] = [num[j],num[i],num[flag]];
    let temp = num[flag];
    num[flag] = num[j];
    num[j] = num[i];
    num[i] = temp;
    flag = i; // 基数已经在原num[i]的位置，flag同时也要赋值成i。
  }
  _quickSort(num, left, flag - 1);
  _quickSort(num, flag + 1, right);
}

/**
 *
 * 网上版本
 */

var quickSort_New = function(ary, left, right) {
  if (left >= right) {
    return ary;
  }

  let i = left;
  let j = right;
  let base = ary[left]; // 基数

  while (i < j) {
    while (i < j && ary[j] >= base) {
      j--;
    }

    while (i < j && ary[i] <= base) {
      i++;
    }

    if (i < j) {
      var temp = ary[i];
      ary[i] = ary[j];
      ary[j] = temp;
    }
  }

  ary[left] = ary[i];
  ary[i] = base;

  quickSort_New(ary, left, i - 1);
  quickSort_New(ary, i + 1, right);

  return ary;
};

const arr = [1, 5, 7, 2, 7, 9, 2, 7, 10];
quickSort_New(arr, 0, arr.length - 1);
```

## 二叉树查找

```javascript
// 二叉树数据源
var treeNodes = [
  {
    id: 1,
    name: "1",
    children: [
      {
        id: 11,
        name: "11",
        children: [
          {
            id: 111,
            name: "111",
            children: []
          },
          {
            id: 112,
            name: "112"
          }
        ]
      },
      {
        id: 12,
        name: "12",
        children: []
      }
    ],
    users: []
  },
  {
    id: 2,
    name: "2",
    children: [
      {
        id: 22,
        name: "22",
        children: []
      }
    ]
  }
];
```

要求：算出所有 id

- 深度优先

```javascript
// 递归 => 深度优先
function deepCalleen(treeNodes) {
  treeNodes.forEach((treeNode, index) => {
    console.log(treeNode.id);
    if (treeNode.children && treeNode.children.length) {
      deepCalleen(treeNode.children);
    }
  });
}
```

```javascript
// 非递归 => 深度优先
// 数据结构拍平 遍历有children加到数组之前
function deep(treeNodes) {
  let stack = treeNodes.map(treeNode => treeNode);

  while (stack.length) {
    const stackItem = stack.shift();
    console.log(stackItem.id);
    if (stackItem.children && stackItem.children.length) {
      stack = stackItem.children.concat(stack);
    }
  }
}
```

- 广度优先

```javascript
// 非递归 => 广度优先
// 数据结构拍平 遍历有children加到数组之前
function spans(treeNodes) {
  let stack = treeNodes.map(treeNode => treeNode);

  while (stack.length) {
    const stackItem = stack.shift();
    console.log(stackItem.id);
    if (stackItem.children && stackItem.children.length) {
      stack = stack.concat(stackItem.children);
    }
  }
}

spans(treeNodes);
```

## 查看无限大数组中第 k 个大的元素

```javascript
// 无限大排除sort之后取倒数k个索引方法
// [1,5,4,7,2]
// k = 2
// 结果：5

// 解法1 冒泡排序
function searchK(arr = [], k) {
  let temp;
  for (let i = 0; i < k; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
    return arr[arr.length - k];
  }
}
```

参考资料：

[十大经典排序算法总结（JavaScript 描述）](https://juejin.im/post/57dcd394a22b9d00610c5ec8#heading-30)

[前端该如何准备数据结构和算法？](https://juejin.im/post/5d5b307b5188253da24d3cd1#heading-42)
