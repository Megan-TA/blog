---
title: 堆排序入门
catalog: true
date: 2020-12-02 11:06:43
subtitle:
header-img:
tags: algorithm
categories: 前端
---

## 简介

  堆排序是指利用堆这种数据结构所设计的一种排序算法。
  利用最大堆实现升序, 最小堆实现降序。
  因为最大堆的根父节点一定是最大的, 让它和队尾元素互换, 然后在从堆中排除最后一个元素, 并复原最大堆，循环 n-1次。
  
## 堆的特点

- 堆是一个近似完全二叉树的结构；
- 堆分为 最大堆和最小堆；
- 最大堆父节点都大于子节点，最小堆父节点都小于子节点；
- 第i个元素的左子节点：2*i + 1  （i为父节点index）
- 第i个元素的右子节点：2*i + 2
- 第i个元素的父节点： (n - 1) / 2
- 最后一个非叶子节点为 Math.floor(arr.length / 2) - 1

## 过程

### 基本过程

max_heapify 过程：其时间复杂度为O(lgn)

build_max_heap 过程：从无序数组构建最大堆。具有线性时间复杂度。

heap_sort 过程：堆排序过程。时间复杂度是O(nlgn)

堆排序的关键点在于如何构建最大堆

### 堆排序原理

1.首先，构建最大堆，此时堆的大小与数组大小相等，

2.然后，把堆顶元素（堆中最大的元素 a ）与堆尾元素交换，

3.此时 a 元素已经放到了正确的位置，

4.堆的大小减去1，

5.对堆顶的元素执行 max_heapify 过程，维持最大堆的性质。之后堆顶又是目前堆中的最大元素了。

6.从 步骤2 循环，直到堆中只剩下一个元素（该元素是数组中最小元素，且此时位于下标 0 的位置）

示意图如下：

![最大堆的构建过程](https://i.loli.net/2020/03/21/Mqn8abVcAim9GTu.png)

## 实现

```javascript
let arrs = [7, 1, 13, 9, 11, 5, 8]

console.log(`原始序列：`, arrs)

const newArrs = heapSort(arrs)

console.log(`排序后：`, arrs)

function swap(arr, i, j) {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

// 堆调整
function maxHeapify(arr, i, len) {
    let left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i

    if (left < len && arr[left] > arr[largest]) largest = left
    if (right < len && arr[right] > arr[largest]) largest = right

    // 不等于初始值 说明左右节点有比原先父节点大的数值
    if (largest !== i) {
        swap(arr, i, largest)
        // 原先的父节点位置和现在父节点交换位置后 在原先的节点位置处是否还是最大值 需要判断比较
        maxHeapify(arr, largest, len)
    }
}

// 构建最大堆（大顶堆）
function buildMaxHeap(arr = []) {
    // 初始化最大堆 从最后一个非叶子节点开始
    for(let i = Math.floor(arr.length / 2 - 1); i >= 0; i--) {
        maxHeapify(arr, i, arr.length)
    }
}

// 堆排序
function heapSort(arr) {
    if (!arr || arr.length === 0) return new Error('数组为null或者长度为0')
    let newArr = []

    buildMaxHeap(arr)

    // 大顶堆的第一个元素与堆内最后一个元素交换位置 并将堆大小-1 循环n-1次
    for(let i = arr.length - 1; i > 0; i--) {
        newArr.push(arr[0])
        swap(arr, 0, i)
        arr.length--
        maxHeapify(arr, 0, arr.length)
    }

    return newArr
}

```

## 时间复杂度

buildMaxHeap使用O(N)的时间，元素下滤需要O(logN)，需要下滤N-1次，所以总共需要O(N + (N - 1)logN) = O(NlogN)。所以复杂度稳定在O(NlogN)。
