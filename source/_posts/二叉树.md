---
title: 二叉树
catalog: true
date: 2020-03-15 22:22:18
subtitle:
header-img:
tags: 算法
---

二叉树遍历主要分为深度遍历和广度遍历，一共有四种遍历方式。

其中深度遍历分为：

- 前序遍历： 访问根–>遍历左子树–>遍历右子树;
- 中序遍历： 遍历左子树–>访问根–>遍历右子树
- 后序遍历： 遍历左子树–>遍历右子树–>访问根

主要就是根据遍历根的访问顺序决定何种顺序

![二叉树](https://user-gold-cdn.xitu.io/2016/12/7/59115f76fbe825eea6de6a1749a8f5df.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 前序遍历： - + a \* b c / d e
- 中序遍历： a + b \* c - d / e
- 后续遍历： a b c \* + d e / -
- 层次遍历： - + / a \* d e b c

数据结构表示如下：

```javascript
var treeNode = {
  value: "-",
  left: {
    value: "+",
    left: {
      value: "a"
    },
    right: {
      value: "*",
      left: {
        value: "b"
      },
      right: {
        value: "c"
      }
    }
  },
  right: {
    value: "/",
    left: {
      value: "d"
    },
    right: {
      value: "e"
    }
  }
};
```

## 前序遍历

- 递归

```javascript
let finalTreeNodeArr = [];

function popNode(treeNode) {
  if (treeNode) {
    finalTreeNodeArr.push(treeNode.value);
    popNode(treeNode.left);
    popNode(treeNode.right);
  }
}
```

- 非递归

```javascript
let finalTreeNodeArr = [];

function popNode(treeNode) {
  if (treeNode) {
    let stack = [treeNode];
    while (stack.length) {
      // 注意 从最后弹出
      let node = stack.pop();
      finalTreeNodeArr.push(node.value);
      // 先遍历右边节点 在遍历左边节点
      if (node.right) stack.push(node.right);
      if (node.left) stack.push(node.left);
    }
  }
}
```

## 中序遍历

- 递归

```javascript
let finalTreeNodeArr = [];

function popNode(treeNode) {
  if (treeNode) {
    popNode(treeNode.left);
    finalTreeNodeArr.push(treeNode.value);
    popNode(treeNode.right);
  }
}
```

- 非递归

```javascript
let finalTreeNodeArr = [];

function popNode(node) {
  if (node) {
    var stack = [];
    while (stack.length !== 0 || node) {
      //如果栈不为空或结点不为空，则循环遍历
      if (node) {
        stack.push(node);
        node = node.left;
      } else {
        //左子树为空，即没有左子树的情况
        node = stack.pop();
        inListUnRec.push(node.value);
        node = node.right;
      }
    }
  }
}
```

## 后序遍历

- 递归

```javascript
let finalTreeNodeArr = [];

function popNode(treeNode) {
  if (treeNode) {
    popNode(treeNode.left);
    popNode(treeNode.right);
    finalTreeNodeArr.push(treeNode.value);
  }
}
```

- 非递归

```javascript
let finalTreeNodeArr = [];

const popNode = root => {
  // 记录val值
  let res = [];
  let stack = [];
  while (root || stack.length) {
    // 依次向数组中插入一个val值
    res.unshift(root.val);

    if (root.left) stack.push(root.left);
    if (root.right) stack.push(root.right);
    // 取出数组最后一个值为根节点
    root = stack.pop();
  }
  return res;
};
```

## 广度遍历

```javascript
let finalTreeNodeArr = [];

function popNode(treeNode) {
  if (treeNode) {
    let stack = [treeNode];
    while (stack.length) {
      // 从前弹出元素 和 前序遍历不同
      let node = stack.shift();
      finalTreeNodeArr.push(node.value);
      // 先加入左节点 后加入右节点
      if (node.left) stack.push(node.left);
      if (node.right) stack.push(node.right);
    }
  }
}
```

---

## 判断对称二叉树

对称二叉树就是镜像二叉树

比如：

![对称二叉树](https://img-blog.csdnimg.cn/20190625104849486.png)

代码模拟一个对称和非对称二叉树如下：

```javascript
//对称二叉树
const symmetricalTree = {
  val: 8,
  left: {
    val: 6,
    left: { val: 5, left: null, right: null },
    right: { val: 7, left: null, right: null }
  },
  right: {
    val: 6,
    left: { val: 7, left: null, right: null },
    right: { val: 5, left: null, right: null }
  }
};

const noSymmetricalTree = {
  val: 8,
  left: {
    val: 6,
    left: { val: 5, left: null, right: null },
    right: { val: 7, left: null, right: null }
  },
  right: {
    val: 6,
    left: { val: 7, left: null, right: null },
    right: { val: 9, left: null, right: null }
  }
};
```

递归判断

```javascript
function isMirrorTreeNodes(treeNodes) {
  return isMirrorNode(treeNodes.left, treeNodes.right);
}

function isMirrorNode(leftNode, rightNode) {
  // 左右节点都不存在
  if (!leftNode && !rightNode) return true;

  // 左右节点只有一个存在
  if (!leftNode || !rightNode) return false;

  if (leftNode.val !== rightNode.val) return false;

  return (
    isMirrorNode(leftNode.left, rightNode.right) &&
    isMirrorNode(leftNode.right, rightNode.left)
  );
}
```

参考资料：

[二叉树与 JavaScript](https://juejin.im/entry/5847c17a128fe10058bcf2c5)
