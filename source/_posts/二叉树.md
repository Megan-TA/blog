---
title: 二叉树
catalog: true
date: 2020-03-15 22:22:18
subtitle:
header-img:
tags: algorithm
categories: 前端
---

二叉树遍历主要分为深度遍历和广度遍历，一共有四种遍历方式。

其中深度遍历分为：

- 前序遍历： 访问根–>遍历左子树–>遍历右子树;
- 中序遍历： 遍历左子树–>访问根–>遍历右子树
- 后序遍历： 遍历左子树–>遍历右子树–>访问根

主要就是根据遍历根的访问顺序决定何种顺序

[![8cvQSI.png](https://s1.ax1x.com/2020/03/20/8cvQSI.png)](https://imgchr.com/i/8cvQSI)

- 前序遍历： - + a \* b c / d e
- 中序遍历： a + b \* c - d / e
- 后续遍历： a b c \* + d e / -
- 层次遍历： - + / a \* d e b c

数据结构表示如下：

```javascript
var treeNode = {
  value: "-",
  left: {
    value: "+",
    left: {
      value: "a"
    },
    right: {
      value: "*",
      left: {
        value: "b"
      },
      right: {
        value: "c"
      }
    }
  },
  right: {
    value: "/",
    left: {
      value: "d"
    },
    right: {
      value: "e"
    }
  }
};
```

## 前序遍历

- 递归

```javascript
let finalTreeNodeArr = [];

function popNode(treeNode) {
  if (treeNode) {
    finalTreeNodeArr.push(treeNode.value);
    popNode(treeNode.left);
    popNode(treeNode.right);
  }
}
```

- 非递归

1. 依次遍历数组，每次取数组最后一个值；
2. 一次遍历中，每次先判断是否有右节点，有的话插入到数组末尾，再判断左节点，有的话再插入到数组末尾；
3. 依次循环；

整体流程如下：

1. [{left, right }];
2. [right, left]
3. [right, right, left]

```javascript
function firstPop(root) {
  const stack = [];
  const result = [];

  while (root || stack.length) {
    result.push(root.value);

    // 注意顺序 先要取右节点
    if (root.right) stack.push(root.right);
    if (root.left) stack.push(root.left);

    root = stack.pop();
  }
  console.log("先序遍历：", result);
  return result;
}
```

## 中序遍历

- 递归

```javascript
let finalTreeNodeArr = [];

function popNode(treeNode) {
  if (treeNode) {
    popNode(treeNode.left);
    finalTreeNodeArr.push(treeNode.value);
    popNode(treeNode.right);
  }
}
```

- 非递归

```javascript
function middlePop(root) {
  const stack = [];
  const result = [];

  while (root || stack.length) {
    // 一直遍历是否有左节点 入栈
    while (root) {
      stack.push(root);
      root = root.left;
    }

    root = stack.pop();

    result.push(root.value);

    root = root.right;
  }
  console.log("中序遍历：", result);
  return result;
}
```

## 后序遍历

- 递归

```javascript
let finalTreeNodeArr = [];

function popNode(treeNode) {
  if (treeNode) {
    popNode(treeNode.left);
    popNode(treeNode.right);
    finalTreeNodeArr.push(treeNode.value);
  }
}
```

- 非递归

```javascript
function endPop(root) {
  const stack = [];
  const result = [];

  while (root || stack.length) {
    result.unshift(root.value);

    if (root.left) stack.push(root.left);
    if (root.right) stack.push(root.right);

    root = stack.pop();
  }
  console.log("后序遍历：", result);
  return result;
}
```

## 广度遍历

```javascript
function deepPop(root) {
  const stack = [];
  const result = [];

  while (root || stack.length) {
    result.push(root.value);

    if (root.left) stack.push(root.left);
    if (root.right) stack.push(root.right);

    root = stack.shift();
  }
  console.log("广度遍历：", result);
  return result;
}
```

总结：

1. 先序非递归 要先存右节点 后存左节点；
2. 后序非递归 unshift 插值；

---

## 判断对称二叉树

对称二叉树就是镜像二叉树

比如：

![对称二叉树](https://img-blog.csdnimg.cn/20190625104849486.png)

代码模拟一个对称和非对称二叉树如下：

```javascript
//对称二叉树
const symmetricalTree = {
  val: 8,
  left: {
    val: 6,
    left: { val: 5, left: null, right: null },
    right: { val: 7, left: null, right: null }
  },
  right: {
    val: 6,
    left: { val: 7, left: null, right: null },
    right: { val: 5, left: null, right: null }
  }
};

const noSymmetricalTree = {
  val: 8,
  left: {
    val: 6,
    left: { val: 5, left: null, right: null },
    right: { val: 7, left: null, right: null }
  },
  right: {
    val: 6,
    left: { val: 7, left: null, right: null },
    right: { val: 9, left: null, right: null }
  }
};
```

递归判断

```javascript
function isMirrorTreeNodes(treeNodes) {
  return isMirrorNode(treeNodes.left, treeNodes.right);
}

function isMirrorNode(leftNode, rightNode) {
  // 左右节点都不存在
  if (!leftNode && !rightNode) return true;

  // 左右节点只有一个存在
  if (!leftNode || !rightNode) return false;

  if (leftNode.val !== rightNode.val) return false;

  return (
    isMirrorNode(leftNode.left, rightNode.right) &&
    isMirrorNode(leftNode.right, rightNode.left)
  );
}
```

参考资料：

[二叉树与 JavaScript](https://juejin.im/entry/5847c17a128fe10058bcf2c5)
