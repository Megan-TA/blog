{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/article/tag.png","path":"img/article/tag.png","modified":1,"renderable":0},{"_id":"themes/hu/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/hu/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/hu/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/hu/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/hu/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/hu/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/hu/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/hu/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/hu/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/hu/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/hu/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/hu/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/hu/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/hu/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/hu/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/hu/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/hu/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":1,"renderable":0},{"_id":"themes/hu/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/hu/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/hu/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"themes/hu/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/hu/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/hu/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/hu/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/avatar/ironman.png","path":"img/avatar/ironman.png","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/article/huweihuang_blog.png","path":"img/article/huweihuang_blog.png","modified":1,"renderable":0},{"_id":"source/img/blog.jpg","path":"img/blog.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":1,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1563847051723},{"_id":"themes/hu/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1563847051866},{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1563847051723},{"_id":"themes/hu/_config.yml","hash":"e800e32847df32dacddb5202823a004557023bcd","modified":1563847051867},{"_id":"source/about/index.md","hash":"56b5f984a91bba5206db3b3fe1b1a02cf6f830e7","modified":1563847051737},{"_id":"source/_posts/centos下利用nvm安装node.md","hash":"6e23fd302849fd653ad441b9d5ee43599f5483a6","modified":1563950696567},{"_id":"source/_posts/centos下开机自动重启服务和脚本.md","hash":"9156114c42ea391ec849408a8565f884cdb659c7","modified":1563847051724},{"_id":"source/_posts/docker基本使用.md","hash":"cfecf7ae5ef68eef3c5233d8062a4fef05ebf70b","modified":1567568435849},{"_id":"source/_posts/git常用命令.md","hash":"7d2a2794670f6df759d2cc56dbd99e2c370bc3c1","modified":1568967104198},{"_id":"source/_posts/git-submodule.md","hash":"b906140520df7411ecb8cbe466dce79281002aae","modified":1563847051727},{"_id":"source/_posts/js知识点总结.md","hash":"bb58f0863f86e0efb8377d0bfb5decd2ef10b484","modified":1567145540482},{"_id":"source/_posts/js继承问题总结.md","hash":"8498df3ce598d69ca07ea3f6fa7cff9ed9e1fc31","modified":1569379793341},{"_id":"source/_posts/js中几种设计模式.md","hash":"302889da49a4891d763abe5554edddcab0df9359","modified":1563847051728},{"_id":"source/_posts/python爬虫框架scrapy.md","hash":"bf3035f160e50f686ef67750343c0eb7f198225a","modified":1568879088387},{"_id":"source/_posts/pm2常用命令整理.md","hash":"58358ca2e8881715655cf8987d196b0bfc9bcf29","modified":1564065600136},{"_id":"source/_posts/linux常用指令记录.md","hash":"07c1713eb8f7159117bb55572a5c284a87e63c52","modified":1564114239060},{"_id":"source/_posts/rollup-js使用.md","hash":"5f2a53ede7f2a94ab99370751a4f2fff2c6a2553","modified":1569382187962},{"_id":"source/_posts/nginx入门.md","hash":"94e8da68bf2a9079bb027014a3ab74353bc09809","modified":1564637883299},{"_id":"source/_posts/react-vue中dom-diff简易版实现.md","hash":"e2596d658de1c39b12896e5b0fb36ec21431ceda","modified":1563847051729},{"_id":"source/_posts/vue项目接入sentry.md","hash":"72222665ee9e929cd9c810b695d00fa9c213b33d","modified":1572167331082},{"_id":"source/_posts/一些新的api.md","hash":"25b0ef488e660f2fac3143b2b4260cc3f4f6b7be","modified":1563847051730},{"_id":"source/_posts/利用verdaccio搭建私有npm仓库.md","hash":"82acd8cc995ca3bd275598dd5bd997a9ca889b02","modified":1563847051731},{"_id":"source/_posts/分享个人vscode常用插件.md","hash":"344f32ffb1d7c0c327b94876f5f4e0cda2e8fa5a","modified":1563847051731},{"_id":"source/_posts/常用npm包整理.md","hash":"15eccbe860139982a2eb834dd2e4d8d562fc6f99","modified":1564536793295},{"_id":"source/_posts/前端多项目公共模块管理实践.md","hash":"bbf1786241f78f6d1969c55c86db2fe35ba69f4c","modified":1563847051732},{"_id":"source/_posts/序.md","hash":"f6b814efcc0228443127066d69e86f8340f49dcf","modified":1563847051734},{"_id":"source/_posts/掉坑记录.md","hash":"2cbdab5655a1c28c91bb89d7c1fd5b5221ca4874","modified":1566976393322},{"_id":"source/_posts/记录typescript使用的几个注意点.md","hash":"1732f8dc608efc5fc3d6f61e22223e77170780b1","modified":1569298943964},{"_id":"source/_posts/正则实战.md","hash":"c815534eb271dcd238e0a690940e6d38af932345","modified":1567147104335},{"_id":"source/_posts/记录一次node爬虫开发.md","hash":"2796d42ac0fc09ac363e48d3dbc7b51cb56b7bca","modified":1564066188521},{"_id":"source/_posts/记录工单系统的前端性能优化.md","hash":"04234e9755bd3fbc37dce738d3283d831f2236dc","modified":1563847051736},{"_id":"source/_posts/记录平时jenkins使用遇到的问题.md","hash":"304a275a8640f122405e08d7f0487fbdaeccda6f","modified":1564066500853},{"_id":"source/archive/index.md","hash":"e4c40d8a769b9076bebf7b8a07f20a4e339a4804","modified":1563847051738},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1563847051856},{"_id":"source/tags/index.md","hash":"4e62b153da9d097c43aa29bb1a37586bc47d5a62","modified":1563847051865},{"_id":"themes/hu/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1563847051868},{"_id":"themes/hu/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1563847051868},{"_id":"themes/hu/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1563847051869},{"_id":"themes/hu/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1563847051869},{"_id":"themes/hu/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1563847051870},{"_id":"themes/hu/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1563847051870},{"_id":"themes/hu/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1563847051871},{"_id":"themes/hu/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1563847051871},{"_id":"themes/hu/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1563847051872},{"_id":"themes/hu/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1563847051872},{"_id":"themes/hu/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1563847051881},{"_id":"themes/hu/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1563847051881},{"_id":"themes/hu/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1563847051882},{"_id":"themes/hu/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1563847051883},{"_id":"themes/hu/layout/layout.ejs","hash":"a6f0f1369afaddf5b63cc04589f17dfee409fcd0","modified":1563847051883},{"_id":"themes/hu/layout/post.ejs","hash":"a36524a762090581a858ae55b62ca18e6251876a","modified":1563847051885},{"_id":"themes/hu/layout/page.ejs","hash":"5e588f200a7b7cd3ae40402b0dd3b779aac6787f","modified":1563847051884},{"_id":"themes/hu/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1563847051886},{"_id":"source/_posts/centos下开机自动重启服务和脚本/WX20190708-113220.png","hash":"2ddd3501c319f9cd7848239f1ec6ccfc138ca9cd","modified":1563847051725},{"_id":"source/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1563847051744},{"_id":"themes/hu/layout/_partial/footer.ejs","hash":"e69b7c4a446db77588b981521471194dff5fc5f7","modified":1563847051873},{"_id":"themes/hu/layout/_partial/head.ejs","hash":"7858f29b52340f2ba2fc52733167c802028820e5","modified":1563847051874},{"_id":"themes/hu/layout/_partial/header.ejs","hash":"3bd09df76e0622d76d186b020393fcab361e6c97","modified":1563847051874},{"_id":"themes/hu/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1563847051875},{"_id":"themes/hu/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1563847051875},{"_id":"themes/hu/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1563847051876},{"_id":"themes/hu/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1563847051876},{"_id":"themes/hu/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1563847051877},{"_id":"themes/hu/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1563847051878},{"_id":"themes/hu/layout/_widget/featured-tags.ejs","hash":"229b58f185955a9bfbc658fd00b3e7f3c69cbb2c","modified":1563847051878},{"_id":"themes/hu/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1563847051879},{"_id":"themes/hu/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1563847051879},{"_id":"themes/hu/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1563847051880},{"_id":"themes/hu/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1563847051887},{"_id":"themes/hu/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1563847051888},{"_id":"themes/hu/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1563847051888},{"_id":"themes/hu/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1563847051892},{"_id":"themes/hu/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1563847051893},{"_id":"themes/hu/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1563847051893},{"_id":"themes/hu/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1563847051895},{"_id":"themes/hu/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1563847051896},{"_id":"themes/hu/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1563847051896},{"_id":"themes/hu/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1563847051897},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1563847051898},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1563847051901},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1563847051900},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1563847051901},{"_id":"themes/hu/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1563847051905},{"_id":"themes/hu/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1563847051905},{"_id":"themes/hu/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1563847051904},{"_id":"themes/hu/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1563847051909},{"_id":"themes/hu/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1563847051909},{"_id":"themes/hu/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1563847051909},{"_id":"themes/hu/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1563847051909},{"_id":"source/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1563847051797},{"_id":"themes/hu/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1563847051891},{"_id":"themes/hu/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1563847051904},{"_id":"themes/hu/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1563847051908},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1563847051799},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1563847051802},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1563847051863},{"_id":"themes/hu/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1563847051889},{"_id":"themes/hu/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1563847051894},{"_id":"themes/hu/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1563847051894},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1563847051899},{"_id":"themes/hu/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1563847051907},{"_id":"source/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1563847051768},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1563847051859},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1563847051747},{"_id":"source/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1563847051744},{"_id":"source/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1563847051777},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1563847051826},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1563847051855},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1563847051762},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1563847051817},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1563847051845},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1563847051794},{"_id":"public/post-sitemap.xml","hash":"ff5b88d3812eaac7a466730189d44775fa648864","modified":1572167473693},{"_id":"public/page-sitemap.xml","hash":"9e74fe36f8e54d64c87dad7ab23f2786c9d0e4dc","modified":1572167473693},{"_id":"public/tag-sitemap.xml","hash":"253c7f4613018ddb2b2833f4af2d7843f50ff186","modified":1572167474110},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1572167474111},{"_id":"public/sitemap.xml","hash":"b3e696cd26ce5f4e00468abc5d0bd5fbea616e44","modified":1572167474238},{"_id":"public/404.html","hash":"65713d36d462bc378eb17c066ec6e04b1fe2af74","modified":1572167474276},{"_id":"public/2019/08/28/掉坑记录/index.html","hash":"2f865fe6099a7b1b55d7a727083dd6f3edeafbc9","modified":1572167474277},{"_id":"public/2019/07/24/centos下利用nvm安装node/index.html","hash":"746a2b7d442ef7743949414dd29ec8cbe3359d56","modified":1572167474339},{"_id":"public/2019/07/22/一些新的api/index.html","hash":"f5bdd074a97e960560daba331cb47f5e163e1a64","modified":1572167474340},{"_id":"public/2019/07/22/记录工单系统的前端性能优化/index.html","hash":"f18dbf2196ba2c5d2a18e03d906456485fde6be7","modified":1572167474362},{"_id":"public/tags/index.html","hash":"53fea446be7dc94059e3853b662041315f12cbcc","modified":1572167474363},{"_id":"public/2019/08/30/正则实战/index.html","hash":"e63992ae96d5d5a8229c293c1116b42de648e002","modified":1572167474363},{"_id":"public/2019/07/25/pm2常用命令整理/index.html","hash":"5b61ed944db4e318fbd4530f8bfb08871b8d1148","modified":1572167474364},{"_id":"public/2019/07/22/记录typescript使用的几个注意点/index.html","hash":"ffaa39a52bc9f92b73d87bc93c0023c8a6bafc52","modified":1572167474364},{"_id":"public/2019/07/14/js中几种设计模式/index.html","hash":"052d4540460d3e9094ab5ee5c0e396595ada25d8","modified":1572167474364},{"_id":"public/2019/07/10/git-submodule/index.html","hash":"07e0ca9e010f1daca3ceb181208e55c6f70320c7","modified":1572167474364},{"_id":"public/2019/07/08/centos下开机自动重启服务和脚本/index.html","hash":"614982d11ceb6c495f8e517a8b5c6d5fb0fd7612","modified":1572167474364},{"_id":"public/2019/07/03/常用npm包整理/index.html","hash":"ae5ac69631c8f5ff25b785ed9c2c37396191c8c1","modified":1572167474364},{"_id":"public/2019/06/21/前端多项目公共模块管理实践/index.html","hash":"6e44edf7eae093283d2a8014f2d9961986c8d908","modified":1572167474364},{"_id":"public/2019/06/20/react-vue中dom-diff简易版实现/index.html","hash":"bde2b8b77cbca99e7c9e2e9adcf8d33b0184726b","modified":1572167474364},{"_id":"public/2019/06/19/docker基本使用/index.html","hash":"0e57090c8af666d224d66d707c5cc12b73221708","modified":1572167474364},{"_id":"public/2019/06/19/python爬虫框架scrapy/index.html","hash":"b05125adce26471f2da04f24b8a0185d15e4da29","modified":1572167474364},{"_id":"public/2019/06/19/分享个人vscode常用插件/index.html","hash":"ada1a60b0261e25ab1f998a53cde113adf2d04e5","modified":1572167474364},{"_id":"public/2019/06/19/nginx入门/index.html","hash":"379441748f42a828d447e5f9491541b192ed0d88","modified":1572167474365},{"_id":"public/2019/06/16/利用verdaccio搭建私有npm仓库/index.html","hash":"f5013677f89a2d485cf194cadf73e83f2570be31","modified":1572167474365},{"_id":"public/2019/06/15/序/index.html","hash":"d1611a0a10ba72c79fa49dfdfe9fa555efd36b94","modified":1572167474365},{"_id":"public/2019/05/21/记录平时jenkins使用遇到的问题/index.html","hash":"e71f4da0687b652eb8f76528257b34f1c5c59eab","modified":1572167474365},{"_id":"public/2019/05/07/记录一次node爬虫开发/index.html","hash":"a197d4607f57c88a45b6f00e078ae8e57ec898c1","modified":1572167474365},{"_id":"public/2019/04/25/git常用命令/index.html","hash":"e469f0f78cc214d1286025317513d26a55778ae9","modified":1572167474365},{"_id":"public/2019/03/25/linux常用指令记录/index.html","hash":"a4a63adb3a4394f8094a3029576662f673b63bd8","modified":1572167474365},{"_id":"public/2018/07/21/js知识点总结/index.html","hash":"9497db6eb02971f3a1324606341eb78508ca9b41","modified":1572167474365},{"_id":"public/about/index.html","hash":"b9a911feec84fa09fd6586e80ee66bc0e4134948","modified":1572167474365},{"_id":"public/archive/index.html","hash":"332952a4fc5119e7b3d59f0b58911295430ca673","modified":1572167474365},{"_id":"public/index.html","hash":"a7afc9655a4c4be51379bd55fceab88671f05ac3","modified":1572167474366},{"_id":"public/archives/2/index.html","hash":"c416bb929deb097ba1a6427a62f9e88dbb4a6274","modified":1572167474366},{"_id":"public/archives/3/index.html","hash":"7a7cf677b6fdec09b1ff49b3f4784cc11c68c189","modified":1572167474366},{"_id":"public/tags/linux/index.html","hash":"24f3a0cd330ef2506e6051b503b1c72cf11a627d","modified":1572167474366},{"_id":"public/tags/git/index.html","hash":"e5909507654946c6d627cdc70dae3b038a3a1502","modified":1572167474366},{"_id":"public/tags/docker/index.html","hash":"6dfa4bfbe8ebef6542f1d8936aaa5d2d52cf42df","modified":1572167474366},{"_id":"public/tags/web/index.html","hash":"17dd2cbd242bcf0a1028c4ccbcbd7728cf8f5386","modified":1572167474366},{"_id":"public/tags/javascript/index.html","hash":"6484c8b7178827f811dd242e67c44fc7fc7dac07","modified":1572167474367},{"_id":"public/tags/python/index.html","hash":"134ce5bd402b4f5982b959b4d83577ec994fc437","modified":1572167474367},{"_id":"public/tags/node/index.html","hash":"0211e4560dfd02ecf9510485ed4b5486d113ae2a","modified":1572167474367},{"_id":"public/tags/vue-react/index.html","hash":"0e33d3c746ec584259489a79b0f37fb4f8f2488c","modified":1572167474367},{"_id":"public/tags/IDE/index.html","hash":"bcc18c596c22bba7105e212de63cac69c8b4ae82","modified":1572167474367},{"_id":"public/tags/npm/index.html","hash":"cc319eaf296216d45156365b4505cce98e1f54cb","modified":1572167474367},{"_id":"public/tags/随笔/index.html","hash":"af45f329f7d924649aab8aa838582757348858cd","modified":1572167474367},{"_id":"public/tags/前端/index.html","hash":"9deee545312bc6834e6c75354abdbeb038a91f7a","modified":1572167474367},{"_id":"public/tags/jenkins/index.html","hash":"3ec0a503bdd63e7879e32631a6857e3cefbaf3b6","modified":1572167474367},{"_id":"public/tags/nginx/index.html","hash":"a254066acb3f66105d7412e7321b5280cc6ca547","modified":1572167474367},{"_id":"public/archives/index.html","hash":"8a3aa235e3bfea1601ef3518f2251bb7a0f0c966","modified":1572167474368},{"_id":"public/archives/archives/2/index.html","hash":"c2cc19ba0dd2f321981efee8d26261aedc4bba97","modified":1572167474368},{"_id":"public/archives/archives/3/index.html","hash":"78d923259eb41367a91966a19f55d8291c8586f2","modified":1572167474368},{"_id":"public/archives/2018/index.html","hash":"b876eeb2901189ba48a5115a88950275e968013c","modified":1572167474368},{"_id":"public/archives/2018/07/index.html","hash":"d24fe0a7dc6681d468a569cbf5ac605457838971","modified":1572167474368},{"_id":"public/archives/2019/index.html","hash":"4c261af2316d0fe79c3523bd9c1fa1de00eaea75","modified":1572167474368},{"_id":"public/archives/2019/archives/2/index.html","hash":"9a0991059c0cd055d4438e16324e2859a0ba5478","modified":1572167474368},{"_id":"public/archives/2019/archives/3/index.html","hash":"af0cef96b6d2c26b633f4e86d4850eb3b1a7ee29","modified":1572167474368},{"_id":"public/archives/2019/03/index.html","hash":"ea64ac7bac7ba0086bb1ced31bd9864dfe9f6f60","modified":1572167474368},{"_id":"public/archives/2019/04/index.html","hash":"9fd53d0df0b921bc768d9c597a803632c0191ad0","modified":1572167474368},{"_id":"public/archives/2019/05/index.html","hash":"0eb7c8a817f631abb47124c575d56fb87f953c48","modified":1572167474369},{"_id":"public/archives/2019/06/index.html","hash":"7748b1b17ece784c8f09205bcda720b4359998c9","modified":1572167474369},{"_id":"public/archives/2019/07/index.html","hash":"63d57e52fb69d5be306e7a19d1638ca22d40c93b","modified":1572167474369},{"_id":"public/archives/2019/08/index.html","hash":"13a7286beac6253b369f567166a2fc82b8623677","modified":1572167474369},{"_id":"public/2019/09/25/rollup-js使用/index.html","hash":"605a719a715996880f9426ca8b6becb2cbd470b6","modified":1572167474374},{"_id":"public/2019/10/11/vue项目接入sentry/index.html","hash":"cb3b402dda150bef0bbd317c56538a24558c10eb","modified":1572167474374},{"_id":"public/2019/09/24/js继承问题总结/index.html","hash":"40fdd408f9954901edf310c89ec646707dfeab8d","modified":1572167474374},{"_id":"public/tags/监控/index.html","hash":"2fd30951f43132a7f88eed62016d067aa529d162","modified":1572167474374},{"_id":"public/archives/2019/09/index.html","hash":"11660c6ad71ca614626f30fbd5d10a8ccfea11e5","modified":1572167474374},{"_id":"public/archives/2019/10/index.html","hash":"eab96f2c69d0421baecc0a44b991fc5def25c330","modified":1572167474374},{"_id":"public/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1572167474374},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1572167474379},{"_id":"public/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1572167474379},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1572167474379},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1572167474379},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1572167474379},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1572167474379},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1572167474379},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1572167474379},{"_id":"public/2019/07/08/centos下开机自动重启服务和脚本/WX20190708-113220.png","hash":"2ddd3501c319f9cd7848239f1ec6ccfc138ca9cd","modified":1572167474379},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1572167474672},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1572167474680},{"_id":"public/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1572167474680},{"_id":"public/css/highlight.css","hash":"c58b4569c086e477a00dcbf5a95a166fe5fecfb0","modified":1572167474680},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1572167474680},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1572167474680},{"_id":"public/css/toc.css","hash":"f756b9e1b2208d2e5b0f3d2ac5e4fea3b7da0e10","modified":1572167474680},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1572167474680},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1572167474681},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1572167474681},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1572167474682},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1572167474682},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1572167474682},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1572167474683},{"_id":"public/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1572167474684},{"_id":"public/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1572167474705},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1572167474705},{"_id":"public/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1572167474705},{"_id":"public/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1572167474705},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1572167474706},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1572167474709},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1572167474709},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1572167474709},{"_id":"public/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1572167474710},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1572167474720},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1572167474747},{"_id":"public/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1572167474749},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1572167474752},{"_id":"public/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1572167474752},{"_id":"public/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1572167474756},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1572167474760},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1572167474765},{"_id":"public/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1572167474771},{"_id":"public/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1572167474776},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1572167474779},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1572167474782},{"_id":"public/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1572167474785},{"_id":"public/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1572167474793}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2019-07-23T01:57:31.723Z","updated":"2019-07-23T01:57:31.723Z","path":"404.html","title":"","comments":1,"_id":"ck28rx5lr0000h91ptyiv19e7","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2017-10-03T02:48:33.000Z","description":"走在成为极客的路上","header-img":"/blog/img/header_img/about.jpg","aplayer":true,"fixed":false,"_content":"\n### 一句话\n\n>Just do it !    (翻译：nike名言)\n\n### 关于我\n\n>\n>\n>\n\n### 兴趣方向\n\n>\n\n### 参与社区\n\n > 掘金: \n >\n\n### 联系我\n\n>Email: hc1132107224@163.com\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2017-10-03 10:48:33\ndescription: \"走在成为极客的路上\"\nheader-img: \"/blog/img/header_img/about.jpg\"\naplayer: true\nfixed: false\n---\n\n### 一句话\n\n>Just do it !    (翻译：nike名言)\n\n### 关于我\n\n>\n>\n>\n\n### 兴趣方向\n\n>\n\n### 参与社区\n\n > 掘金: \n >\n\n### 联系我\n\n>Email: hc1132107224@163.com\n","updated":"2019-07-23T01:57:31.737Z","path":"about/index.html","comments":1,"_id":"ck28rx5m90001h91p3ia3j0vo","content":"<h3><span id=\"一句话\">一句话</span></h3>\n<blockquote>\n<p>Just do it !    (翻译：nike名言)</p>\n</blockquote>\n<h3><span id=\"关于我\">关于我</span></h3>\n<blockquote></blockquote>\n<h3><span id=\"兴趣方向\">兴趣方向</span></h3>\n<blockquote></blockquote>\n<h3><span id=\"参与社区\">参与社区</span></h3>\n<blockquote>\n<p>掘金:</p>\n</blockquote>\n<h3><span id=\"联系我\">联系我</span></h3>\n<blockquote>\n<p>Email: <a href=\"mailto:hc1132107224@163.com\" target=\"_blank\" rel=\"noopener\">hc1132107224@163.com</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>一句话</h3>\n<blockquote>\n<p>Just do it !    (翻译：nike名言)</p>\n</blockquote>\n<h3>关于我</h3>\n<blockquote></blockquote>\n<h3>兴趣方向</h3>\n<blockquote></blockquote>\n<h3>参与社区</h3>\n<blockquote>\n<p>掘金:</p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:hc1132107224@163.com\" target=\"_blank\" rel=\"noopener\">hc1132107224@163.com</a></p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"/blog/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/blog/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-07-23T01:57:31.738Z","path":"archive/index.html","_id":"ck28rx5me0003h91pflaeifzi","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/blog/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/blog/img/header_img/tag.png\"\n---\n","date":"2019-07-23T01:57:31.865Z","updated":"2019-07-23T01:57:31.865Z","path":"tags/index.html","comments":1,"_id":"ck28rx5mi0006h91p06ict882","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"centos下利用nvm安装node","catalog":true,"date":"2019-07-24T06:43:38.000Z","subtitle":null,"header-img":null,"_content":"\n- 安装 github\n\nyum install git -y\n\n- 下载 nvm\n\ngit clone git://github.com/creationix/nvm.git ~/nvm\n\n- 设置 nvm 自动运行;\n\necho \"source ~/nvm/nvm.sh\" >> ~/.bashrc\nsource ~/.bashrc\n\n- 查询 node 版本\n\nnvm list-remote\n\n- 安装 node.js\n\nnvm install v10.15.1\n\n- 使用 nodejs\n  nvm use v10.15.1\n","source":"_posts/centos下利用nvm安装node.md","raw":"---\ntitle: centos下利用nvm安装node\ncatalog: true\ndate: 2019-07-24 14:43:38\nsubtitle:\nheader-img:\ntags: linux\n---\n\n- 安装 github\n\nyum install git -y\n\n- 下载 nvm\n\ngit clone git://github.com/creationix/nvm.git ~/nvm\n\n- 设置 nvm 自动运行;\n\necho \"source ~/nvm/nvm.sh\" >> ~/.bashrc\nsource ~/.bashrc\n\n- 查询 node 版本\n\nnvm list-remote\n\n- 安装 node.js\n\nnvm install v10.15.1\n\n- 使用 nodejs\n  nvm use v10.15.1\n","slug":"centos下利用nvm安装node","published":1,"updated":"2019-07-24T06:44:56.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5ma0002h91pnfyhfa0j","content":"<ul>\n<li>安装 github</li>\n</ul>\n<p>yum install git -y</p>\n<ul>\n<li>下载 nvm</li>\n</ul>\n<p>git clone git://github.com/creationix/nvm.git ~/nvm</p>\n<ul>\n<li>设置 nvm 自动运行;</li>\n</ul>\n<p>echo “source ~/nvm/nvm.sh” &gt;&gt; ~/.bashrc<br>\nsource ~/.bashrc</p>\n<ul>\n<li>查询 node 版本</li>\n</ul>\n<p>nvm list-remote</p>\n<ul>\n<li>安装 node.js</li>\n</ul>\n<p>nvm install v10.15.1</p>\n<ul>\n<li>使用 nodejs<br>\nnvm use v10.15.1</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>安装 github</li>\n</ul>\n<p>yum install git -y</p>\n<ul>\n<li>下载 nvm</li>\n</ul>\n<p>git clone git://github.com/creationix/nvm.git ~/nvm</p>\n<ul>\n<li>设置 nvm 自动运行;</li>\n</ul>\n<p>echo “source ~/nvm/nvm.sh” &gt;&gt; ~/.bashrc<br>\nsource ~/.bashrc</p>\n<ul>\n<li>查询 node 版本</li>\n</ul>\n<p>nvm list-remote</p>\n<ul>\n<li>安装 node.js</li>\n</ul>\n<p>nvm install v10.15.1</p>\n<ul>\n<li>使用 nodejs<br>\nnvm use v10.15.1</li>\n</ul>\n"},{"title":"centos下开机自动重启服务和脚本","catalog":true,"date":"2019-07-08T02:45:59.000Z","subtitle":null,"header-img":null,"_content":"\n1. ### 利用`chkconfig`添加开机自启服务\n\n```shell\nchkconfig\n\n--list 各项服务状态栏显示出来\n--level 设置某个服务在该状态栏显示出来\n\n单独开启某一服务的命令：chkconfig 服务名 on\n\n单独关闭某一服务的命令：chkconfig 服务名 off\n\n查看某一服务的状态：/etc/intd.d/服务名 status\n\n```\n\n我这里以docker 服务为例，设置如下两条命令即可：\n\n```shell\n1  # systemctl enable docker.service #设置docker服务为自启动服务 相当于我们的 chkconfig docker on\n2 # systemctl start docker.service #启动docker服务\n\n```\n\n2. ### 添加开机自启脚本\n\n - 方法一\n\n    1. 赋予脚本可执行权限（/opt/script/duDefaultService.sh是你的脚本路径）\n\n    2. 打开/etc/rc.d/rc.local文件，在末尾增加如下内容\n\n    ```shell\n    echo \"/opt/script/duDefaultService.sh\" >> /etc/rc.d/rc.local\n    ```\n\n    3. 在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\n\n    ```shell\n    chmod +x /etc/rc.d/rc.local\n    ```\n\n- 方法二\n\n    0. 设置sh启动脚本必要参数\n\n    ```shell\n    #!/bin/sh\n    #chkconfig: 2345 80 80\n    #description: auto start web server\n\n    ```\n\n    第一句：必须的\n    声明sh\n    第二句：必须的\n    2345 表示linux 有 0-6种状态 在2345下启动\n    80：表示启动顺序\n    80：表示关闭顺序\n    后面两个参数小于 100\n    第三句：必须的\n    描述\n\n    结果截图如下：\n    {% asset_img WX20190708-113220.png 自动重启服务列表截图 %}\n\n    1. 将脚本移动到/etc/rc.d/init.d目录下\n\n    ```shell\n    mv  /opt/script/duDefaultService.sh /etc/rc.d/init.d\n    ```\n\n    2. 增加脚本的可执行权限\n\n    ```shell\n    chmod +x  /etc/rc.d/init.d/duDefaultService.sh\n    ```\n\n    3. 添加脚本到开机自动启动项目中\n\n    ```shell\n    cd /etc/rc.d/init.d\n    chkconfig --add duDefaultService.sh\n    chkconfig duDefaultService.sh on\n    ```\n\n- 方法三\n\n    1.建立服务文件\n\n    vim /lib/systemd/system/nginx.service\n\n    [Unit]\n\n    Description=nginx\n\n    After=network.target\n\n    [Service]\n\n    Type=forking\n\n    ExecStart=/www/lanmps/init.d/nginx start\n\n    ExecReload=/www/lanmps/init.d/nginx restart\n\n    ExecStop=/www/lanmps/init.d/nginx  stop\n\n    PrivateTmp=true\n\n    [Install]\n\n    WantedBy=multi-user.target\n\n    [Unit]:服务的说明\n\n    Description:描述服务\n\n    After:描述服务类别\n\n    [Service]服务运行参数的设置\n\n    Type=forking是后台运行的形式\n\n    ExecStart为服务的具体运行命令\n\n    ExecReload为重启命令\n\n    ExecStop为停止命令\n\n    PrivateTmp=True表示给服务分配独立的临时空间\n\n    注意：[Service]的启动、重启、停止命令全部要求使用绝对路径\n\n    [Install]服务安装的相关设置，可设置为多用户\n\n    2.保存目录\n\n    以754的权限保存在目录：\n\n    /lib/systemd/system  \n\n    3.设置开机自启动\n\n    systemctl enable nginx.service  \n\n    ```shell\n    systemctl enable XXXX.service\n    ```\n","source":"_posts/centos下开机自动重启服务和脚本.md","raw":"---\ntitle: centos下开机自动重启服务和脚本\ncatalog: true\ndate: 2019-07-08 10:45:59\nsubtitle:\nheader-img:\ntags: linux\n---\n\n1. ### 利用`chkconfig`添加开机自启服务\n\n```shell\nchkconfig\n\n--list 各项服务状态栏显示出来\n--level 设置某个服务在该状态栏显示出来\n\n单独开启某一服务的命令：chkconfig 服务名 on\n\n单独关闭某一服务的命令：chkconfig 服务名 off\n\n查看某一服务的状态：/etc/intd.d/服务名 status\n\n```\n\n我这里以docker 服务为例，设置如下两条命令即可：\n\n```shell\n1  # systemctl enable docker.service #设置docker服务为自启动服务 相当于我们的 chkconfig docker on\n2 # systemctl start docker.service #启动docker服务\n\n```\n\n2. ### 添加开机自启脚本\n\n - 方法一\n\n    1. 赋予脚本可执行权限（/opt/script/duDefaultService.sh是你的脚本路径）\n\n    2. 打开/etc/rc.d/rc.local文件，在末尾增加如下内容\n\n    ```shell\n    echo \"/opt/script/duDefaultService.sh\" >> /etc/rc.d/rc.local\n    ```\n\n    3. 在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\n\n    ```shell\n    chmod +x /etc/rc.d/rc.local\n    ```\n\n- 方法二\n\n    0. 设置sh启动脚本必要参数\n\n    ```shell\n    #!/bin/sh\n    #chkconfig: 2345 80 80\n    #description: auto start web server\n\n    ```\n\n    第一句：必须的\n    声明sh\n    第二句：必须的\n    2345 表示linux 有 0-6种状态 在2345下启动\n    80：表示启动顺序\n    80：表示关闭顺序\n    后面两个参数小于 100\n    第三句：必须的\n    描述\n\n    结果截图如下：\n    {% asset_img WX20190708-113220.png 自动重启服务列表截图 %}\n\n    1. 将脚本移动到/etc/rc.d/init.d目录下\n\n    ```shell\n    mv  /opt/script/duDefaultService.sh /etc/rc.d/init.d\n    ```\n\n    2. 增加脚本的可执行权限\n\n    ```shell\n    chmod +x  /etc/rc.d/init.d/duDefaultService.sh\n    ```\n\n    3. 添加脚本到开机自动启动项目中\n\n    ```shell\n    cd /etc/rc.d/init.d\n    chkconfig --add duDefaultService.sh\n    chkconfig duDefaultService.sh on\n    ```\n\n- 方法三\n\n    1.建立服务文件\n\n    vim /lib/systemd/system/nginx.service\n\n    [Unit]\n\n    Description=nginx\n\n    After=network.target\n\n    [Service]\n\n    Type=forking\n\n    ExecStart=/www/lanmps/init.d/nginx start\n\n    ExecReload=/www/lanmps/init.d/nginx restart\n\n    ExecStop=/www/lanmps/init.d/nginx  stop\n\n    PrivateTmp=true\n\n    [Install]\n\n    WantedBy=multi-user.target\n\n    [Unit]:服务的说明\n\n    Description:描述服务\n\n    After:描述服务类别\n\n    [Service]服务运行参数的设置\n\n    Type=forking是后台运行的形式\n\n    ExecStart为服务的具体运行命令\n\n    ExecReload为重启命令\n\n    ExecStop为停止命令\n\n    PrivateTmp=True表示给服务分配独立的临时空间\n\n    注意：[Service]的启动、重启、停止命令全部要求使用绝对路径\n\n    [Install]服务安装的相关设置，可设置为多用户\n\n    2.保存目录\n\n    以754的权限保存在目录：\n\n    /lib/systemd/system  \n\n    3.设置开机自启动\n\n    systemctl enable nginx.service  \n\n    ```shell\n    systemctl enable XXXX.service\n    ```\n","slug":"centos下开机自动重启服务和脚本","published":1,"updated":"2019-07-23T01:57:31.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5me0004h91pc1ysdl6p","content":"<ol>\n<li>\n<h3><span id=\"利用chkconfig添加开机自启服务\">利用<code>chkconfig</code>添加开机自启服务</span></h3>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkconfig</span><br><span class=\"line\"></span><br><span class=\"line\">--list 各项服务状态栏显示出来</span><br><span class=\"line\">--level 设置某个服务在该状态栏显示出来</span><br><span class=\"line\"></span><br><span class=\"line\">单独开启某一服务的命令：chkconfig 服务名 on</span><br><span class=\"line\"></span><br><span class=\"line\">单独关闭某一服务的命令：chkconfig 服务名 off</span><br><span class=\"line\"></span><br><span class=\"line\">查看某一服务的状态：/etc/intd.d/服务名 status</span><br></pre></td></tr></table></figure>\n<p>我这里以docker 服务为例，设置如下两条命令即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  # systemctl enable docker.service #设置docker服务为自启动服务 相当于我们的 chkconfig docker on</span><br><span class=\"line\">2 # systemctl start docker.service #启动docker服务</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<h3><span id=\"添加开机自启脚本\">添加开机自启脚本</span></h3>\n</li>\n</ol>\n<ul>\n<li>\n<p>方法一</p>\n<ol>\n<li>\n<p>赋予脚本可执行权限（/opt/script/duDefaultService.sh是你的脚本路径）</p>\n</li>\n<li>\n<p>打开/etc/rc.d/rc.local文件，在末尾增加如下内容</p>\n</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"/opt/script/duDefaultService.sh\" &gt;&gt; /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方法二</p>\n<ol start=\"0\">\n<li>设置sh启动脚本必要参数</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\"><span class=\"meta\">#</span>chkconfig: 2345 80 80</span><br><span class=\"line\"><span class=\"meta\">#</span>description: auto start web server</span><br></pre></td></tr></table></figure>\n<p>第一句：必须的<br>\n声明sh<br>\n第二句：必须的<br>\n2345 表示linux 有 0-6种状态 在2345下启动<br>\n80：表示启动顺序<br>\n80：表示关闭顺序<br>\n后面两个参数小于 100<br>\n第三句：必须的<br>\n描述</p>\n<p>结果截图如下：</p>\n  <img src=\"/blog/2019/07/08/centos下开机自动重启服务和脚本/WX20190708-113220.png\" title=\"自动重启服务列表截图\">\n<ol>\n<li>将脚本移动到/etc/rc.d/init.d目录下</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv  /opt/script/duDefaultService.sh /etc/rc.d/init.d</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>增加脚本的可执行权限</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x  /etc/rc.d/init.d/duDefaultService.sh</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>添加脚本到开机自动启动项目中</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc/rc.d/init.d</span><br><span class=\"line\">chkconfig --add duDefaultService.sh</span><br><span class=\"line\">chkconfig duDefaultService.sh on</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方法三</p>\n<p>1.建立服务文件</p>\n<p>vim /lib/systemd/system/nginx.service</p>\n<p><a href=\"%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AF%B4%E6%98%8E\">Unit</a></p>\n<p>Description=nginx</p>\n<p>After=network.target</p>\n<p>[Service]</p>\n<p>Type=forking</p>\n<p>ExecStart=/www/lanmps/init.d/nginx start</p>\n<p>ExecReload=/www/lanmps/init.d/nginx restart</p>\n<p>ExecStop=/www/lanmps/init.d/nginx  stop</p>\n<p>PrivateTmp=true</p>\n<p>[Install]</p>\n<p>WantedBy=multi-user.target</p>\n<p>Description:描述服务</p>\n<p>After:描述服务类别</p>\n<p>[Service]服务运行参数的设置</p>\n<p>Type=forking是后台运行的形式</p>\n<p>ExecStart为服务的具体运行命令</p>\n<p>ExecReload为重启命令</p>\n<p>ExecStop为停止命令</p>\n<p>PrivateTmp=True表示给服务分配独立的临时空间</p>\n<p>注意：[Service]的启动、重启、停止命令全部要求使用绝对路径</p>\n<p>[Install]服务安装的相关设置，可设置为多用户</p>\n<p>2.保存目录</p>\n<p>以754的权限保存在目录：</p>\n<p>/lib/systemd/system</p>\n<p>3.设置开机自启动</p>\n<p>systemctl enable nginx.service</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable XXXX.service</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>\n<h3>利用<code>chkconfig</code>添加开机自启服务</h3>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkconfig</span><br><span class=\"line\"></span><br><span class=\"line\">--list 各项服务状态栏显示出来</span><br><span class=\"line\">--level 设置某个服务在该状态栏显示出来</span><br><span class=\"line\"></span><br><span class=\"line\">单独开启某一服务的命令：chkconfig 服务名 on</span><br><span class=\"line\"></span><br><span class=\"line\">单独关闭某一服务的命令：chkconfig 服务名 off</span><br><span class=\"line\"></span><br><span class=\"line\">查看某一服务的状态：/etc/intd.d/服务名 status</span><br></pre></td></tr></table></figure>\n<p>我这里以docker 服务为例，设置如下两条命令即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  # systemctl enable docker.service #设置docker服务为自启动服务 相当于我们的 chkconfig docker on</span><br><span class=\"line\">2 # systemctl start docker.service #启动docker服务</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<h3>添加开机自启脚本</h3>\n</li>\n</ol>\n<ul>\n<li>\n<p>方法一</p>\n<ol>\n<li>\n<p>赋予脚本可执行权限（/opt/script/duDefaultService.sh是你的脚本路径）</p>\n</li>\n<li>\n<p>打开/etc/rc.d/rc.local文件，在末尾增加如下内容</p>\n</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"/opt/script/duDefaultService.sh\" &gt;&gt; /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方法二</p>\n<ol start=\"0\">\n<li>设置sh启动脚本必要参数</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\"><span class=\"meta\">#</span>chkconfig: 2345 80 80</span><br><span class=\"line\"><span class=\"meta\">#</span>description: auto start web server</span><br></pre></td></tr></table></figure>\n<p>第一句：必须的<br>\n声明sh<br>\n第二句：必须的<br>\n2345 表示linux 有 0-6种状态 在2345下启动<br>\n80：表示启动顺序<br>\n80：表示关闭顺序<br>\n后面两个参数小于 100<br>\n第三句：必须的<br>\n描述</p>\n<p>结果截图如下：</p>\n  <img src=\"/blog/2019/07/08/centos下开机自动重启服务和脚本/WX20190708-113220.png\" title=\"自动重启服务列表截图\">\n<ol>\n<li>将脚本移动到/etc/rc.d/init.d目录下</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv  /opt/script/duDefaultService.sh /etc/rc.d/init.d</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>增加脚本的可执行权限</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x  /etc/rc.d/init.d/duDefaultService.sh</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>添加脚本到开机自动启动项目中</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc/rc.d/init.d</span><br><span class=\"line\">chkconfig --add duDefaultService.sh</span><br><span class=\"line\">chkconfig duDefaultService.sh on</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方法三</p>\n<p>1.建立服务文件</p>\n<p>vim /lib/systemd/system/nginx.service</p>\n<p><a href=\"%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AF%B4%E6%98%8E\">Unit</a></p>\n<p>Description=nginx</p>\n<p>After=network.target</p>\n<p>[Service]</p>\n<p>Type=forking</p>\n<p>ExecStart=/www/lanmps/init.d/nginx start</p>\n<p>ExecReload=/www/lanmps/init.d/nginx restart</p>\n<p>ExecStop=/www/lanmps/init.d/nginx  stop</p>\n<p>PrivateTmp=true</p>\n<p>[Install]</p>\n<p>WantedBy=multi-user.target</p>\n<p>Description:描述服务</p>\n<p>After:描述服务类别</p>\n<p>[Service]服务运行参数的设置</p>\n<p>Type=forking是后台运行的形式</p>\n<p>ExecStart为服务的具体运行命令</p>\n<p>ExecReload为重启命令</p>\n<p>ExecStop为停止命令</p>\n<p>PrivateTmp=True表示给服务分配独立的临时空间</p>\n<p>注意：[Service]的启动、重启、停止命令全部要求使用绝对路径</p>\n<p>[Install]服务安装的相关设置，可设置为多用户</p>\n<p>2.保存目录</p>\n<p>以754的权限保存在目录：</p>\n<p>/lib/systemd/system</p>\n<p>3.设置开机自启动</p>\n<p>systemctl enable nginx.service</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable XXXX.service</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"git常用命令","catalog":true,"date":"2019-04-25T07:55:22.000Z","subtitle":null,"header-img":null,"_content":"\n1. 记录账户密码，不用每次 pull/push 都输入账号密码\n\n   在指定项目下，或者全局的根目录下输入如下命令，再执行 pull 之后输入账号密码，以后就不用再输入了\n\n   ```shell\n     git config --global credential.helper store\n   ```\n\n2. git 回退版本\n\n   - 本地回退到指定版本\n\n   ```shell\n     git reset --hard commit_id\n   ```\n\n- 远程强制回退到指定版本\n\n  ```shell\n    git push origin HEAD --force\n  ```\n\n3. git rebase\n   指定要合并 commit 的 id（不包含这个 commit）\n\n   ```shell\n     git rebase -i commit_id\n   ```\n\n   交互操作： s 合并 commit 记录 p 选中当前 commit 记录\n\n4. git tag\n   打标签\n\n```shell\n  git tag v1.0.0\n```\n\n删除标签\n\n```shell\n给标签加注释-m 指定标签版本 -a\n```\n\ngit tag -a v0.1.0 -m “0.1.2 版本”\n\n```shell\ngit tag -d v1.0.0\n```\n\n推送某次标签 和 本地全部标签\n\n```\ngit push origin v1.0.0\ngit push origin –tags\n```\n\n5. 项目迁移到新仓库\n\n```\ngit remote rename origin old-origin\ngit remote add origin 远程地址\ngit remote rm old-origin\ngit push -u origin --all\ngit push -u origin --tags\n```\n\n6. 导出私钥\n\n没有设置 ssh 的话，拉取代码会报`Permission denied, please try again`\n\n导出公私钥的方式`ssh-keygen -t rsa -C \"xxxx@xxxx.com\"`会生成 id_rsa 和 id_rsa.pub 两个文件，将 id_rsa.pub 拷贝到 gitlab 对应的远程仓库的 ssh keys 列表里面\n","source":"_posts/git常用命令.md","raw":"---\ntitle: git常用命令\ncatalog: true\ndate: 2019-04-25 15:55:22\nsubtitle:\nheader-img:\ntags: git\n---\n\n1. 记录账户密码，不用每次 pull/push 都输入账号密码\n\n   在指定项目下，或者全局的根目录下输入如下命令，再执行 pull 之后输入账号密码，以后就不用再输入了\n\n   ```shell\n     git config --global credential.helper store\n   ```\n\n2. git 回退版本\n\n   - 本地回退到指定版本\n\n   ```shell\n     git reset --hard commit_id\n   ```\n\n- 远程强制回退到指定版本\n\n  ```shell\n    git push origin HEAD --force\n  ```\n\n3. git rebase\n   指定要合并 commit 的 id（不包含这个 commit）\n\n   ```shell\n     git rebase -i commit_id\n   ```\n\n   交互操作： s 合并 commit 记录 p 选中当前 commit 记录\n\n4. git tag\n   打标签\n\n```shell\n  git tag v1.0.0\n```\n\n删除标签\n\n```shell\n给标签加注释-m 指定标签版本 -a\n```\n\ngit tag -a v0.1.0 -m “0.1.2 版本”\n\n```shell\ngit tag -d v1.0.0\n```\n\n推送某次标签 和 本地全部标签\n\n```\ngit push origin v1.0.0\ngit push origin –tags\n```\n\n5. 项目迁移到新仓库\n\n```\ngit remote rename origin old-origin\ngit remote add origin 远程地址\ngit remote rm old-origin\ngit push -u origin --all\ngit push -u origin --tags\n```\n\n6. 导出私钥\n\n没有设置 ssh 的话，拉取代码会报`Permission denied, please try again`\n\n导出公私钥的方式`ssh-keygen -t rsa -C \"xxxx@xxxx.com\"`会生成 id_rsa 和 id_rsa.pub 两个文件，将 id_rsa.pub 拷贝到 gitlab 对应的远程仓库的 ssh keys 列表里面\n","slug":"git常用命令","published":1,"updated":"2019-09-20T08:11:44.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5mi0007h91pyb1xv86h","content":"<ol>\n<li>\n<p>记录账户密码，不用每次 pull/push 都输入账号密码</p>\n<p>在指定项目下，或者全局的根目录下输入如下命令，再执行 pull 之后输入账号密码，以后就不用再输入了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global credential.helper store</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>git 回退版本</p>\n<ul>\n<li>本地回退到指定版本</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard commit_id</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>\n<p>远程强制回退到指定版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin HEAD --force</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>git rebase<br>\n指定要合并 commit 的 id（不包含这个 commit）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i commit_id</span><br></pre></td></tr></table></figure>\n<p>交互操作： s 合并 commit 记录 p 选中当前 commit 记录</p>\n</li>\n<li>\n<p>git tag<br>\n打标签</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0.0</span><br></pre></td></tr></table></figure>\n<p>删除标签</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给标签加注释-m 指定标签版本 -a</span><br></pre></td></tr></table></figure>\n<p>git tag -a v0.1.0 -m “0.1.2 版本”</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d v1.0.0</span><br></pre></td></tr></table></figure>\n<p>推送某次标签 和 本地全部标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin v1.0.0</span><br><span class=\"line\">git push origin –tags</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>项目迁移到新仓库</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rename origin old-origin</span><br><span class=\"line\">git remote add origin 远程地址</span><br><span class=\"line\">git remote rm old-origin</span><br><span class=\"line\">git push -u origin --all</span><br><span class=\"line\">git push -u origin --tags</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>导出私钥</li>\n</ol>\n<p>没有设置 ssh 的话，拉取代码会报<code>Permission denied, please try again</code></p>\n<p>导出公私钥的方式<code>ssh-keygen -t rsa -C &quot;xxxx@xxxx.com&quot;</code>会生成 id_rsa 和 id_rsa.pub 两个文件，将 id_rsa.pub 拷贝到 gitlab 对应的远程仓库的 ssh keys 列表里面</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>\n<p>记录账户密码，不用每次 pull/push 都输入账号密码</p>\n<p>在指定项目下，或者全局的根目录下输入如下命令，再执行 pull 之后输入账号密码，以后就不用再输入了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global credential.helper store</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>git 回退版本</p>\n<ul>\n<li>本地回退到指定版本</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard commit_id</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>\n<p>远程强制回退到指定版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin HEAD --force</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>git rebase<br>\n指定要合并 commit 的 id（不包含这个 commit）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i commit_id</span><br></pre></td></tr></table></figure>\n<p>交互操作： s 合并 commit 记录 p 选中当前 commit 记录</p>\n</li>\n<li>\n<p>git tag<br>\n打标签</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0.0</span><br></pre></td></tr></table></figure>\n<p>删除标签</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给标签加注释-m 指定标签版本 -a</span><br></pre></td></tr></table></figure>\n<p>git tag -a v0.1.0 -m “0.1.2 版本”</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d v1.0.0</span><br></pre></td></tr></table></figure>\n<p>推送某次标签 和 本地全部标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin v1.0.0</span><br><span class=\"line\">git push origin –tags</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>项目迁移到新仓库</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rename origin old-origin</span><br><span class=\"line\">git remote add origin 远程地址</span><br><span class=\"line\">git remote rm old-origin</span><br><span class=\"line\">git push -u origin --all</span><br><span class=\"line\">git push -u origin --tags</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>导出私钥</li>\n</ol>\n<p>没有设置 ssh 的话，拉取代码会报<code>Permission denied, please try again</code></p>\n<p>导出公私钥的方式<code>ssh-keygen -t rsa -C &quot;xxxx@xxxx.com&quot;</code>会生成 id_rsa 和 id_rsa.pub 两个文件，将 id_rsa.pub 拷贝到 gitlab 对应的远程仓库的 ssh keys 列表里面</p>\n"},{"title":"docker基本使用","catalog":true,"date":"2019-06-19T06:15:03.000Z","subtitle":null,"header-img":null,"_content":"\n本文都是基于`centos7`环境使用\n\n1. 启动 docker\n\n启动配置文件默认`/etc/docker/daemon.json`\n可以修改配置文件指定 docker 服务启动的一些默认参数\n\n- --regisrty-mirror=PROXY_URL 指定拉取镜像的地址加速 Docker 镜像拉取\n\n  2.docker pull NAME[:TAG]\n  默认都是从 `docker`官方仓库去拉取镜像（registry.hub.docker.com）\n  一般直接 pull  \n  比如：\n  `docker`下载`node`的`alpine`版本\n\n```shell\ndocker pull node:10.15-alpine\n```\n\n相当于\n\n```shell\ndocker pull registry.hub.docker.com/ubuntu:node:10.15-alpine\n```\n\n`alpine`是`node`在`docker`运行的最小环境的版本，相比于完整的`node`包体积更小\n\n如果不指定版本默认拉取 `latest`版本，生产环境的时候最好指定版本号，因为`lastest`版本会跟踪最新版本的变更而变化\n\n3.如何进入`未启动`的`node`镜像内部去修改默认一些配置\n\n```shell\ndocker run -it node:10.15-alpine sh\n```\n\n以`shell`脚本的方式去执行`node`命令\n\n4.docker exec ／ docker attach\n\n两者都是进入容器内部\n\n`attach`的不足：\n\n- 多个窗口同时 `attach`同一个容器时候，所有窗口会同步显示；\n- 当某个窗口因命令阻塞，所有窗口都无法执行操作；\n\n进入`已成功运行`的容器内部\n\n```shell\ndocker exec -it 容器名称/容器ID /bin/sh\n```\n\n- -i 支持标准输入\n- -t 开启一个伪终端\n\n  5.docker ps\n\n- docker ps\n  查看已经成功运行的容器（如果运行容器之后 ps 未看到说明容器启动失败）\n- docker ps -a\n  查看所有容器（包含未成功运行的容器）\n- docker ps -f 容器 id  \n   根据容器 id 筛选指定容器\n\n  6.docker run\n\n参数部分\n\n- -d 守护进程方式运行\n- -p 端口映射 （外部访问的端口：docker 内部端口）\n- -u 指定容器的用户\n- -v 挂载存储卷映射 （外部存储卷位置：docker 内部存储卷位置）\n- -h 指定容器的主机名\n- -root\n- --name 容器重命名\n- --rm 容器停止后自动删除\n- --link 关联其它容器\n\n7. 删除\n\ndocker rmi XXX\n\n批量删除失效的容器\n\n```\ndocker rm `docker ps -a -q`\n```\n","source":"_posts/docker基本使用.md","raw":"---\ntitle: docker基本使用\ncatalog: true\ndate: 2019-06-19 14:15:03\nsubtitle:\nheader-img:\ntags: docker\n---\n\n本文都是基于`centos7`环境使用\n\n1. 启动 docker\n\n启动配置文件默认`/etc/docker/daemon.json`\n可以修改配置文件指定 docker 服务启动的一些默认参数\n\n- --regisrty-mirror=PROXY_URL 指定拉取镜像的地址加速 Docker 镜像拉取\n\n  2.docker pull NAME[:TAG]\n  默认都是从 `docker`官方仓库去拉取镜像（registry.hub.docker.com）\n  一般直接 pull  \n  比如：\n  `docker`下载`node`的`alpine`版本\n\n```shell\ndocker pull node:10.15-alpine\n```\n\n相当于\n\n```shell\ndocker pull registry.hub.docker.com/ubuntu:node:10.15-alpine\n```\n\n`alpine`是`node`在`docker`运行的最小环境的版本，相比于完整的`node`包体积更小\n\n如果不指定版本默认拉取 `latest`版本，生产环境的时候最好指定版本号，因为`lastest`版本会跟踪最新版本的变更而变化\n\n3.如何进入`未启动`的`node`镜像内部去修改默认一些配置\n\n```shell\ndocker run -it node:10.15-alpine sh\n```\n\n以`shell`脚本的方式去执行`node`命令\n\n4.docker exec ／ docker attach\n\n两者都是进入容器内部\n\n`attach`的不足：\n\n- 多个窗口同时 `attach`同一个容器时候，所有窗口会同步显示；\n- 当某个窗口因命令阻塞，所有窗口都无法执行操作；\n\n进入`已成功运行`的容器内部\n\n```shell\ndocker exec -it 容器名称/容器ID /bin/sh\n```\n\n- -i 支持标准输入\n- -t 开启一个伪终端\n\n  5.docker ps\n\n- docker ps\n  查看已经成功运行的容器（如果运行容器之后 ps 未看到说明容器启动失败）\n- docker ps -a\n  查看所有容器（包含未成功运行的容器）\n- docker ps -f 容器 id  \n   根据容器 id 筛选指定容器\n\n  6.docker run\n\n参数部分\n\n- -d 守护进程方式运行\n- -p 端口映射 （外部访问的端口：docker 内部端口）\n- -u 指定容器的用户\n- -v 挂载存储卷映射 （外部存储卷位置：docker 内部存储卷位置）\n- -h 指定容器的主机名\n- -root\n- --name 容器重命名\n- --rm 容器停止后自动删除\n- --link 关联其它容器\n\n7. 删除\n\ndocker rmi XXX\n\n批量删除失效的容器\n\n```\ndocker rm `docker ps -a -q`\n```\n","slug":"docker基本使用","published":1,"updated":"2019-09-04T03:40:35.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5mk0008h91pynkmg4tc","content":"<p>本文都是基于<code>centos7</code>环境使用</p>\n<ol>\n<li>启动 docker</li>\n</ol>\n<p>启动配置文件默认<code>/etc/docker/daemon.json</code><br>\n可以修改配置文件指定 docker 服务启动的一些默认参数</p>\n<ul>\n<li>\n<p>–regisrty-mirror=PROXY_URL 指定拉取镜像的地址加速 Docker 镜像拉取</p>\n<p>2.docker pull NAME[:TAG]<br>\n默认都是从 <code>docker</code>官方仓库去拉取镜像（<a href=\"http://registry.hub.docker.com\" target=\"_blank\" rel=\"noopener\">registry.hub.docker.com</a>）<br>\n一般直接 pull<br>\n比如：<br>\n<code>docker</code>下载<code>node</code>的<code>alpine</code>版本</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull node:10.15-alpine</span><br></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull registry.hub.docker.com/ubuntu:node:10.15-alpine</span><br></pre></td></tr></table></figure>\n<p><code>alpine</code>是<code>node</code>在<code>docker</code>运行的最小环境的版本，相比于完整的<code>node</code>包体积更小</p>\n<p>如果不指定版本默认拉取 <code>latest</code>版本，生产环境的时候最好指定版本号，因为<code>lastest</code>版本会跟踪最新版本的变更而变化</p>\n<p>3.如何进入<code>未启动</code>的<code>node</code>镜像内部去修改默认一些配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it node:10.15-alpine sh</span><br></pre></td></tr></table></figure>\n<p>以<code>shell</code>脚本的方式去执行<code>node</code>命令</p>\n<p>4.docker exec ／ docker attach</p>\n<p>两者都是进入容器内部</p>\n<p><code>attach</code>的不足：</p>\n<ul>\n<li>多个窗口同时 <code>attach</code>同一个容器时候，所有窗口会同步显示；</li>\n<li>当某个窗口因命令阻塞，所有窗口都无法执行操作；</li>\n</ul>\n<p>进入<code>已成功运行</code>的容器内部</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it 容器名称/容器ID /bin/sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>-i 支持标准输入</p>\n</li>\n<li>\n<p>-t 开启一个伪终端</p>\n<p>5.docker ps</p>\n</li>\n<li>\n<p>docker ps<br>\n查看已经成功运行的容器（如果运行容器之后 ps 未看到说明容器启动失败）</p>\n</li>\n<li>\n<p>docker ps -a<br>\n查看所有容器（包含未成功运行的容器）</p>\n</li>\n<li>\n<p>docker ps -f 容器 id<br>\n根据容器 id 筛选指定容器</p>\n<p>6.docker run</p>\n</li>\n</ul>\n<p>参数部分</p>\n<ul>\n<li>-d 守护进程方式运行</li>\n<li>-p 端口映射 （外部访问的端口：docker 内部端口）</li>\n<li>-u 指定容器的用户</li>\n<li>-v 挂载存储卷映射 （外部存储卷位置：docker 内部存储卷位置）</li>\n<li>-h 指定容器的主机名</li>\n<li>-root</li>\n<li>–name 容器重命名</li>\n<li>–rm 容器停止后自动删除</li>\n<li>–link 关联其它容器</li>\n</ul>\n<ol start=\"7\">\n<li>删除</li>\n</ol>\n<p>docker rmi XXX</p>\n<p>批量删除失效的容器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>本文都是基于<code>centos7</code>环境使用</p>\n<ol>\n<li>启动 docker</li>\n</ol>\n<p>启动配置文件默认<code>/etc/docker/daemon.json</code><br>\n可以修改配置文件指定 docker 服务启动的一些默认参数</p>\n<ul>\n<li>\n<p>–regisrty-mirror=PROXY_URL 指定拉取镜像的地址加速 Docker 镜像拉取</p>\n<p>2.docker pull NAME[:TAG]<br>\n默认都是从 <code>docker</code>官方仓库去拉取镜像（<a href=\"http://registry.hub.docker.com\" target=\"_blank\" rel=\"noopener\">registry.hub.docker.com</a>）<br>\n一般直接 pull<br>\n比如：<br>\n<code>docker</code>下载<code>node</code>的<code>alpine</code>版本</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull node:10.15-alpine</span><br></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull registry.hub.docker.com/ubuntu:node:10.15-alpine</span><br></pre></td></tr></table></figure>\n<p><code>alpine</code>是<code>node</code>在<code>docker</code>运行的最小环境的版本，相比于完整的<code>node</code>包体积更小</p>\n<p>如果不指定版本默认拉取 <code>latest</code>版本，生产环境的时候最好指定版本号，因为<code>lastest</code>版本会跟踪最新版本的变更而变化</p>\n<p>3.如何进入<code>未启动</code>的<code>node</code>镜像内部去修改默认一些配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it node:10.15-alpine sh</span><br></pre></td></tr></table></figure>\n<p>以<code>shell</code>脚本的方式去执行<code>node</code>命令</p>\n<p>4.docker exec ／ docker attach</p>\n<p>两者都是进入容器内部</p>\n<p><code>attach</code>的不足：</p>\n<ul>\n<li>多个窗口同时 <code>attach</code>同一个容器时候，所有窗口会同步显示；</li>\n<li>当某个窗口因命令阻塞，所有窗口都无法执行操作；</li>\n</ul>\n<p>进入<code>已成功运行</code>的容器内部</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it 容器名称/容器ID /bin/sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>-i 支持标准输入</p>\n</li>\n<li>\n<p>-t 开启一个伪终端</p>\n<p>5.docker ps</p>\n</li>\n<li>\n<p>docker ps<br>\n查看已经成功运行的容器（如果运行容器之后 ps 未看到说明容器启动失败）</p>\n</li>\n<li>\n<p>docker ps -a<br>\n查看所有容器（包含未成功运行的容器）</p>\n</li>\n<li>\n<p>docker ps -f 容器 id<br>\n根据容器 id 筛选指定容器</p>\n<p>6.docker run</p>\n</li>\n</ul>\n<p>参数部分</p>\n<ul>\n<li>-d 守护进程方式运行</li>\n<li>-p 端口映射 （外部访问的端口：docker 内部端口）</li>\n<li>-u 指定容器的用户</li>\n<li>-v 挂载存储卷映射 （外部存储卷位置：docker 内部存储卷位置）</li>\n<li>-h 指定容器的主机名</li>\n<li>-root</li>\n<li>–name 容器重命名</li>\n<li>–rm 容器停止后自动删除</li>\n<li>–link 关联其它容器</li>\n</ul>\n<ol start=\"7\">\n<li>删除</li>\n</ol>\n<p>docker rmi XXX</p>\n<p>批量删除失效的容器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure>\n"},{"title":"git submodule","catalog":true,"date":"2019-07-10T08:31:04.000Z","subtitle":null,"header-img":null,"_content":"\n子模块一些操作方法：\n\n- 克隆带有子模块的项目\n\n```shell\ngit clone --recursive 远程地址\n```\n\n- 拉取子模块更新\n\n```shell\ngit submodule update --remote\n```\n\n- 提交子模块修改（需要切换到`master`分支）\n\n```shell\ngit add .\ngit commit -m 'xxxx'\ngit push origin master\n```\n\n- 删除子模块\n\n```shell\ngit submodule deinit themes/hugo-nuo\nvim .gitmodules # 移除要删除的子模块\ngit add .gitmodules\ngit rm --cached themes/hugo-nuo\nrm -rf .git/modules/themes/hugo-nuo\nrm -rf themes/hugo-nuo\ngit commit -m \"Remove submodule themes/hugo-nuo\"\n```\n\n参考链接： 1. [Git Submodule 的使用](https://www.jianshu.com/p/0107698498af) 2. [Git Submodule](https://laozhu.me/post/git-submodule-tutorial/)\n\n使用过程中遇到的问题：\n\n1. `jenkins`构建过程中，使用 http 方式拉取子模块一直提示需要输入账号密码，将账号密码放在 url 前面\n\n```shell\n\ngit config submodule.H5-Base.url http://账号:密码@远程地址/app/H5-Base.git\n\n\ngit submodule init\ngit submodule update --remote\n\nyarn install\ngit submodule foreach 'yarn install'\nyarn build\n```\n","source":"_posts/git-submodule.md","raw":"---\ntitle: git submodule\ncatalog: true\ndate: 2019-07-10 16:31:04\nsubtitle:\nheader-img:\ntags: web\n---\n\n子模块一些操作方法：\n\n- 克隆带有子模块的项目\n\n```shell\ngit clone --recursive 远程地址\n```\n\n- 拉取子模块更新\n\n```shell\ngit submodule update --remote\n```\n\n- 提交子模块修改（需要切换到`master`分支）\n\n```shell\ngit add .\ngit commit -m 'xxxx'\ngit push origin master\n```\n\n- 删除子模块\n\n```shell\ngit submodule deinit themes/hugo-nuo\nvim .gitmodules # 移除要删除的子模块\ngit add .gitmodules\ngit rm --cached themes/hugo-nuo\nrm -rf .git/modules/themes/hugo-nuo\nrm -rf themes/hugo-nuo\ngit commit -m \"Remove submodule themes/hugo-nuo\"\n```\n\n参考链接： 1. [Git Submodule 的使用](https://www.jianshu.com/p/0107698498af) 2. [Git Submodule](https://laozhu.me/post/git-submodule-tutorial/)\n\n使用过程中遇到的问题：\n\n1. `jenkins`构建过程中，使用 http 方式拉取子模块一直提示需要输入账号密码，将账号密码放在 url 前面\n\n```shell\n\ngit config submodule.H5-Base.url http://账号:密码@远程地址/app/H5-Base.git\n\n\ngit submodule init\ngit submodule update --remote\n\nyarn install\ngit submodule foreach 'yarn install'\nyarn build\n```\n","slug":"git-submodule","published":1,"updated":"2019-07-23T01:57:31.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5mm0009h91pwjub60v4","content":"<p>子模块一些操作方法：</p>\n<ul>\n<li>克隆带有子模块的项目</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --recursive 远程地址</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拉取子模块更新</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --remote</span><br></pre></td></tr></table></figure>\n<ul>\n<li>提交子模块修改（需要切换到<code>master</code>分支）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m 'xxxx'</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除子模块</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule deinit themes/hugo-nuo</span><br><span class=\"line\">vim .gitmodules # 移除要删除的子模块</span><br><span class=\"line\">git add .gitmodules</span><br><span class=\"line\">git rm --cached themes/hugo-nuo</span><br><span class=\"line\">rm -rf .git/modules/themes/hugo-nuo</span><br><span class=\"line\">rm -rf themes/hugo-nuo</span><br><span class=\"line\">git commit -m \"Remove submodule themes/hugo-nuo\"</span><br></pre></td></tr></table></figure>\n<p>参考链接： 1. <a href=\"https://www.jianshu.com/p/0107698498af\" target=\"_blank\" rel=\"noopener\">Git Submodule 的使用</a> 2. <a href=\"https://laozhu.me/post/git-submodule-tutorial/\" target=\"_blank\" rel=\"noopener\">Git Submodule</a></p>\n<p>使用过程中遇到的问题：</p>\n<ol>\n<li><code>jenkins</code>构建过程中，使用 http 方式拉取子模块一直提示需要输入账号密码，将账号密码放在 url 前面</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">git config submodule.H5-Base.url http://账号:密码@远程地址/app/H5-Base.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">git submodule init</span><br><span class=\"line\">git submodule update --remote</span><br><span class=\"line\"></span><br><span class=\"line\">yarn install</span><br><span class=\"line\">git submodule foreach 'yarn install'</span><br><span class=\"line\">yarn build</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>子模块一些操作方法：</p>\n<ul>\n<li>克隆带有子模块的项目</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --recursive 远程地址</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拉取子模块更新</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --remote</span><br></pre></td></tr></table></figure>\n<ul>\n<li>提交子模块修改（需要切换到<code>master</code>分支）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m 'xxxx'</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除子模块</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule deinit themes/hugo-nuo</span><br><span class=\"line\">vim .gitmodules # 移除要删除的子模块</span><br><span class=\"line\">git add .gitmodules</span><br><span class=\"line\">git rm --cached themes/hugo-nuo</span><br><span class=\"line\">rm -rf .git/modules/themes/hugo-nuo</span><br><span class=\"line\">rm -rf themes/hugo-nuo</span><br><span class=\"line\">git commit -m \"Remove submodule themes/hugo-nuo\"</span><br></pre></td></tr></table></figure>\n<p>参考链接： 1. <a href=\"https://www.jianshu.com/p/0107698498af\" target=\"_blank\" rel=\"noopener\">Git Submodule 的使用</a> 2. <a href=\"https://laozhu.me/post/git-submodule-tutorial/\" target=\"_blank\" rel=\"noopener\">Git Submodule</a></p>\n<p>使用过程中遇到的问题：</p>\n<ol>\n<li><code>jenkins</code>构建过程中，使用 http 方式拉取子模块一直提示需要输入账号密码，将账号密码放在 url 前面</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">git config submodule.H5-Base.url http://账号:密码@远程地址/app/H5-Base.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">git submodule init</span><br><span class=\"line\">git submodule update --remote</span><br><span class=\"line\"></span><br><span class=\"line\">yarn install</span><br><span class=\"line\">git submodule foreach 'yarn install'</span><br><span class=\"line\">yarn build</span><br></pre></td></tr></table></figure>\n"},{"title":"js中几种设计模式","catalog":true,"date":"2019-07-14T13:50:10.000Z","subtitle":null,"header-img":null,"_content":"\n1. 工厂模式\n\n> TODO\n\n```javascript\nclass Product  {\n    constructor (name) {\n        this.name = name\n    }\n}\n\nclass Creator {\n    create (name) {\n        return new Product(name)\n    }\n}\n\nconst creatorInstance = new Creator()\n\ncreatorInstance.create('张三')\n```\n\n应用场景：TODO\n\n2. 单例模式\n\n> 一个类只有一个实例，并提供全局访问的方法，一般用于登录、购物车等场景\n\n```javascript\nclass Single {\n    login () {}\n    shopping () {}\n}\n\nSingle.getInstance = (function () {\n    let Instance\n    return () => {\n        if (!Instance) {\n                Instance = new Single()\n        }\n        return Instance\n    }\n})()\n\nconst signleInstanceA = Single.getInstance()\nconst signleInstanceB = Single.getInstance()\nconsole.log(signleInstanceA === signleInstanceB) // true\n```\n\n应用场景：TODO\n\n3. 适配器模式\n\n> 用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问\n\n```javascript\nclass Adapter {\n    money () {\n        return '人民币'\n    }\n}\n\nclass AdapterWrapper {\n    constructor () {\n        this.Adapter = new Adapter()\n    }\n\n    m2$ () {\n        const m = this.Adapter.money()\n        return `人民币兑换成美元`\n    }\n}\n\nconst adapterWrapper = new AdapterWrapper()\nadapterWrapper.m2$()\n```\n\n应用场景：多个对象合并成一个对象\n\n4. 装饰器模式（AOP编程）\n\n> 在不改变源对象的自身方法的基础上，给源对象自身方法提供新的功能\n\n```javascript\nclass Source {\n    add (a, b) {\n        return a + b\n    }\n}\n\nclass DecorateSource {\n    constructor () {\n        this.source = new Source()\n    }\n    add (a, b) {\n        console.log('传入的参数为', a, b)\n        return this.source.add(a, b)\n    }\n}\n\nconst decorateSource = new DecorateSource()\ndecorateSource.add(1, 2) // 传入的参数为 1 2     3\n```\n\n应用场景：\n\n- 处理ajax异常上报，数据分析\n- Vue中处理数组变异方法\n\n5. 观察者模式\n\n> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知\n\n```javascript\nclass Sub {\n    constructor () {\n        this.observers = []\n    }\n    attach (observer) {\n        this.observers.push(observer)\n    }\n    notify () {\n        this.observers.forEach(observer => {\n            observer.update()\n        } )\n    }\n}\n\nclass Observer {\n    constructor (name) {\n        this.name = name\n    }\n    update () {\n        console.log(`${this.name}触发更新`)\n    }\n}\n\nconst observerA = new Observer('A')\nconst observerB = new Observer('B')\nconst sub = new Sub()\nsub.attach(observerA)\nsub.attach(observerB)\nsub.notify()\n\n```\n\n应用场景：JS事件、promise、Vue的watch方法\n\n与订阅/发布模式区别 主要在于调度不同。观察者模式由具体目标方法调度，而订阅发布模式由统一调度中心去调度，所以观察者模式的观察者和目标会有依赖，而后者没有。\n","source":"_posts/js中几种设计模式.md","raw":"---\ntitle: js中几种设计模式\ncatalog: true\ndate: 2019-07-14 21:50:10\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n1. 工厂模式\n\n> TODO\n\n```javascript\nclass Product  {\n    constructor (name) {\n        this.name = name\n    }\n}\n\nclass Creator {\n    create (name) {\n        return new Product(name)\n    }\n}\n\nconst creatorInstance = new Creator()\n\ncreatorInstance.create('张三')\n```\n\n应用场景：TODO\n\n2. 单例模式\n\n> 一个类只有一个实例，并提供全局访问的方法，一般用于登录、购物车等场景\n\n```javascript\nclass Single {\n    login () {}\n    shopping () {}\n}\n\nSingle.getInstance = (function () {\n    let Instance\n    return () => {\n        if (!Instance) {\n                Instance = new Single()\n        }\n        return Instance\n    }\n})()\n\nconst signleInstanceA = Single.getInstance()\nconst signleInstanceB = Single.getInstance()\nconsole.log(signleInstanceA === signleInstanceB) // true\n```\n\n应用场景：TODO\n\n3. 适配器模式\n\n> 用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问\n\n```javascript\nclass Adapter {\n    money () {\n        return '人民币'\n    }\n}\n\nclass AdapterWrapper {\n    constructor () {\n        this.Adapter = new Adapter()\n    }\n\n    m2$ () {\n        const m = this.Adapter.money()\n        return `人民币兑换成美元`\n    }\n}\n\nconst adapterWrapper = new AdapterWrapper()\nadapterWrapper.m2$()\n```\n\n应用场景：多个对象合并成一个对象\n\n4. 装饰器模式（AOP编程）\n\n> 在不改变源对象的自身方法的基础上，给源对象自身方法提供新的功能\n\n```javascript\nclass Source {\n    add (a, b) {\n        return a + b\n    }\n}\n\nclass DecorateSource {\n    constructor () {\n        this.source = new Source()\n    }\n    add (a, b) {\n        console.log('传入的参数为', a, b)\n        return this.source.add(a, b)\n    }\n}\n\nconst decorateSource = new DecorateSource()\ndecorateSource.add(1, 2) // 传入的参数为 1 2     3\n```\n\n应用场景：\n\n- 处理ajax异常上报，数据分析\n- Vue中处理数组变异方法\n\n5. 观察者模式\n\n> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知\n\n```javascript\nclass Sub {\n    constructor () {\n        this.observers = []\n    }\n    attach (observer) {\n        this.observers.push(observer)\n    }\n    notify () {\n        this.observers.forEach(observer => {\n            observer.update()\n        } )\n    }\n}\n\nclass Observer {\n    constructor (name) {\n        this.name = name\n    }\n    update () {\n        console.log(`${this.name}触发更新`)\n    }\n}\n\nconst observerA = new Observer('A')\nconst observerB = new Observer('B')\nconst sub = new Sub()\nsub.attach(observerA)\nsub.attach(observerB)\nsub.notify()\n\n```\n\n应用场景：JS事件、promise、Vue的watch方法\n\n与订阅/发布模式区别 主要在于调度不同。观察者模式由具体目标方法调度，而订阅发布模式由统一调度中心去调度，所以观察者模式的观察者和目标会有依赖，而后者没有。\n","slug":"js中几种设计模式","published":1,"updated":"2019-07-23T01:57:31.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5mq000ch91puiage7s6","content":"<ol>\n<li>工厂模式</li>\n</ol>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Creator</span> </span>&#123;</span><br><span class=\"line\">    create (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Product(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> creatorInstance = <span class=\"keyword\">new</span> Creator()</span><br><span class=\"line\"></span><br><span class=\"line\">creatorInstance.create(<span class=\"string\">'张三'</span>)</span><br></pre></td></tr></table></figure>\n<p>应用场景：TODO</p>\n<ol start=\"2\">\n<li>单例模式</li>\n</ol>\n<blockquote>\n<p>一个类只有一个实例，并提供全局访问的方法，一般用于登录、购物车等场景</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</span><br><span class=\"line\">    login () &#123;&#125;</span><br><span class=\"line\">    shopping () &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Single.getInstance = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Instance</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Instance) &#123;</span><br><span class=\"line\">                Instance = <span class=\"keyword\">new</span> Single()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Instance</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> signleInstanceA = Single.getInstance()</span><br><span class=\"line\"><span class=\"keyword\">const</span> signleInstanceB = Single.getInstance()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(signleInstanceA === signleInstanceB) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>应用场景：TODO</p>\n<ol start=\"3\">\n<li>适配器模式</li>\n</ol>\n<blockquote>\n<p>用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> </span>&#123;</span><br><span class=\"line\">    money () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'人民币'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdapterWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.Adapter = <span class=\"keyword\">new</span> Adapter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m2$ () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> m = <span class=\"keyword\">this</span>.Adapter.money()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`人民币兑换成美元`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> adapterWrapper = <span class=\"keyword\">new</span> AdapterWrapper()</span><br><span class=\"line\">adapterWrapper.m2$()</span><br></pre></td></tr></table></figure>\n<p>应用场景：多个对象合并成一个对象</p>\n<ol start=\"4\">\n<li>装饰器模式（AOP编程）</li>\n</ol>\n<blockquote>\n<p>在不改变源对象的自身方法的基础上，给源对象自身方法提供新的功能</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Source</span> </span>&#123;</span><br><span class=\"line\">    add (a, b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecorateSource</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.source = <span class=\"keyword\">new</span> Source()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add (a, b) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'传入的参数为'</span>, a, b)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.source.add(a, b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decorateSource = <span class=\"keyword\">new</span> DecorateSource()</span><br><span class=\"line\">decorateSource.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 传入的参数为 1 2     3</span></span><br></pre></td></tr></table></figure>\n<p>应用场景：</p>\n<ul>\n<li>处理ajax异常上报，数据分析</li>\n<li>Vue中处理数组变异方法</li>\n</ul>\n<ol start=\"5\">\n<li>观察者模式</li>\n</ol>\n<blockquote>\n<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    attach (observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers.push(observer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    notify () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">observer</span> =&gt;</span> &#123;</span><br><span class=\"line\">            observer.update()</span><br><span class=\"line\">        &#125; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span>触发更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> observerA = <span class=\"keyword\">new</span> Observer(<span class=\"string\">'A'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> observerB = <span class=\"keyword\">new</span> Observer(<span class=\"string\">'B'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> sub = <span class=\"keyword\">new</span> Sub()</span><br><span class=\"line\">sub.attach(observerA)</span><br><span class=\"line\">sub.attach(observerB)</span><br><span class=\"line\">sub.notify()</span><br></pre></td></tr></table></figure>\n<p>应用场景：JS事件、promise、Vue的watch方法</p>\n<p>与订阅/发布模式区别 主要在于调度不同。观察者模式由具体目标方法调度，而订阅发布模式由统一调度中心去调度，所以观察者模式的观察者和目标会有依赖，而后者没有。</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>工厂模式</li>\n</ol>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Creator</span> </span>&#123;</span><br><span class=\"line\">    create (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Product(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> creatorInstance = <span class=\"keyword\">new</span> Creator()</span><br><span class=\"line\"></span><br><span class=\"line\">creatorInstance.create(<span class=\"string\">'张三'</span>)</span><br></pre></td></tr></table></figure>\n<p>应用场景：TODO</p>\n<ol start=\"2\">\n<li>单例模式</li>\n</ol>\n<blockquote>\n<p>一个类只有一个实例，并提供全局访问的方法，一般用于登录、购物车等场景</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</span><br><span class=\"line\">    login () &#123;&#125;</span><br><span class=\"line\">    shopping () &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Single.getInstance = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Instance</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Instance) &#123;</span><br><span class=\"line\">                Instance = <span class=\"keyword\">new</span> Single()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Instance</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> signleInstanceA = Single.getInstance()</span><br><span class=\"line\"><span class=\"keyword\">const</span> signleInstanceB = Single.getInstance()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(signleInstanceA === signleInstanceB) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>应用场景：TODO</p>\n<ol start=\"3\">\n<li>适配器模式</li>\n</ol>\n<blockquote>\n<p>用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> </span>&#123;</span><br><span class=\"line\">    money () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'人民币'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdapterWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.Adapter = <span class=\"keyword\">new</span> Adapter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m2$ () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> m = <span class=\"keyword\">this</span>.Adapter.money()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`人民币兑换成美元`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> adapterWrapper = <span class=\"keyword\">new</span> AdapterWrapper()</span><br><span class=\"line\">adapterWrapper.m2$()</span><br></pre></td></tr></table></figure>\n<p>应用场景：多个对象合并成一个对象</p>\n<ol start=\"4\">\n<li>装饰器模式（AOP编程）</li>\n</ol>\n<blockquote>\n<p>在不改变源对象的自身方法的基础上，给源对象自身方法提供新的功能</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Source</span> </span>&#123;</span><br><span class=\"line\">    add (a, b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecorateSource</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.source = <span class=\"keyword\">new</span> Source()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add (a, b) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'传入的参数为'</span>, a, b)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.source.add(a, b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decorateSource = <span class=\"keyword\">new</span> DecorateSource()</span><br><span class=\"line\">decorateSource.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 传入的参数为 1 2     3</span></span><br></pre></td></tr></table></figure>\n<p>应用场景：</p>\n<ul>\n<li>处理ajax异常上报，数据分析</li>\n<li>Vue中处理数组变异方法</li>\n</ul>\n<ol start=\"5\">\n<li>观察者模式</li>\n</ol>\n<blockquote>\n<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    attach (observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers.push(observer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    notify () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">observer</span> =&gt;</span> &#123;</span><br><span class=\"line\">            observer.update()</span><br><span class=\"line\">        &#125; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span>触发更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> observerA = <span class=\"keyword\">new</span> Observer(<span class=\"string\">'A'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> observerB = <span class=\"keyword\">new</span> Observer(<span class=\"string\">'B'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> sub = <span class=\"keyword\">new</span> Sub()</span><br><span class=\"line\">sub.attach(observerA)</span><br><span class=\"line\">sub.attach(observerB)</span><br><span class=\"line\">sub.notify()</span><br></pre></td></tr></table></figure>\n<p>应用场景：JS事件、promise、Vue的watch方法</p>\n<p>与订阅/发布模式区别 主要在于调度不同。观察者模式由具体目标方法调度，而订阅发布模式由统一调度中心去调度，所以观察者模式的观察者和目标会有依赖，而后者没有。</p>\n"},{"title":"js继承问题总结","catalog":true,"date":"2019-09-24T04:24:41.000Z","subtitle":null,"header-img":null,"_content":"\n如果要用 js 实现一个类的话，我们会用构造函数来模拟一个类，代码如下：\n\n```javascript\nfunction Animal(name) {\n\tthis.name = name\n\tthis.height = function() {\n\t\tconsole.log(this.name + '的高度未知')\n\t}\n}\n\nAnimal.prototype.eat = function(food) {\n\tconsole.log(this.name + '正在吃' + food)\n}\n```\n\n那现在我们需要继承这个`Animal`的类来实现一个具体的`Dog`类，我们一般会使用`组合继承`，方法如下：\n\n```javascript\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n\tthis.age = age\n}\n\nDog.prototype = new Animal()\nDog.prototype.constructor = Dog\n```\n\n目测是比较完美的继承方式了，但是仔细思考会发现有个问题：\n\n1. 在`Dog.prototype = new Animal()`执行了一次`Animal`实例；\n2. 在 Dog 类实例化时候，内部使用 call 方法的时候又执行了一次`Animal`实例化；\n\n所以这并不是最完美的继承方式。那么我们应该使用什么样的办法才能解决上述问题呢？这个时候就需要用到`寄生继承`方式，代码如下：\n\n```javascript\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n\tthis.age = age\n}\n\nDog.prototype = Object.create(Animal.prototype)\nDog.prototype.constructor = Dog\n```\n\n利用一个中间对象先继承父类，减少了第一次继承父类原型的时候会实例化父类的缺点，这应该是目前最完美的继承方法。\n\n参考资料：\n\n1. [JS 组合继承（寄生继承）](https://www.jianshu.com/p/8a83ed26ecbb)\n2. [Javascript 完美继承方式 - 寄生组合](https://www.jianshu.com/p/5d53d06ea918)\n","source":"_posts/js继承问题总结.md","raw":"---\ntitle: js继承问题总结\ncatalog: true\ndate: 2019-09-24 12:24:41\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n如果要用 js 实现一个类的话，我们会用构造函数来模拟一个类，代码如下：\n\n```javascript\nfunction Animal(name) {\n\tthis.name = name\n\tthis.height = function() {\n\t\tconsole.log(this.name + '的高度未知')\n\t}\n}\n\nAnimal.prototype.eat = function(food) {\n\tconsole.log(this.name + '正在吃' + food)\n}\n```\n\n那现在我们需要继承这个`Animal`的类来实现一个具体的`Dog`类，我们一般会使用`组合继承`，方法如下：\n\n```javascript\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n\tthis.age = age\n}\n\nDog.prototype = new Animal()\nDog.prototype.constructor = Dog\n```\n\n目测是比较完美的继承方式了，但是仔细思考会发现有个问题：\n\n1. 在`Dog.prototype = new Animal()`执行了一次`Animal`实例；\n2. 在 Dog 类实例化时候，内部使用 call 方法的时候又执行了一次`Animal`实例化；\n\n所以这并不是最完美的继承方式。那么我们应该使用什么样的办法才能解决上述问题呢？这个时候就需要用到`寄生继承`方式，代码如下：\n\n```javascript\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n\tthis.age = age\n}\n\nDog.prototype = Object.create(Animal.prototype)\nDog.prototype.constructor = Dog\n```\n\n利用一个中间对象先继承父类，减少了第一次继承父类原型的时候会实例化父类的缺点，这应该是目前最完美的继承方法。\n\n参考资料：\n\n1. [JS 组合继承（寄生继承）](https://www.jianshu.com/p/8a83ed26ecbb)\n2. [Javascript 完美继承方式 - 寄生组合](https://www.jianshu.com/p/5d53d06ea918)\n","slug":"js继承问题总结","published":1,"updated":"2019-09-25T02:49:53.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5mt000dh91puwly65yu","content":"<p>如果要用 js 实现一个类的话，我们会用构造函数来模拟一个类，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.height = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'的高度未知'</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃'</span> + food)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那现在我们需要继承这个<code>Animal</code>的类来实现一个具体的<code>Dog</code>类，我们一般会使用<code>组合继承</code>，方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> Animal()</span><br><span class=\"line\">Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure>\n<p>目测是比较完美的继承方式了，但是仔细思考会发现有个问题：</p>\n<ol>\n<li>在<code>Dog.prototype = new Animal()</code>执行了一次<code>Animal</code>实例；</li>\n<li>在 Dog 类实例化时候，内部使用 call 方法的时候又执行了一次<code>Animal</code>实例化；</li>\n</ol>\n<p>所以这并不是最完美的继承方式。那么我们应该使用什么样的办法才能解决上述问题呢？这个时候就需要用到<code>寄生继承</code>方式，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype = <span class=\"built_in\">Object</span>.create(Animal.prototype)</span><br><span class=\"line\">Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure>\n<p>利用一个中间对象先继承父类，减少了第一次继承父类原型的时候会实例化父类的缺点，这应该是目前最完美的继承方法。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/8a83ed26ecbb\" target=\"_blank\" rel=\"noopener\">JS 组合继承（寄生继承）</a></li>\n<li><a href=\"https://www.jianshu.com/p/5d53d06ea918\" target=\"_blank\" rel=\"noopener\">Javascript 完美继承方式 - 寄生组合</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>如果要用 js 实现一个类的话，我们会用构造函数来模拟一个类，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.height = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'的高度未知'</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃'</span> + food)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那现在我们需要继承这个<code>Animal</code>的类来实现一个具体的<code>Dog</code>类，我们一般会使用<code>组合继承</code>，方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> Animal()</span><br><span class=\"line\">Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure>\n<p>目测是比较完美的继承方式了，但是仔细思考会发现有个问题：</p>\n<ol>\n<li>在<code>Dog.prototype = new Animal()</code>执行了一次<code>Animal</code>实例；</li>\n<li>在 Dog 类实例化时候，内部使用 call 方法的时候又执行了一次<code>Animal</code>实例化；</li>\n</ol>\n<p>所以这并不是最完美的继承方式。那么我们应该使用什么样的办法才能解决上述问题呢？这个时候就需要用到<code>寄生继承</code>方式，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype = <span class=\"built_in\">Object</span>.create(Animal.prototype)</span><br><span class=\"line\">Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure>\n<p>利用一个中间对象先继承父类，减少了第一次继承父类原型的时候会实例化父类的缺点，这应该是目前最完美的继承方法。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/8a83ed26ecbb\" target=\"_blank\" rel=\"noopener\">JS 组合继承（寄生继承）</a></li>\n<li><a href=\"https://www.jianshu.com/p/5d53d06ea918\" target=\"_blank\" rel=\"noopener\">Javascript 完美继承方式 - 寄生组合</a></li>\n</ol>\n"},{"title":"python爬虫框架scrapy","catalog":true,"date":"2019-06-19T06:07:34.000Z","subtitle":null,"header-img":null,"_content":"\n### 基本用法\n\n1.创建项目\n\n```shell\nscrapy startproject 项目名称\n```\n\n2.创建一个爬虫\n\n```shell\nscrapy genspider XX XX.com\n```\n\n3.启动脚本\n\n```shell\nscrapy crawl XX\n```\n\n也可以新建一个启动文件，比如`start.py`\n\n```python\nfrom scrapy.cmdline import execute\n\nexecute('scrapy crawl stockX'.split())\n```\n\n4.爬虫脚本\n\n必须要有`name`，这个是和启动对应命令对应的的名称\n\n`parse`以及`start_urls`和`allowed_domains`可选\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\n\nclass BaiduSpider(scrapy.Spider):\n    name = 'baidu'\n    allowed_domains = ['baidu.com']\n    start_urls = ['https://www.baidu.com/']\n\n    def parse(self, response):\n        print(response.text)\n```\n\n其中 start_urls 可以接受多个 url 参数，也可以拆分成多个步骤\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\n\nclass BaiduSpider(scrapy.Spider):\n    name = 'baidu'\n    allowed_domains = ['baidu.com']\n    # start_urls = ['https://www.baidu.com/']\n\n    def start_requests(self):\n        yield scrapy.Request('https://www.baidu.com')\n\n    def parse(self, response):\n        print(response.text)\n```\n\n---\n\n1. `Items`相当于定义的需要输出的数据模型，用来存储数据，推送给`pipline`解析处理；\n\n2. 如果要爬取多组数据，最好是建立多个模型，即`Item`；\n\n---\n\n## Pipline\n\n### 1. 介绍\n\n当 item 在 Spider 中被收集之后，会传递到 item pipline 中处理；\n\n作用：\n\n- 清理 html 数据\n- 验证爬取数据\n- 去重并丢弃\n- 数据持久化\n\n### 2. 编写 item pipline\n\n2.1 必须实现的函数\n\n- process_item\n\n  每个`pipline`都是一个 python 类，负责接收到`item`并执行一些行为，内部必须实现`process_item(self, item, spider)`方法，必须返回一个`dict`或者`item`对象。\n\n  `piplines`只能接受字典和`items`，在主程序通过`yield`推送到`piplines`\n\n  2.2 可以选择实现\n\n- `open_spider(self, spider)`表示当 spider 开启的时候调用的方法；\n- `close_spider(self, spider)`标识当 spider 关闭的时候调用的方法；\n\n注意：\n\n- `pipline`写完需要在配置项`settings`的`ITEM_PIPELINES`里写入来启动\n\n```python\nITEM_PIPELINE {\n  demo.pipelines.testDemoPipeline : 300    // 300是优先级 越大优先级越高\n}\n```\n\n- 文件流写入是缓冲一定字节的数据再一次性写入\n\n  强制立刻写入\n\n```python\nself.file.flush()\n```\n\n---\n\n2.3 如果编写多个`pipeline`，则会改成指定大小去依次执行每次推过来的`item`，如果需要丢弃`item`\n\n```python\n from scrapy.exceptions import DropItem\n\n raise DropItem()\n```\n\n2.4 推送过来的`item`并不是一个 list，如果需要存储数据，则需要转成字典\n\n```python\n self.json_file.writelines(json.dumps(dict(item), ensure_ascii=False) + '\\r')\n```\n","source":"_posts/python爬虫框架scrapy.md","raw":"---\ntitle: python爬虫框架scrapy\ncatalog: true\ndate: 2019-06-19 14:07:34\nsubtitle:\nheader-img:\ntags: python\n---\n\n### 基本用法\n\n1.创建项目\n\n```shell\nscrapy startproject 项目名称\n```\n\n2.创建一个爬虫\n\n```shell\nscrapy genspider XX XX.com\n```\n\n3.启动脚本\n\n```shell\nscrapy crawl XX\n```\n\n也可以新建一个启动文件，比如`start.py`\n\n```python\nfrom scrapy.cmdline import execute\n\nexecute('scrapy crawl stockX'.split())\n```\n\n4.爬虫脚本\n\n必须要有`name`，这个是和启动对应命令对应的的名称\n\n`parse`以及`start_urls`和`allowed_domains`可选\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\n\nclass BaiduSpider(scrapy.Spider):\n    name = 'baidu'\n    allowed_domains = ['baidu.com']\n    start_urls = ['https://www.baidu.com/']\n\n    def parse(self, response):\n        print(response.text)\n```\n\n其中 start_urls 可以接受多个 url 参数，也可以拆分成多个步骤\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\n\nclass BaiduSpider(scrapy.Spider):\n    name = 'baidu'\n    allowed_domains = ['baidu.com']\n    # start_urls = ['https://www.baidu.com/']\n\n    def start_requests(self):\n        yield scrapy.Request('https://www.baidu.com')\n\n    def parse(self, response):\n        print(response.text)\n```\n\n---\n\n1. `Items`相当于定义的需要输出的数据模型，用来存储数据，推送给`pipline`解析处理；\n\n2. 如果要爬取多组数据，最好是建立多个模型，即`Item`；\n\n---\n\n## Pipline\n\n### 1. 介绍\n\n当 item 在 Spider 中被收集之后，会传递到 item pipline 中处理；\n\n作用：\n\n- 清理 html 数据\n- 验证爬取数据\n- 去重并丢弃\n- 数据持久化\n\n### 2. 编写 item pipline\n\n2.1 必须实现的函数\n\n- process_item\n\n  每个`pipline`都是一个 python 类，负责接收到`item`并执行一些行为，内部必须实现`process_item(self, item, spider)`方法，必须返回一个`dict`或者`item`对象。\n\n  `piplines`只能接受字典和`items`，在主程序通过`yield`推送到`piplines`\n\n  2.2 可以选择实现\n\n- `open_spider(self, spider)`表示当 spider 开启的时候调用的方法；\n- `close_spider(self, spider)`标识当 spider 关闭的时候调用的方法；\n\n注意：\n\n- `pipline`写完需要在配置项`settings`的`ITEM_PIPELINES`里写入来启动\n\n```python\nITEM_PIPELINE {\n  demo.pipelines.testDemoPipeline : 300    // 300是优先级 越大优先级越高\n}\n```\n\n- 文件流写入是缓冲一定字节的数据再一次性写入\n\n  强制立刻写入\n\n```python\nself.file.flush()\n```\n\n---\n\n2.3 如果编写多个`pipeline`，则会改成指定大小去依次执行每次推过来的`item`，如果需要丢弃`item`\n\n```python\n from scrapy.exceptions import DropItem\n\n raise DropItem()\n```\n\n2.4 推送过来的`item`并不是一个 list，如果需要存储数据，则需要转成字典\n\n```python\n self.json_file.writelines(json.dumps(dict(item), ensure_ascii=False) + '\\r')\n```\n","slug":"python爬虫框架scrapy","published":1,"updated":"2019-09-19T07:44:48.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5mv000gh91p78gp1znr","content":"<h3><span id=\"基本用法\">基本用法</span></h3>\n<p>1.创建项目</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject 项目名称</span><br></pre></td></tr></table></figure>\n<p>2.创建一个爬虫</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy genspider XX XX.com</span><br></pre></td></tr></table></figure>\n<p>3.启动脚本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl XX</span><br></pre></td></tr></table></figure>\n<p>也可以新建一个启动文件，比如<code>start.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.cmdline <span class=\"keyword\">import</span> execute</span><br><span class=\"line\"></span><br><span class=\"line\">execute(<span class=\"string\">'scrapy crawl stockX'</span>.split())</span><br></pre></td></tr></table></figure>\n<p>4.爬虫脚本</p>\n<p>必须要有<code>name</code>，这个是和启动对应命令对应的的名称</p>\n<p><code>parse</code>以及<code>start_urls</code>和<code>allowed_domains</code>可选</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'baidu'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'baidu.com'</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">'https://www.baidu.com/'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(response.text)</span><br></pre></td></tr></table></figure>\n<p>其中 start_urls 可以接受多个 url 参数，也可以拆分成多个步骤</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'baidu'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'baidu.com'</span>]</span><br><span class=\"line\">    <span class=\"comment\"># start_urls = ['https://www.baidu.com/']</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_requests</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">yield</span> scrapy.Request(<span class=\"string\">'https://www.baidu.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(response.text)</span><br></pre></td></tr></table></figure>\n<hr>\n<ol>\n<li>\n<p><code>Items</code>相当于定义的需要输出的数据模型，用来存储数据，推送给<code>pipline</code>解析处理；</p>\n</li>\n<li>\n<p>如果要爬取多组数据，最好是建立多个模型，即<code>Item</code>；</p>\n</li>\n</ol>\n<hr>\n<h2><span id=\"pipline\">Pipline</span></h2>\n<h3><span id=\"1-介绍\">1. 介绍</span></h3>\n<p>当 item 在 Spider 中被收集之后，会传递到 item pipline 中处理；</p>\n<p>作用：</p>\n<ul>\n<li>清理 html 数据</li>\n<li>验证爬取数据</li>\n<li>去重并丢弃</li>\n<li>数据持久化</li>\n</ul>\n<h3><span id=\"2-编写-item-pipline\">2. 编写 item pipline</span></h3>\n<p>2.1 必须实现的函数</p>\n<ul>\n<li>\n<p>process_item</p>\n<p>每个<code>pipline</code>都是一个 python 类，负责接收到<code>item</code>并执行一些行为，内部必须实现<code>process_item(self, item, spider)</code>方法，必须返回一个<code>dict</code>或者<code>item</code>对象。</p>\n<p><code>piplines</code>只能接受字典和<code>items</code>，在主程序通过<code>yield</code>推送到<code>piplines</code></p>\n<p>2.2 可以选择实现</p>\n</li>\n<li>\n<p><code>open_spider(self, spider)</code>表示当 spider 开启的时候调用的方法；</p>\n</li>\n<li>\n<p><code>close_spider(self, spider)</code>标识当 spider 关闭的时候调用的方法；</p>\n</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li><code>pipline</code>写完需要在配置项<code>settings</code>的<code>ITEM_PIPELINES</code>里写入来启动</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ITEM_PIPELINE &#123;</span><br><span class=\"line\">  demo.pipelines.testDemoPipeline : <span class=\"number\">300</span>    // <span class=\"number\">300</span>是优先级 越大优先级越高</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>文件流写入是缓冲一定字节的数据再一次性写入</p>\n<p>强制立刻写入</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.file.flush()</span><br></pre></td></tr></table></figure>\n<hr>\n<p>2.3 如果编写多个<code>pipeline</code>，则会改成指定大小去依次执行每次推过来的<code>item</code>，如果需要丢弃<code>item</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.exceptions <span class=\"keyword\">import</span> DropItem</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">raise</span> DropItem()</span><br></pre></td></tr></table></figure>\n<p>2.4 推送过来的<code>item</code>并不是一个 list，如果需要存储数据，则需要转成字典</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.json_file.writelines(json.dumps(dict(item), ensure_ascii=<span class=\"literal\">False</span>) + <span class=\"string\">'\\r'</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3>基本用法</h3>\n<p>1.创建项目</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject 项目名称</span><br></pre></td></tr></table></figure>\n<p>2.创建一个爬虫</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy genspider XX XX.com</span><br></pre></td></tr></table></figure>\n<p>3.启动脚本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl XX</span><br></pre></td></tr></table></figure>\n<p>也可以新建一个启动文件，比如<code>start.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.cmdline <span class=\"keyword\">import</span> execute</span><br><span class=\"line\"></span><br><span class=\"line\">execute(<span class=\"string\">'scrapy crawl stockX'</span>.split())</span><br></pre></td></tr></table></figure>\n<p>4.爬虫脚本</p>\n<p>必须要有<code>name</code>，这个是和启动对应命令对应的的名称</p>\n<p><code>parse</code>以及<code>start_urls</code>和<code>allowed_domains</code>可选</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'baidu'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'baidu.com'</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">'https://www.baidu.com/'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(response.text)</span><br></pre></td></tr></table></figure>\n<p>其中 start_urls 可以接受多个 url 参数，也可以拆分成多个步骤</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'baidu'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'baidu.com'</span>]</span><br><span class=\"line\">    <span class=\"comment\"># start_urls = ['https://www.baidu.com/']</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_requests</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">yield</span> scrapy.Request(<span class=\"string\">'https://www.baidu.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(response.text)</span><br></pre></td></tr></table></figure>\n<hr>\n<ol>\n<li>\n<p><code>Items</code>相当于定义的需要输出的数据模型，用来存储数据，推送给<code>pipline</code>解析处理；</p>\n</li>\n<li>\n<p>如果要爬取多组数据，最好是建立多个模型，即<code>Item</code>；</p>\n</li>\n</ol>\n<hr>\n<h2>Pipline</h2>\n<h3>1. 介绍</h3>\n<p>当 item 在 Spider 中被收集之后，会传递到 item pipline 中处理；</p>\n<p>作用：</p>\n<ul>\n<li>清理 html 数据</li>\n<li>验证爬取数据</li>\n<li>去重并丢弃</li>\n<li>数据持久化</li>\n</ul>\n<h3>2. 编写 item pipline</h3>\n<p>2.1 必须实现的函数</p>\n<ul>\n<li>\n<p>process_item</p>\n<p>每个<code>pipline</code>都是一个 python 类，负责接收到<code>item</code>并执行一些行为，内部必须实现<code>process_item(self, item, spider)</code>方法，必须返回一个<code>dict</code>或者<code>item</code>对象。</p>\n<p><code>piplines</code>只能接受字典和<code>items</code>，在主程序通过<code>yield</code>推送到<code>piplines</code></p>\n<p>2.2 可以选择实现</p>\n</li>\n<li>\n<p><code>open_spider(self, spider)</code>表示当 spider 开启的时候调用的方法；</p>\n</li>\n<li>\n<p><code>close_spider(self, spider)</code>标识当 spider 关闭的时候调用的方法；</p>\n</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li><code>pipline</code>写完需要在配置项<code>settings</code>的<code>ITEM_PIPELINES</code>里写入来启动</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ITEM_PIPELINE &#123;</span><br><span class=\"line\">  demo.pipelines.testDemoPipeline : <span class=\"number\">300</span>    // <span class=\"number\">300</span>是优先级 越大优先级越高</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>文件流写入是缓冲一定字节的数据再一次性写入</p>\n<p>强制立刻写入</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.file.flush()</span><br></pre></td></tr></table></figure>\n<hr>\n<p>2.3 如果编写多个<code>pipeline</code>，则会改成指定大小去依次执行每次推过来的<code>item</code>，如果需要丢弃<code>item</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.exceptions <span class=\"keyword\">import</span> DropItem</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">raise</span> DropItem()</span><br></pre></td></tr></table></figure>\n<p>2.4 推送过来的<code>item</code>并不是一个 list，如果需要存储数据，则需要转成字典</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.json_file.writelines(json.dumps(dict(item), ensure_ascii=<span class=\"literal\">False</span>) + <span class=\"string\">'\\r'</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"pm2常用命令整理","catalog":true,"date":"2019-07-25T14:34:15.000Z","subtitle":null,"header-img":null,"_content":"\n- pm2 start\n\n之前一直使用过程中，都是指定一个启动文件（`pm2 start app.js`），后来在用`pm2`部署`nuxt.js`项目时候，发现这样的方式不太能用，查阅文档发现可以使用以 npm 方式执行 script 脚本命令\n\n```shell\n# pm2 start npm --name '进程名称' -- run 脚本命令\n# package.json\n#  script: {\n#    \"start:nuxt\": \"nuxt build\"\n#}\npm2 start npm -- run start:nuxt --name 'nuxt'\n```\n","source":"_posts/pm2常用命令整理.md","raw":"---\ntitle: pm2常用命令整理\ncatalog: true\ndate: 2019-07-25 22:34:15\nsubtitle:\nheader-img:\ntags: node\n---\n\n- pm2 start\n\n之前一直使用过程中，都是指定一个启动文件（`pm2 start app.js`），后来在用`pm2`部署`nuxt.js`项目时候，发现这样的方式不太能用，查阅文档发现可以使用以 npm 方式执行 script 脚本命令\n\n```shell\n# pm2 start npm --name '进程名称' -- run 脚本命令\n# package.json\n#  script: {\n#    \"start:nuxt\": \"nuxt build\"\n#}\npm2 start npm -- run start:nuxt --name 'nuxt'\n```\n","slug":"pm2常用命令整理","published":1,"updated":"2019-07-25T14:40:00.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5mw000hh91pwqm7et99","content":"<ul>\n<li>pm2 start</li>\n</ul>\n<p>之前一直使用过程中，都是指定一个启动文件（<code>pm2 start app.js</code>），后来在用<code>pm2</code>部署<code>nuxt.js</code>项目时候，发现这样的方式不太能用，查阅文档发现可以使用以 npm 方式执行 script 脚本命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> pm2 start npm --name '进程名称' -- run 脚本命令</span><br><span class=\"line\"><span class=\"meta\">#</span> package.json</span><br><span class=\"line\"><span class=\"meta\">#</span>  script: &#123;</span><br><span class=\"line\"><span class=\"meta\">#</span>    \"start:nuxt\": \"nuxt build\"</span><br><span class=\"line\"><span class=\"meta\">#</span>&#125;</span><br><span class=\"line\">pm2 start npm -- run start:nuxt --name 'nuxt'</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>pm2 start</li>\n</ul>\n<p>之前一直使用过程中，都是指定一个启动文件（<code>pm2 start app.js</code>），后来在用<code>pm2</code>部署<code>nuxt.js</code>项目时候，发现这样的方式不太能用，查阅文档发现可以使用以 npm 方式执行 script 脚本命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> pm2 start npm --name '进程名称' -- run 脚本命令</span><br><span class=\"line\"><span class=\"meta\">#</span> package.json</span><br><span class=\"line\"><span class=\"meta\">#</span>  script: &#123;</span><br><span class=\"line\"><span class=\"meta\">#</span>    \"start:nuxt\": \"nuxt build\"</span><br><span class=\"line\"><span class=\"meta\">#</span>&#125;</span><br><span class=\"line\">pm2 start npm -- run start:nuxt --name 'nuxt'</span><br></pre></td></tr></table></figure>\n"},{"title":"linux常用指令记录","catalog":true,"date":"2019-03-25T12:41:36.000Z","subtitle":null,"header-img":null,"_content":"\n1. 软连接\n\nln -s 软件源目录 /usr/local/bin/\n\n比如安装完 node 将`/app/software/nodejs/bin/node`的命令提示符直接通过`node`去访问\n\n```shell\n# ln -s 源文件bin目录 系统bin目录\nln -s /app/software/nodejs/bin/node /usr/local/bin/node\n```\n\n删除软连接\n\n```shell\nrm -rf /usr/local/bin/node\n```\n\n2. 创建文件\n\n```shell\ntouch XXX\n```\n\n3.  查看进程\n\n```shell\nnetstat -ntpl\n```\n\n4. 设置环境变量\n\n`vi /etc/profile`在文件的最下方倒数第三行里面编写变量名，例如：`export NGINX=/usr/local/webserver/nginx/conf` 保存之后不会立即生效，需要输入`source /etc/profile`，之后`echo $NGINX`查看是否生效\n\n5. `rsync`跨服务器传输文件\n\n```shell\n  rsync  -rzte 'ssh -p 22' 源目录 目的地目录\n```\n\n要是服务器 A 要传文件到服务器 B，可能会存在没有权限的问题，这个时候就要 A 生成公钥`ssh-keygen`，将 A 的公钥`id_rsa.pub`内容复制到 B 服务器`.ssh/authorized_keys`内容下方，就可以解决权限问题了。\n\n6. 设置新建立的`shell`等脚本拥有可执行权限\n\n```shell\nchmod +x 路径\n```\n\n7. 将指定用户/用户组加入到其他组\n\n```shell\n gpasswd -a www root   // www将入到root组\n```\n\n8. 给指定目录以指定用户/用户组的所有权限\n\n```shell\nchown -R www:www /data/www-data/test\n```\n\n9. source\n\n用户登录系统会自动创建一个父`shell`，如果在这个父`shell`里面执行一个`shell`则为子`shell`，两者创建的变量是不会共享的，如果需要登陆的`shell`可以访问内部的`shell`变量，需要用`source`命令，在当前父`shell`窗口立刻执行子`shell`，能访问子`shell`变量，也不用注销用户登录。\n`export`是父`shell`暴露变量给子`shell`使用\n\n[source 详解](https://www.cnblogs.com/ThatsMyTiger/p/6865817.html)\n\n10. curl\n\n- -O 将指定地址的文件下载到本地\n\n```shell\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.6.tgz\n```\n\n11. tar 解压/压缩\n\n-c: 压缩\n-x：解压\n-t：查看内容\n-r：向压缩归档文件末尾追加文件\n-u：更新原压缩包中的文件\n-f：（必选且必须在最后一个参数）使用源文件名字\n-z：有 gzip 属性的\n-j：有 bz2 属性的\n-Z：有 compress 属性的\n-v：显示所有过程\n-O：将文件解开到标准输出\n\n```shell\ntar -zxvf 源文件\n```\n\n12. grep\n\n查找字符串中指定的字符\n\n```shell\ngrep [-acinv] [--color=auto] '搜寻字符串' filename\n```\n\n选项与参数：\n-a ：将 binary 文件以 text 文件的方式搜寻数据\n-c ：计算找到 '搜寻字符串' 的次数\n-i ：忽略大小写的不同，所以大小写视为相同\n-n ：顺便输出行号\n-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！\n--color=auto ：可以将找到的关键词部分加上颜色的显示喔！\n\n14. rm\n\n-r 向下遍历目录文件依次删除\n-f 强制删除\n\n全部删除但排除某个文件\n\n比如：排除.git 之外的所有文件\n\n```shell\nrm -rf `ls |grep -v .git`\n```\n\n15. cp\n\ncp -r 源目录地址 目标目录地址\n\n16. 新打开一个 shell 自动执行一些配置项 在/root/.bashrc 下编辑默认环境变量 全部 shell 共享需要修改/etc/profile\n\n17. ansible\n\n远程服务器 切换目录`chdir`\n\n```shell\nansible -i /opt/script/xxx.hosts duapp-node-common-service -u root -m shell -a 'chdir=/data/www-data/hupu.com/node-common sh start.sh'\n```\n\n18. 全局查找某个文件\n\n```shell\nfind / -name 文件名\n```\n\n常见错误处理参考链接：\n\n- [nginx 在 reload 时候报错 invalid PID number](https://www.cnblogs.com/tielemao/p/6163419.html)\n- [nginx: [emerg] invalid socket number ](https://blog.csdn.net/bikeorcl/article/details/78850265)\n","source":"_posts/linux常用指令记录.md","raw":"---\ntitle: linux常用指令记录\ncatalog: true\ndate: 2019-03-25 20:41:36\nsubtitle:\nheader-img:\ntags: linux\n---\n\n1. 软连接\n\nln -s 软件源目录 /usr/local/bin/\n\n比如安装完 node 将`/app/software/nodejs/bin/node`的命令提示符直接通过`node`去访问\n\n```shell\n# ln -s 源文件bin目录 系统bin目录\nln -s /app/software/nodejs/bin/node /usr/local/bin/node\n```\n\n删除软连接\n\n```shell\nrm -rf /usr/local/bin/node\n```\n\n2. 创建文件\n\n```shell\ntouch XXX\n```\n\n3.  查看进程\n\n```shell\nnetstat -ntpl\n```\n\n4. 设置环境变量\n\n`vi /etc/profile`在文件的最下方倒数第三行里面编写变量名，例如：`export NGINX=/usr/local/webserver/nginx/conf` 保存之后不会立即生效，需要输入`source /etc/profile`，之后`echo $NGINX`查看是否生效\n\n5. `rsync`跨服务器传输文件\n\n```shell\n  rsync  -rzte 'ssh -p 22' 源目录 目的地目录\n```\n\n要是服务器 A 要传文件到服务器 B，可能会存在没有权限的问题，这个时候就要 A 生成公钥`ssh-keygen`，将 A 的公钥`id_rsa.pub`内容复制到 B 服务器`.ssh/authorized_keys`内容下方，就可以解决权限问题了。\n\n6. 设置新建立的`shell`等脚本拥有可执行权限\n\n```shell\nchmod +x 路径\n```\n\n7. 将指定用户/用户组加入到其他组\n\n```shell\n gpasswd -a www root   // www将入到root组\n```\n\n8. 给指定目录以指定用户/用户组的所有权限\n\n```shell\nchown -R www:www /data/www-data/test\n```\n\n9. source\n\n用户登录系统会自动创建一个父`shell`，如果在这个父`shell`里面执行一个`shell`则为子`shell`，两者创建的变量是不会共享的，如果需要登陆的`shell`可以访问内部的`shell`变量，需要用`source`命令，在当前父`shell`窗口立刻执行子`shell`，能访问子`shell`变量，也不用注销用户登录。\n`export`是父`shell`暴露变量给子`shell`使用\n\n[source 详解](https://www.cnblogs.com/ThatsMyTiger/p/6865817.html)\n\n10. curl\n\n- -O 将指定地址的文件下载到本地\n\n```shell\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.6.tgz\n```\n\n11. tar 解压/压缩\n\n-c: 压缩\n-x：解压\n-t：查看内容\n-r：向压缩归档文件末尾追加文件\n-u：更新原压缩包中的文件\n-f：（必选且必须在最后一个参数）使用源文件名字\n-z：有 gzip 属性的\n-j：有 bz2 属性的\n-Z：有 compress 属性的\n-v：显示所有过程\n-O：将文件解开到标准输出\n\n```shell\ntar -zxvf 源文件\n```\n\n12. grep\n\n查找字符串中指定的字符\n\n```shell\ngrep [-acinv] [--color=auto] '搜寻字符串' filename\n```\n\n选项与参数：\n-a ：将 binary 文件以 text 文件的方式搜寻数据\n-c ：计算找到 '搜寻字符串' 的次数\n-i ：忽略大小写的不同，所以大小写视为相同\n-n ：顺便输出行号\n-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！\n--color=auto ：可以将找到的关键词部分加上颜色的显示喔！\n\n14. rm\n\n-r 向下遍历目录文件依次删除\n-f 强制删除\n\n全部删除但排除某个文件\n\n比如：排除.git 之外的所有文件\n\n```shell\nrm -rf `ls |grep -v .git`\n```\n\n15. cp\n\ncp -r 源目录地址 目标目录地址\n\n16. 新打开一个 shell 自动执行一些配置项 在/root/.bashrc 下编辑默认环境变量 全部 shell 共享需要修改/etc/profile\n\n17. ansible\n\n远程服务器 切换目录`chdir`\n\n```shell\nansible -i /opt/script/xxx.hosts duapp-node-common-service -u root -m shell -a 'chdir=/data/www-data/hupu.com/node-common sh start.sh'\n```\n\n18. 全局查找某个文件\n\n```shell\nfind / -name 文件名\n```\n\n常见错误处理参考链接：\n\n- [nginx 在 reload 时候报错 invalid PID number](https://www.cnblogs.com/tielemao/p/6163419.html)\n- [nginx: [emerg] invalid socket number ](https://blog.csdn.net/bikeorcl/article/details/78850265)\n","slug":"linux常用指令记录","published":1,"updated":"2019-07-26T04:10:39.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5my000jh91pe7y1on1w","content":"<ol>\n<li>软连接</li>\n</ol>\n<p>ln -s 软件源目录 /usr/local/bin/</p>\n<p>比如安装完 node 将<code>/app/software/nodejs/bin/node</code>的命令提示符直接通过<code>node</code>去访问</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> ln -s 源文件bin目录 系统bin目录</span><br><span class=\"line\">ln -s /app/software/nodejs/bin/node /usr/local/bin/node</span><br></pre></td></tr></table></figure>\n<p>删除软连接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf /usr/local/bin/node</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>创建文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch XXX</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>查看进程</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntpl</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>设置环境变量</li>\n</ol>\n<p><code>vi /etc/profile</code>在文件的最下方倒数第三行里面编写变量名，例如：<code>export NGINX=/usr/local/webserver/nginx/conf</code> 保存之后不会立即生效，需要输入<code>source /etc/profile</code>，之后<code>echo $NGINX</code>查看是否生效</p>\n<ol start=\"5\">\n<li><code>rsync</code>跨服务器传输文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync  -rzte 'ssh -p 22' 源目录 目的地目录</span><br></pre></td></tr></table></figure>\n<p>要是服务器 A 要传文件到服务器 B，可能会存在没有权限的问题，这个时候就要 A 生成公钥<code>ssh-keygen</code>，将 A 的公钥<code>id_rsa.pub</code>内容复制到 B 服务器<code>.ssh/authorized_keys</code>内容下方，就可以解决权限问题了。</p>\n<ol start=\"6\">\n<li>设置新建立的<code>shell</code>等脚本拥有可执行权限</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x 路径</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>将指定用户/用户组加入到其他组</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpasswd -a www root   // www将入到root组</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>给指定目录以指定用户/用户组的所有权限</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -R www:www /data/www-data/test</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>source</li>\n</ol>\n<p>用户登录系统会自动创建一个父<code>shell</code>，如果在这个父<code>shell</code>里面执行一个<code>shell</code>则为子<code>shell</code>，两者创建的变量是不会共享的，如果需要登陆的<code>shell</code>可以访问内部的<code>shell</code>变量，需要用<code>source</code>命令，在当前父<code>shell</code>窗口立刻执行子<code>shell</code>，能访问子<code>shell</code>变量，也不用注销用户登录。<br>\n<code>export</code>是父<code>shell</code>暴露变量给子<code>shell</code>使用</p>\n<p><a href=\"https://www.cnblogs.com/ThatsMyTiger/p/6865817.html\" target=\"_blank\" rel=\"noopener\">source 详解</a></p>\n<ol start=\"10\">\n<li>curl</li>\n</ol>\n<ul>\n<li>-O 将指定地址的文件下载到本地</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.6.tgz</span><br></pre></td></tr></table></figure>\n<ol start=\"11\">\n<li>tar 解压/压缩</li>\n</ol>\n<p>-c: 压缩<br>\n-x：解压<br>\n-t：查看内容<br>\n-r：向压缩归档文件末尾追加文件<br>\n-u：更新原压缩包中的文件<br>\n-f：（必选且必须在最后一个参数）使用源文件名字<br>\n-z：有 gzip 属性的<br>\n-j：有 bz2 属性的<br>\n-Z：有 compress 属性的<br>\n-v：显示所有过程<br>\n-O：将文件解开到标准输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf 源文件</span><br></pre></td></tr></table></figure>\n<ol start=\"12\">\n<li>grep</li>\n</ol>\n<p>查找字符串中指定的字符</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [-acinv] [--color=auto] '搜寻字符串' filename</span><br></pre></td></tr></table></figure>\n<p>选项与参数：<br>\n-a ：将 binary 文件以 text 文件的方式搜寻数据<br>\n-c ：计算找到 ‘搜寻字符串’ 的次数<br>\n-i ：忽略大小写的不同，所以大小写视为相同<br>\n-n ：顺便输出行号<br>\n-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！<br>\n–color=auto ：可以将找到的关键词部分加上颜色的显示喔！</p>\n<ol start=\"14\">\n<li>rm</li>\n</ol>\n<p>-r 向下遍历目录文件依次删除<br>\n-f 强制删除</p>\n<p>全部删除但排除某个文件</p>\n<p>比如：排除.git 之外的所有文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf `ls |grep -v .git`</span><br></pre></td></tr></table></figure>\n<ol start=\"15\">\n<li>cp</li>\n</ol>\n<p>cp -r 源目录地址 目标目录地址</p>\n<ol start=\"16\">\n<li>\n<p>新打开一个 shell 自动执行一些配置项 在/root/.bashrc 下编辑默认环境变量 全部 shell 共享需要修改/etc/profile</p>\n</li>\n<li>\n<p>ansible</p>\n</li>\n</ol>\n<p>远程服务器 切换目录<code>chdir</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible -i /opt/script/xxx.hosts duapp-node-common-service -u root -m shell -a 'chdir=/data/www-data/hupu.com/node-common sh start.sh'</span><br></pre></td></tr></table></figure>\n<ol start=\"18\">\n<li>全局查找某个文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name 文件名</span><br></pre></td></tr></table></figure>\n<p>常见错误处理参考链接：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/tielemao/p/6163419.html\" target=\"_blank\" rel=\"noopener\">nginx 在 reload 时候报错 invalid PID number</a></li>\n<li><a href=\"https://blog.csdn.net/bikeorcl/article/details/78850265\" target=\"_blank\" rel=\"noopener\">nginx: [emerg] invalid socket number </a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>软连接</li>\n</ol>\n<p>ln -s 软件源目录 /usr/local/bin/</p>\n<p>比如安装完 node 将<code>/app/software/nodejs/bin/node</code>的命令提示符直接通过<code>node</code>去访问</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> ln -s 源文件bin目录 系统bin目录</span><br><span class=\"line\">ln -s /app/software/nodejs/bin/node /usr/local/bin/node</span><br></pre></td></tr></table></figure>\n<p>删除软连接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf /usr/local/bin/node</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>创建文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch XXX</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>查看进程</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntpl</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>设置环境变量</li>\n</ol>\n<p><code>vi /etc/profile</code>在文件的最下方倒数第三行里面编写变量名，例如：<code>export NGINX=/usr/local/webserver/nginx/conf</code> 保存之后不会立即生效，需要输入<code>source /etc/profile</code>，之后<code>echo $NGINX</code>查看是否生效</p>\n<ol start=\"5\">\n<li><code>rsync</code>跨服务器传输文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync  -rzte 'ssh -p 22' 源目录 目的地目录</span><br></pre></td></tr></table></figure>\n<p>要是服务器 A 要传文件到服务器 B，可能会存在没有权限的问题，这个时候就要 A 生成公钥<code>ssh-keygen</code>，将 A 的公钥<code>id_rsa.pub</code>内容复制到 B 服务器<code>.ssh/authorized_keys</code>内容下方，就可以解决权限问题了。</p>\n<ol start=\"6\">\n<li>设置新建立的<code>shell</code>等脚本拥有可执行权限</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x 路径</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>将指定用户/用户组加入到其他组</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpasswd -a www root   // www将入到root组</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>给指定目录以指定用户/用户组的所有权限</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -R www:www /data/www-data/test</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>source</li>\n</ol>\n<p>用户登录系统会自动创建一个父<code>shell</code>，如果在这个父<code>shell</code>里面执行一个<code>shell</code>则为子<code>shell</code>，两者创建的变量是不会共享的，如果需要登陆的<code>shell</code>可以访问内部的<code>shell</code>变量，需要用<code>source</code>命令，在当前父<code>shell</code>窗口立刻执行子<code>shell</code>，能访问子<code>shell</code>变量，也不用注销用户登录。<br>\n<code>export</code>是父<code>shell</code>暴露变量给子<code>shell</code>使用</p>\n<p><a href=\"https://www.cnblogs.com/ThatsMyTiger/p/6865817.html\" target=\"_blank\" rel=\"noopener\">source 详解</a></p>\n<ol start=\"10\">\n<li>curl</li>\n</ol>\n<ul>\n<li>-O 将指定地址的文件下载到本地</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.6.tgz</span><br></pre></td></tr></table></figure>\n<ol start=\"11\">\n<li>tar 解压/压缩</li>\n</ol>\n<p>-c: 压缩<br>\n-x：解压<br>\n-t：查看内容<br>\n-r：向压缩归档文件末尾追加文件<br>\n-u：更新原压缩包中的文件<br>\n-f：（必选且必须在最后一个参数）使用源文件名字<br>\n-z：有 gzip 属性的<br>\n-j：有 bz2 属性的<br>\n-Z：有 compress 属性的<br>\n-v：显示所有过程<br>\n-O：将文件解开到标准输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf 源文件</span><br></pre></td></tr></table></figure>\n<ol start=\"12\">\n<li>grep</li>\n</ol>\n<p>查找字符串中指定的字符</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [-acinv] [--color=auto] '搜寻字符串' filename</span><br></pre></td></tr></table></figure>\n<p>选项与参数：<br>\n-a ：将 binary 文件以 text 文件的方式搜寻数据<br>\n-c ：计算找到 ‘搜寻字符串’ 的次数<br>\n-i ：忽略大小写的不同，所以大小写视为相同<br>\n-n ：顺便输出行号<br>\n-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！<br>\n–color=auto ：可以将找到的关键词部分加上颜色的显示喔！</p>\n<ol start=\"14\">\n<li>rm</li>\n</ol>\n<p>-r 向下遍历目录文件依次删除<br>\n-f 强制删除</p>\n<p>全部删除但排除某个文件</p>\n<p>比如：排除.git 之外的所有文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf `ls |grep -v .git`</span><br></pre></td></tr></table></figure>\n<ol start=\"15\">\n<li>cp</li>\n</ol>\n<p>cp -r 源目录地址 目标目录地址</p>\n<ol start=\"16\">\n<li>\n<p>新打开一个 shell 自动执行一些配置项 在/root/.bashrc 下编辑默认环境变量 全部 shell 共享需要修改/etc/profile</p>\n</li>\n<li>\n<p>ansible</p>\n</li>\n</ol>\n<p>远程服务器 切换目录<code>chdir</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible -i /opt/script/xxx.hosts duapp-node-common-service -u root -m shell -a 'chdir=/data/www-data/hupu.com/node-common sh start.sh'</span><br></pre></td></tr></table></figure>\n<ol start=\"18\">\n<li>全局查找某个文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name 文件名</span><br></pre></td></tr></table></figure>\n<p>常见错误处理参考链接：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/tielemao/p/6163419.html\" target=\"_blank\" rel=\"noopener\">nginx 在 reload 时候报错 invalid PID number</a></li>\n<li><a href=\"https://blog.csdn.net/bikeorcl/article/details/78850265\" target=\"_blank\" rel=\"noopener\">nginx: [emerg] invalid socket number </a></li>\n</ul>\n"},{"title":"rollup.js使用","catalog":true,"date":"2019-09-25T03:29:27.000Z","subtitle":null,"header-img":null,"_content":"\noutput.format 生成包的格式，有如下格式：\n\n1. amd -- 异步模块定义，用于像 RequestJS 这样的模块加载器。\n2. cjs -- CommonJS, 适用于 Node 或 Browserify/webpack\n3. es -- 将软件包保存为 ES 模块文件。\n4. iife -- 一个自动执行的功能，适合作为 <script>标签这样的。\n5. umd -- 通用模块定义，以 amd, cjs, 和 iife 为一体。\n","source":"_posts/rollup-js使用.md","raw":"---\ntitle: rollup.js使用\ncatalog: true\ndate: 2019-09-25 11:29:27\nsubtitle:\nheader-img:\ntags: javascript\n---\n\noutput.format 生成包的格式，有如下格式：\n\n1. amd -- 异步模块定义，用于像 RequestJS 这样的模块加载器。\n2. cjs -- CommonJS, 适用于 Node 或 Browserify/webpack\n3. es -- 将软件包保存为 ES 模块文件。\n4. iife -- 一个自动执行的功能，适合作为 <script>标签这样的。\n5. umd -- 通用模块定义，以 amd, cjs, 和 iife 为一体。\n","slug":"rollup-js使用","published":1,"updated":"2019-09-25T03:29:47.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5mz000lh91pguertdi9","content":"<p>output.format 生成包的格式，有如下格式：</p>\n<ol>\n<li>amd – 异步模块定义，用于像 RequestJS 这样的模块加载器。</li>\n<li>cjs – CommonJS, 适用于 Node 或 Browserify/webpack</li>\n<li>es – 将软件包保存为 ES 模块文件。</li>\n<li>iife – 一个自动执行的功能，适合作为 <script>标签这样的。</li>\n<li>umd – 通用模块定义，以 amd, cjs, 和 iife 为一体。</li>\n</ol>\n</script></li></ol>","site":{"data":{}},"excerpt":"","more":"<p>output.format 生成包的格式，有如下格式：</p>\n<ol>\n<li>amd – 异步模块定义，用于像 RequestJS 这样的模块加载器。</li>\n<li>cjs – CommonJS, 适用于 Node 或 Browserify/webpack</li>\n<li>es – 将软件包保存为 ES 模块文件。</li>\n<li>iife – 一个自动执行的功能，适合作为 <script>标签这样的。</li>\n<li>umd – 通用模块定义，以 amd, cjs, 和 iife 为一体。</li>\n</ol>\n</script></li></ol>"},{"title":"react/vue中dom-diff简易版实现","catalog":true,"date":"2019-06-20T03:33:40.000Z","subtitle":null,"header-img":null,"_content":"\n## 一、创建虚拟dom\n\n利用 `create-react-app`快速创建一个项目模板；\n\n删掉src下的源文件，替换成 index.js\n\n首先我们先要用一个对象定义一个虚拟DOM的数据结构：\n\n```shell\nElement {\n    type: 'ul',\n    props: {\n        class: 'list'\n    },\n    children: [\n        Element{\n            type: 'li',\n            props: {\n                class: 'item'\n            },\n            children: ['a']\n        }\n    ]\n}\n```\n\n开始码代码实现虚拟dom的方法实现。\n\n!['虚拟DOM结构'](https://user-gold-cdn.xitu.io/2018/11/3/166d7c8c5aa6083b?w=2956&h=992&f=png&s=271739)\n浏览器上查看打印的日志信息，如下：\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7ca53ba8fef7?w=1210&h=410&f=png&s=97781)\n\n既然虚拟DOM方法已经写好，下一步就要将这个虚拟dom插入到页面中，那我们可以专门写一个渲染真实节点的方法`render`\n\n先遍历最外层`ul`的`type`和`props`两个属性\n\n![render](https://user-gold-cdn.xitu.io/2018/11/3/166d7e8001b419a3?w=2568&h=1244&f=png&s=359336)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7e9fddde1a34?w=1078&h=128&f=png&s=25171)\n\n注意：`input`标签的`value`属性 还有所有标签的`style`属性\n\n好了，接下来就是继续遍历`children`属性，此时`children`会有两种情况\n\n1. 如果是文本 直接插入；\n2. 如果是子元素，递归遍历直到最终的结果是文本；\n\n![遍历虚拟don元素转换为真实dom结构](https://user-gold-cdn.xitu.io/2018/11/3/166d7f0b58ed9735?w=1036&h=484&f=png&s=95541)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7f0d50748a42?w=676&h=198&f=png&s=31439)\n\n下一步我们将这个实际的DOM元素结构插入到页面中\n\n![append](https://user-gold-cdn.xitu.io/2018/11/3/166d8078bce16225?w=2988&h=774&f=png&s=270016)\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d805dec820f97?w=1120&h=862&f=png&s=112852)\n\n完成第一部分。\n\n---\n\n## 二、实现dom-diff算法\n\n`dom-diff`算法就是在两棵抽象语法树的同一位置采用先序的深度遍历算法做比较，同时用补丁的形式记录需要更新的节点位置。\n\n若`type`不一致直接替换当前节点以及当前节点下的子节点；\n如果两个父节点一致，则从左往后遍历子节点，若子节点一致，遍历子节点下的子节点，依次递归。\n\n补丁包的定义规则如下：\n\n1. 属性不同（type: 'ATTRS', attrs）\n2. 新的节点被删除了 （type: 'REMOVE', index: xxxx）\n3. 节点类型不同/\b新增 （type: 'REPLACE', newNode）\n4. 仅仅是文本变化（type: 'TEXT', text）\n\n新建一个`dom-diff.js`，专门处理`diff`算法\n\n手动调用`diff`方法（react中\b调用`diff`算法是在触发`setState`之后）\n\n两个虚拟dom结构如下：\n\n![虚拟dom结构](https://user-gold-cdn.xitu.io/2018/11/4/166ddf9046719203?w=1272&h=896&f=png&s=189549)\n\n先处理`type`相同，属性不同的情况。\n\n![属性不同](https://user-gold-cdn.xitu.io/2018/11/4/166dca2da79ddd4a?w=1240&h=1688&f=png&s=288100)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166dca49d1e2ece5?w=1158&h=420&f=png&s=70893)\n\n发现控制台已经打印到属性变化的补丁包，最后我们把属性的小补丁包存放到最外层的大补丁包中\n\n```shell\n// 补丁包 存放两个虚拟dom的差异部分\nlet patchs = {}\n// 放到最外层的大补丁包中\nif (currentPatchs.length > 0) {\n  patchs[index] = currentPatchs\n}\n```\n\n好了 相同类型的父节点一样，在属性比较完成之后，就需要比较`children`的属性是否有变化\n比较`children`属性内部元素是否变化，利用递归去遍历\n\n```shell\nlet globalIndex = 0\n\nfunction diffChildren (oldChildrens, newChildrens) {\n  oldChildrens.forEach((child, idx) => {\n    walk(child, newChildrens[idx], ++globalIndex)\n  })\n}\n```\n\n如果一开始`type`类型不相同不需要再去比较，直接用新节点替换老节点即可；\n\n```shell\n// type不一致\ncurrentPatchs.push({\n  type: TYPES.REPLACE,\n  newNode: newTree\n})\n```\n\n兼容并处理好各种情况，比如：新节点不存在的情况，新节点增加，新节点类型改变，新节点文本改变以及新节点的属性变化等情况；\n\n最终拿到所有与旧节点有差异的对象放入patchs这样的一个补丁对象中。\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166dde85f556609a?w=1432&h=1092&f=png&s=211043)\n\n补丁包的`key`就是对应新节点有变化的数据位置。\n\n---\n\n## 三、 打补丁更新视图\n\n最后一步将补丁的差异对象与现有虚拟DOM节点遍历进行一一比较与替换。\n\n![开始打补丁](https://user-gold-cdn.xitu.io/2018/11/4/166ddee92a1a76de?w=1098&h=426&f=png&s=61221)\n\n![补丁步骤](https://user-gold-cdn.xitu.io/2018/11/4/166ddeed8a40ba8c?w=1096&h=1094&f=png&s=175704)\n\n根据之前定义的不同补丁对象结构依次处理\n\n![补丁步骤](https://user-gold-cdn.xitu.io/2018/11/4/166ddf0cc87aaa5d?w=1248&h=1138&f=png&s=192351)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166ddf097e341aaf?w=1006&h=1032&f=png&s=120960)\n\n大功告成！\n\n---\n\n这只是diff算法的一个简易实现，还存在一些复杂情况处理的情况以及还有很多算法上面优化的方案，不过已经让我们大概了解了`diff`算法的原理。\n\n如有笔误或者其他实现不对的地方，还望大家指出，谢谢！\n\n具体代码可以参考github链接查看：[dom-diff-demo](https://github.com/Megan-TA/dom-diff-demo)\n","source":"_posts/react-vue中dom-diff简易版实现.md","raw":"---\ntitle: react/vue中dom-diff简易版实现\ncatalog: true\ndate: 2019-06-20 11:33:40\nsubtitle:\nheader-img:\ntags: vue react\n---\n\n## 一、创建虚拟dom\n\n利用 `create-react-app`快速创建一个项目模板；\n\n删掉src下的源文件，替换成 index.js\n\n首先我们先要用一个对象定义一个虚拟DOM的数据结构：\n\n```shell\nElement {\n    type: 'ul',\n    props: {\n        class: 'list'\n    },\n    children: [\n        Element{\n            type: 'li',\n            props: {\n                class: 'item'\n            },\n            children: ['a']\n        }\n    ]\n}\n```\n\n开始码代码实现虚拟dom的方法实现。\n\n!['虚拟DOM结构'](https://user-gold-cdn.xitu.io/2018/11/3/166d7c8c5aa6083b?w=2956&h=992&f=png&s=271739)\n浏览器上查看打印的日志信息，如下：\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7ca53ba8fef7?w=1210&h=410&f=png&s=97781)\n\n既然虚拟DOM方法已经写好，下一步就要将这个虚拟dom插入到页面中，那我们可以专门写一个渲染真实节点的方法`render`\n\n先遍历最外层`ul`的`type`和`props`两个属性\n\n![render](https://user-gold-cdn.xitu.io/2018/11/3/166d7e8001b419a3?w=2568&h=1244&f=png&s=359336)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7e9fddde1a34?w=1078&h=128&f=png&s=25171)\n\n注意：`input`标签的`value`属性 还有所有标签的`style`属性\n\n好了，接下来就是继续遍历`children`属性，此时`children`会有两种情况\n\n1. 如果是文本 直接插入；\n2. 如果是子元素，递归遍历直到最终的结果是文本；\n\n![遍历虚拟don元素转换为真实dom结构](https://user-gold-cdn.xitu.io/2018/11/3/166d7f0b58ed9735?w=1036&h=484&f=png&s=95541)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7f0d50748a42?w=676&h=198&f=png&s=31439)\n\n下一步我们将这个实际的DOM元素结构插入到页面中\n\n![append](https://user-gold-cdn.xitu.io/2018/11/3/166d8078bce16225?w=2988&h=774&f=png&s=270016)\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d805dec820f97?w=1120&h=862&f=png&s=112852)\n\n完成第一部分。\n\n---\n\n## 二、实现dom-diff算法\n\n`dom-diff`算法就是在两棵抽象语法树的同一位置采用先序的深度遍历算法做比较，同时用补丁的形式记录需要更新的节点位置。\n\n若`type`不一致直接替换当前节点以及当前节点下的子节点；\n如果两个父节点一致，则从左往后遍历子节点，若子节点一致，遍历子节点下的子节点，依次递归。\n\n补丁包的定义规则如下：\n\n1. 属性不同（type: 'ATTRS', attrs）\n2. 新的节点被删除了 （type: 'REMOVE', index: xxxx）\n3. 节点类型不同/\b新增 （type: 'REPLACE', newNode）\n4. 仅仅是文本变化（type: 'TEXT', text）\n\n新建一个`dom-diff.js`，专门处理`diff`算法\n\n手动调用`diff`方法（react中\b调用`diff`算法是在触发`setState`之后）\n\n两个虚拟dom结构如下：\n\n![虚拟dom结构](https://user-gold-cdn.xitu.io/2018/11/4/166ddf9046719203?w=1272&h=896&f=png&s=189549)\n\n先处理`type`相同，属性不同的情况。\n\n![属性不同](https://user-gold-cdn.xitu.io/2018/11/4/166dca2da79ddd4a?w=1240&h=1688&f=png&s=288100)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166dca49d1e2ece5?w=1158&h=420&f=png&s=70893)\n\n发现控制台已经打印到属性变化的补丁包，最后我们把属性的小补丁包存放到最外层的大补丁包中\n\n```shell\n// 补丁包 存放两个虚拟dom的差异部分\nlet patchs = {}\n// 放到最外层的大补丁包中\nif (currentPatchs.length > 0) {\n  patchs[index] = currentPatchs\n}\n```\n\n好了 相同类型的父节点一样，在属性比较完成之后，就需要比较`children`的属性是否有变化\n比较`children`属性内部元素是否变化，利用递归去遍历\n\n```shell\nlet globalIndex = 0\n\nfunction diffChildren (oldChildrens, newChildrens) {\n  oldChildrens.forEach((child, idx) => {\n    walk(child, newChildrens[idx], ++globalIndex)\n  })\n}\n```\n\n如果一开始`type`类型不相同不需要再去比较，直接用新节点替换老节点即可；\n\n```shell\n// type不一致\ncurrentPatchs.push({\n  type: TYPES.REPLACE,\n  newNode: newTree\n})\n```\n\n兼容并处理好各种情况，比如：新节点不存在的情况，新节点增加，新节点类型改变，新节点文本改变以及新节点的属性变化等情况；\n\n最终拿到所有与旧节点有差异的对象放入patchs这样的一个补丁对象中。\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166dde85f556609a?w=1432&h=1092&f=png&s=211043)\n\n补丁包的`key`就是对应新节点有变化的数据位置。\n\n---\n\n## 三、 打补丁更新视图\n\n最后一步将补丁的差异对象与现有虚拟DOM节点遍历进行一一比较与替换。\n\n![开始打补丁](https://user-gold-cdn.xitu.io/2018/11/4/166ddee92a1a76de?w=1098&h=426&f=png&s=61221)\n\n![补丁步骤](https://user-gold-cdn.xitu.io/2018/11/4/166ddeed8a40ba8c?w=1096&h=1094&f=png&s=175704)\n\n根据之前定义的不同补丁对象结构依次处理\n\n![补丁步骤](https://user-gold-cdn.xitu.io/2018/11/4/166ddf0cc87aaa5d?w=1248&h=1138&f=png&s=192351)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166ddf097e341aaf?w=1006&h=1032&f=png&s=120960)\n\n大功告成！\n\n---\n\n这只是diff算法的一个简易实现，还存在一些复杂情况处理的情况以及还有很多算法上面优化的方案，不过已经让我们大概了解了`diff`算法的原理。\n\n如有笔误或者其他实现不对的地方，还望大家指出，谢谢！\n\n具体代码可以参考github链接查看：[dom-diff-demo](https://github.com/Megan-TA/dom-diff-demo)\n","slug":"react-vue中dom-diff简易版实现","published":1,"updated":"2019-07-23T01:57:31.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5n0000oh91pny3y8fge","content":"<h2><span id=\"一-创建虚拟dom\">一、创建虚拟dom</span></h2>\n<p>利用 <code>create-react-app</code>快速创建一个项目模板；</p>\n<p>删掉src下的源文件，替换成 index.js</p>\n<p>首先我们先要用一个对象定义一个虚拟DOM的数据结构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element &#123;</span><br><span class=\"line\">    type: 'ul',</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        class: 'list'</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">        Element&#123;</span><br><span class=\"line\">            type: 'li',</span><br><span class=\"line\">            props: &#123;</span><br><span class=\"line\">                class: 'item'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            children: ['a']</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开始码代码实现虚拟dom的方法实现。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7c8c5aa6083b?w=2956&amp;h=992&amp;f=png&amp;s=271739\" alt=\"'虚拟DOM结构'\"><br>\n浏览器上查看打印的日志信息，如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7ca53ba8fef7?w=1210&amp;h=410&amp;f=png&amp;s=97781\" alt=\"控制台日志\"></p>\n<p>既然虚拟DOM方法已经写好，下一步就要将这个虚拟dom插入到页面中，那我们可以专门写一个渲染真实节点的方法<code>render</code></p>\n<p>先遍历最外层<code>ul</code>的<code>type</code>和<code>props</code>两个属性</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7e8001b419a3?w=2568&amp;h=1244&amp;f=png&amp;s=359336\" alt=\"render\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7e9fddde1a34?w=1078&amp;h=128&amp;f=png&amp;s=25171\" alt=\"控制台日志\"></p>\n<p>注意：<code>input</code>标签的<code>value</code>属性 还有所有标签的<code>style</code>属性</p>\n<p>好了，接下来就是继续遍历<code>children</code>属性，此时<code>children</code>会有两种情况</p>\n<ol>\n<li>如果是文本 直接插入；</li>\n<li>如果是子元素，递归遍历直到最终的结果是文本；</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7f0b58ed9735?w=1036&amp;h=484&amp;f=png&amp;s=95541\" alt=\"遍历虚拟don元素转换为真实dom结构\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7f0d50748a42?w=676&amp;h=198&amp;f=png&amp;s=31439\" alt=\"控制台日志\"></p>\n<p>下一步我们将这个实际的DOM元素结构插入到页面中</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d8078bce16225?w=2988&amp;h=774&amp;f=png&amp;s=270016\" alt=\"append\"><br>\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d805dec820f97?w=1120&amp;h=862&amp;f=png&amp;s=112852\" alt=\"控制台日志\"></p>\n<p>完成第一部分。</p>\n<hr>\n<h2><span id=\"二-实现dom-diff算法\">二、实现dom-diff算法</span></h2>\n<p><code>dom-diff</code>算法就是在两棵抽象语法树的同一位置采用先序的深度遍历算法做比较，同时用补丁的形式记录需要更新的节点位置。</p>\n<p>若<code>type</code>不一致直接替换当前节点以及当前节点下的子节点；<br>\n如果两个父节点一致，则从左往后遍历子节点，若子节点一致，遍历子节点下的子节点，依次递归。</p>\n<p>补丁包的定义规则如下：</p>\n<ol>\n<li>属性不同（type: ‘ATTRS’, attrs）</li>\n<li>新的节点被删除了 （type: ‘REMOVE’, index: xxxx）</li>\n<li>节点类型不同/\b新增 （type: ‘REPLACE’, newNode）</li>\n<li>仅仅是文本变化（type: ‘TEXT’, text）</li>\n</ol>\n<p>新建一个<code>dom-diff.js</code>，专门处理<code>diff</code>算法</p>\n<p>手动调用<code>diff</code>方法（react中\b调用<code>diff</code>算法是在触发<code>setState</code>之后）</p>\n<p>两个虚拟dom结构如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf9046719203?w=1272&amp;h=896&amp;f=png&amp;s=189549\" alt=\"虚拟dom结构\"></p>\n<p>先处理<code>type</code>相同，属性不同的情况。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dca2da79ddd4a?w=1240&amp;h=1688&amp;f=png&amp;s=288100\" alt=\"属性不同\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dca49d1e2ece5?w=1158&amp;h=420&amp;f=png&amp;s=70893\" alt=\"控制台日志\"></p>\n<p>发现控制台已经打印到属性变化的补丁包，最后我们把属性的小补丁包存放到最外层的大补丁包中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 补丁包 存放两个虚拟dom的差异部分</span><br><span class=\"line\">let patchs = &#123;&#125;</span><br><span class=\"line\">// 放到最外层的大补丁包中</span><br><span class=\"line\">if (currentPatchs.length &gt; 0) &#123;</span><br><span class=\"line\">  patchs[index] = currentPatchs</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了 相同类型的父节点一样，在属性比较完成之后，就需要比较<code>children</code>的属性是否有变化<br>\n比较<code>children</code>属性内部元素是否变化，利用递归去遍历</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let globalIndex = 0</span><br><span class=\"line\"></span><br><span class=\"line\">function diffChildren (oldChildrens, newChildrens) &#123;</span><br><span class=\"line\">  oldChildrens.forEach((child, idx) =&gt; &#123;</span><br><span class=\"line\">    walk(child, newChildrens[idx], ++globalIndex)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一开始<code>type</code>类型不相同不需要再去比较，直接用新节点替换老节点即可；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// type不一致</span><br><span class=\"line\">currentPatchs.push(&#123;</span><br><span class=\"line\">  type: TYPES.REPLACE,</span><br><span class=\"line\">  newNode: newTree</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>兼容并处理好各种情况，比如：新节点不存在的情况，新节点增加，新节点类型改变，新节点文本改变以及新节点的属性变化等情况；</p>\n<p>最终拿到所有与旧节点有差异的对象放入patchs这样的一个补丁对象中。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dde85f556609a?w=1432&amp;h=1092&amp;f=png&amp;s=211043\" alt=\"控制台日志\"></p>\n<p>补丁包的<code>key</code>就是对应新节点有变化的数据位置。</p>\n<hr>\n<h2><span id=\"三-打补丁更新视图\">三、 打补丁更新视图</span></h2>\n<p>最后一步将补丁的差异对象与现有虚拟DOM节点遍历进行一一比较与替换。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddee92a1a76de?w=1098&amp;h=426&amp;f=png&amp;s=61221\" alt=\"开始打补丁\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddeed8a40ba8c?w=1096&amp;h=1094&amp;f=png&amp;s=175704\" alt=\"补丁步骤\"></p>\n<p>根据之前定义的不同补丁对象结构依次处理</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf0cc87aaa5d?w=1248&amp;h=1138&amp;f=png&amp;s=192351\" alt=\"补丁步骤\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf097e341aaf?w=1006&amp;h=1032&amp;f=png&amp;s=120960\" alt=\"控制台日志\"></p>\n<p>大功告成！</p>\n<hr>\n<p>这只是diff算法的一个简易实现，还存在一些复杂情况处理的情况以及还有很多算法上面优化的方案，不过已经让我们大概了解了<code>diff</code>算法的原理。</p>\n<p>如有笔误或者其他实现不对的地方，还望大家指出，谢谢！</p>\n<p>具体代码可以参考github链接查看：<a href=\"https://github.com/Megan-TA/dom-diff-demo\" target=\"_blank\" rel=\"noopener\">dom-diff-demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、创建虚拟dom</h2>\n<p>利用 <code>create-react-app</code>快速创建一个项目模板；</p>\n<p>删掉src下的源文件，替换成 index.js</p>\n<p>首先我们先要用一个对象定义一个虚拟DOM的数据结构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element &#123;</span><br><span class=\"line\">    type: 'ul',</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        class: 'list'</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">        Element&#123;</span><br><span class=\"line\">            type: 'li',</span><br><span class=\"line\">            props: &#123;</span><br><span class=\"line\">                class: 'item'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            children: ['a']</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开始码代码实现虚拟dom的方法实现。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7c8c5aa6083b?w=2956&amp;h=992&amp;f=png&amp;s=271739\" alt=\"'虚拟DOM结构'\"><br>\n浏览器上查看打印的日志信息，如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7ca53ba8fef7?w=1210&amp;h=410&amp;f=png&amp;s=97781\" alt=\"控制台日志\"></p>\n<p>既然虚拟DOM方法已经写好，下一步就要将这个虚拟dom插入到页面中，那我们可以专门写一个渲染真实节点的方法<code>render</code></p>\n<p>先遍历最外层<code>ul</code>的<code>type</code>和<code>props</code>两个属性</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7e8001b419a3?w=2568&amp;h=1244&amp;f=png&amp;s=359336\" alt=\"render\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7e9fddde1a34?w=1078&amp;h=128&amp;f=png&amp;s=25171\" alt=\"控制台日志\"></p>\n<p>注意：<code>input</code>标签的<code>value</code>属性 还有所有标签的<code>style</code>属性</p>\n<p>好了，接下来就是继续遍历<code>children</code>属性，此时<code>children</code>会有两种情况</p>\n<ol>\n<li>如果是文本 直接插入；</li>\n<li>如果是子元素，递归遍历直到最终的结果是文本；</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7f0b58ed9735?w=1036&amp;h=484&amp;f=png&amp;s=95541\" alt=\"遍历虚拟don元素转换为真实dom结构\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7f0d50748a42?w=676&amp;h=198&amp;f=png&amp;s=31439\" alt=\"控制台日志\"></p>\n<p>下一步我们将这个实际的DOM元素结构插入到页面中</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d8078bce16225?w=2988&amp;h=774&amp;f=png&amp;s=270016\" alt=\"append\"><br>\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d805dec820f97?w=1120&amp;h=862&amp;f=png&amp;s=112852\" alt=\"控制台日志\"></p>\n<p>完成第一部分。</p>\n<hr>\n<h2>二、实现dom-diff算法</h2>\n<p><code>dom-diff</code>算法就是在两棵抽象语法树的同一位置采用先序的深度遍历算法做比较，同时用补丁的形式记录需要更新的节点位置。</p>\n<p>若<code>type</code>不一致直接替换当前节点以及当前节点下的子节点；<br>\n如果两个父节点一致，则从左往后遍历子节点，若子节点一致，遍历子节点下的子节点，依次递归。</p>\n<p>补丁包的定义规则如下：</p>\n<ol>\n<li>属性不同（type: ‘ATTRS’, attrs）</li>\n<li>新的节点被删除了 （type: ‘REMOVE’, index: xxxx）</li>\n<li>节点类型不同/\b新增 （type: ‘REPLACE’, newNode）</li>\n<li>仅仅是文本变化（type: ‘TEXT’, text）</li>\n</ol>\n<p>新建一个<code>dom-diff.js</code>，专门处理<code>diff</code>算法</p>\n<p>手动调用<code>diff</code>方法（react中\b调用<code>diff</code>算法是在触发<code>setState</code>之后）</p>\n<p>两个虚拟dom结构如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf9046719203?w=1272&amp;h=896&amp;f=png&amp;s=189549\" alt=\"虚拟dom结构\"></p>\n<p>先处理<code>type</code>相同，属性不同的情况。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dca2da79ddd4a?w=1240&amp;h=1688&amp;f=png&amp;s=288100\" alt=\"属性不同\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dca49d1e2ece5?w=1158&amp;h=420&amp;f=png&amp;s=70893\" alt=\"控制台日志\"></p>\n<p>发现控制台已经打印到属性变化的补丁包，最后我们把属性的小补丁包存放到最外层的大补丁包中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 补丁包 存放两个虚拟dom的差异部分</span><br><span class=\"line\">let patchs = &#123;&#125;</span><br><span class=\"line\">// 放到最外层的大补丁包中</span><br><span class=\"line\">if (currentPatchs.length &gt; 0) &#123;</span><br><span class=\"line\">  patchs[index] = currentPatchs</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了 相同类型的父节点一样，在属性比较完成之后，就需要比较<code>children</code>的属性是否有变化<br>\n比较<code>children</code>属性内部元素是否变化，利用递归去遍历</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let globalIndex = 0</span><br><span class=\"line\"></span><br><span class=\"line\">function diffChildren (oldChildrens, newChildrens) &#123;</span><br><span class=\"line\">  oldChildrens.forEach((child, idx) =&gt; &#123;</span><br><span class=\"line\">    walk(child, newChildrens[idx], ++globalIndex)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一开始<code>type</code>类型不相同不需要再去比较，直接用新节点替换老节点即可；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// type不一致</span><br><span class=\"line\">currentPatchs.push(&#123;</span><br><span class=\"line\">  type: TYPES.REPLACE,</span><br><span class=\"line\">  newNode: newTree</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>兼容并处理好各种情况，比如：新节点不存在的情况，新节点增加，新节点类型改变，新节点文本改变以及新节点的属性变化等情况；</p>\n<p>最终拿到所有与旧节点有差异的对象放入patchs这样的一个补丁对象中。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dde85f556609a?w=1432&amp;h=1092&amp;f=png&amp;s=211043\" alt=\"控制台日志\"></p>\n<p>补丁包的<code>key</code>就是对应新节点有变化的数据位置。</p>\n<hr>\n<h2>三、 打补丁更新视图</h2>\n<p>最后一步将补丁的差异对象与现有虚拟DOM节点遍历进行一一比较与替换。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddee92a1a76de?w=1098&amp;h=426&amp;f=png&amp;s=61221\" alt=\"开始打补丁\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddeed8a40ba8c?w=1096&amp;h=1094&amp;f=png&amp;s=175704\" alt=\"补丁步骤\"></p>\n<p>根据之前定义的不同补丁对象结构依次处理</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf0cc87aaa5d?w=1248&amp;h=1138&amp;f=png&amp;s=192351\" alt=\"补丁步骤\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf097e341aaf?w=1006&amp;h=1032&amp;f=png&amp;s=120960\" alt=\"控制台日志\"></p>\n<p>大功告成！</p>\n<hr>\n<p>这只是diff算法的一个简易实现，还存在一些复杂情况处理的情况以及还有很多算法上面优化的方案，不过已经让我们大概了解了<code>diff</code>算法的原理。</p>\n<p>如有笔误或者其他实现不对的地方，还望大家指出，谢谢！</p>\n<p>具体代码可以参考github链接查看：<a href=\"https://github.com/Megan-TA/dom-diff-demo\" target=\"_blank\" rel=\"noopener\">dom-diff-demo</a></p>\n"},{"title":"vue项目接入sentry","catalog":true,"date":"2019-10-11T07:51:00.000Z","subtitle":null,"header-img":null,"_content":"\n首先需要下载官方提供的 sdk，在项目入口处加入进去。\n\n```shell\nyarn add @sentry/browser\nyarn add @sentry/integrations\n```\n\n在应用的入口文件，比如 app.js，加入如下配置：\n\n```javascript\nimport Vue from 'vue'\nimport * as Sentry from '@sentry/browser'\nimport * as Integrations from '@sentry/integrations'\n\nSentry.init({\n\tdsn: 'https://xxxx@sentry.io/1772852',\n\tintegrations: [new Integrations.Vue({ Vue, attachProps: true })]\n})\n```\n\n其中 dsn 是在 sentry 创建的项目的设置中，找到 dsn 的选项 tab，找到项目的默认 dsn\n\n当然如果 application 打包的时候，觉得入口文件体积很大，或者是出于打包速度优化的考虑，可以将 sentry 相关插件通过 cdn 方式引用\n\n```html\n<!-- <script src=\"https://browser.sentry-cdn.com/5.7.1/bundle.es6.min.js\" integrity=\"sha384-h+FyW7fMq0eyUQeRnmnwiWXMxycy0z8n5sOtIH3NJx5GfqxdletL62letiWALtKy\" crossorigin=\"anonymous\"></script> -->\n<script\n\tsrc=\"https://browser.sentry-cdn.com/5.7.1/bundle.min.js\"\n\tintegrity=\"sha384-KMv6bBTABABhv0NI+rVWly6PIRvdippFEgjpKyxUcpEmDWZTkDOiueL5xW+cztZZ\"\n\tcrossorigin=\"anonymous\"\n></script>\n\n<!-- If you include the integration it will be available under Sentry.Integrations.Vue -->\n<script\n\tsrc=\"https://browser.sentry-cdn.com/5.7.1/vue.min.js\"\n\tcrossorigin=\"anonymous\"\n></script>\n```\n\n做完第一步骤之后，此时项目已经具备有异常错误向 sentry 上报日志的功能，如果我们有更精确知道某些异常错误是哪个发布版本带上的，导致相关异常的开发者是谁，还有想要统计某个版本相对于之前的发布版本，错误情况如何等需求，此时需要使用 sentry 提供的 release 功能。\n\n默认接入 release 官方有几种方式，由于我们发布版本并没有走 gitlab、github 等的 ci 流程，我们采用`sentry-cli`提供的全局命令编写脚本去集成到项目发布流程中。\n\n简单的 release 脚本如下：\n\n```shell\n#!/bin/sh\nexport SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\nexport SENTRY_ORG=poizon\n\nPROJECT=\"ticket-platform\"\n\nVERSION=`sentry-cli releases propose-version`\n\n\n# Create a release\nsentry-cli releases -p PROJECT new $VERSION\n\n# upload sourcemap\n# upload-sourcemaps 指定打包后的js文件在项目的路径\n# --url-prefix 外部通过url访问到js静态资源的路径\nsentry-cli releases -p $PROJECT files $VERSION upload-sourcemaps ./dist/js/ --url-prefix ~/js/\n\n```\n\n同时需要在初始化 sentry 的入口出加上版本号（commitid），和后台看到的版本名称要一致，比如当前 git 的 commitid 前 6 为是 123456，需要改成如下设置：\n\n```javascript\nSentry.init({\n\trelease: '123456',\n\tdsn: 'https://xxxx@sentry.io/1772852',\n\tintegrations: [new Integrations.Vue({ Vue, attachProps: true })]\n})\n```\n\n这时候我们在 sentry 后台系统下查看当前项目的的 release 的 tab 下，能看到已经将 sourcemap 文件都上传到 sentry 服务器。默认`sentry-cli`提供的 release 版本号是根据最后一次 git 提交的 commitid，这样会导致我们在查看版本的时候，面对一连串的 commitid，并不能很简单明了的看到当前版本号，所以需要我们手动指定版本号。\n\n1. 通过手动指定版本号\n\n```shell\n#!/bin/sh\nexport SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\nexport SENTRY_ORG=poizon\n\nTAG=\"ticket-platform@2.10.1\"\n\nPROJECT=\"ticket-platform\"\n\nsentry-cli releases -p $PROJECT new $TAG\n\nsentry-cli releases -p $PROJECT files $TAG upload-sourcemaps ./dist/js/ --url-prefix ~/js/\n\n```\n\n初始化的入口处传入的 release 也设置为`ticket-platform@2.10.1`，可以看到这样的方式很繁琐。\n\n2. 通过官方提供的 webpack 插件`@sentry/webpack-plugin`\n\n前提：项目下新建一个`.sentryclirc`文件，写好 sentry 配置项\n\n```\n[defaults]\nurl=https://xxx.xxxx.com\norg=xxx\nproject=ticket-platform\n\n[auth]\ntoken=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\n```\n\n修改项目本身的 webpack 配置\n\n```javascript\nconst SentryCliPlugin = require('@sentry/webpack-plugin');\n\nconst config = {\n  plugins: [\n    new SentryCliPlugin({\n      include: './dist/js',\n      ignore: ['node_modules']\n      urlPrefix: '~/js/'\n    }),\n  ],\n};\n```\n\n可以看到默认提供的插件也是按照 commitid，在我们项目中在构建的过程时流程大概如下：\n\n- 标准的 git coommit（commitizen/cz-cli）\n- 发版前 standard-version 生成本次的版本号\n- 打包时 获取`package.json`的 version 传入`SentryCliPlugin`的配置项`release`\n\n至此 vue 项目完美接入 sentry\n\n参考资料：\n\n1. [sentry 文档接入 vue](https://docs.sentry.io/platforms/javascript/vue/)\n2. [@sentry/webpack-plugin](https://www.npmjs.com/package/@sentry/webpack-plugin)\n3. [Sentry 前端部署拓展篇（sourcemap 关联、issue 关联、release 控制）](https://segmentfault.com/a/1190000014683598#articleHeader5)\n4. [前端日志监控平台 sentry 使用 @sentry/browser @sentry/webpack-plugin](https://juejin.im/post/5bfe0d5be51d4562587b40b9)\n","source":"_posts/vue项目接入sentry.md","raw":"---\ntitle: vue项目接入sentry\ncatalog: true\ndate: 2019-10-11 15:51:00\nsubtitle:\nheader-img:\ntags: 监控\n---\n\n首先需要下载官方提供的 sdk，在项目入口处加入进去。\n\n```shell\nyarn add @sentry/browser\nyarn add @sentry/integrations\n```\n\n在应用的入口文件，比如 app.js，加入如下配置：\n\n```javascript\nimport Vue from 'vue'\nimport * as Sentry from '@sentry/browser'\nimport * as Integrations from '@sentry/integrations'\n\nSentry.init({\n\tdsn: 'https://xxxx@sentry.io/1772852',\n\tintegrations: [new Integrations.Vue({ Vue, attachProps: true })]\n})\n```\n\n其中 dsn 是在 sentry 创建的项目的设置中，找到 dsn 的选项 tab，找到项目的默认 dsn\n\n当然如果 application 打包的时候，觉得入口文件体积很大，或者是出于打包速度优化的考虑，可以将 sentry 相关插件通过 cdn 方式引用\n\n```html\n<!-- <script src=\"https://browser.sentry-cdn.com/5.7.1/bundle.es6.min.js\" integrity=\"sha384-h+FyW7fMq0eyUQeRnmnwiWXMxycy0z8n5sOtIH3NJx5GfqxdletL62letiWALtKy\" crossorigin=\"anonymous\"></script> -->\n<script\n\tsrc=\"https://browser.sentry-cdn.com/5.7.1/bundle.min.js\"\n\tintegrity=\"sha384-KMv6bBTABABhv0NI+rVWly6PIRvdippFEgjpKyxUcpEmDWZTkDOiueL5xW+cztZZ\"\n\tcrossorigin=\"anonymous\"\n></script>\n\n<!-- If you include the integration it will be available under Sentry.Integrations.Vue -->\n<script\n\tsrc=\"https://browser.sentry-cdn.com/5.7.1/vue.min.js\"\n\tcrossorigin=\"anonymous\"\n></script>\n```\n\n做完第一步骤之后，此时项目已经具备有异常错误向 sentry 上报日志的功能，如果我们有更精确知道某些异常错误是哪个发布版本带上的，导致相关异常的开发者是谁，还有想要统计某个版本相对于之前的发布版本，错误情况如何等需求，此时需要使用 sentry 提供的 release 功能。\n\n默认接入 release 官方有几种方式，由于我们发布版本并没有走 gitlab、github 等的 ci 流程，我们采用`sentry-cli`提供的全局命令编写脚本去集成到项目发布流程中。\n\n简单的 release 脚本如下：\n\n```shell\n#!/bin/sh\nexport SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\nexport SENTRY_ORG=poizon\n\nPROJECT=\"ticket-platform\"\n\nVERSION=`sentry-cli releases propose-version`\n\n\n# Create a release\nsentry-cli releases -p PROJECT new $VERSION\n\n# upload sourcemap\n# upload-sourcemaps 指定打包后的js文件在项目的路径\n# --url-prefix 外部通过url访问到js静态资源的路径\nsentry-cli releases -p $PROJECT files $VERSION upload-sourcemaps ./dist/js/ --url-prefix ~/js/\n\n```\n\n同时需要在初始化 sentry 的入口出加上版本号（commitid），和后台看到的版本名称要一致，比如当前 git 的 commitid 前 6 为是 123456，需要改成如下设置：\n\n```javascript\nSentry.init({\n\trelease: '123456',\n\tdsn: 'https://xxxx@sentry.io/1772852',\n\tintegrations: [new Integrations.Vue({ Vue, attachProps: true })]\n})\n```\n\n这时候我们在 sentry 后台系统下查看当前项目的的 release 的 tab 下，能看到已经将 sourcemap 文件都上传到 sentry 服务器。默认`sentry-cli`提供的 release 版本号是根据最后一次 git 提交的 commitid，这样会导致我们在查看版本的时候，面对一连串的 commitid，并不能很简单明了的看到当前版本号，所以需要我们手动指定版本号。\n\n1. 通过手动指定版本号\n\n```shell\n#!/bin/sh\nexport SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\nexport SENTRY_ORG=poizon\n\nTAG=\"ticket-platform@2.10.1\"\n\nPROJECT=\"ticket-platform\"\n\nsentry-cli releases -p $PROJECT new $TAG\n\nsentry-cli releases -p $PROJECT files $TAG upload-sourcemaps ./dist/js/ --url-prefix ~/js/\n\n```\n\n初始化的入口处传入的 release 也设置为`ticket-platform@2.10.1`，可以看到这样的方式很繁琐。\n\n2. 通过官方提供的 webpack 插件`@sentry/webpack-plugin`\n\n前提：项目下新建一个`.sentryclirc`文件，写好 sentry 配置项\n\n```\n[defaults]\nurl=https://xxx.xxxx.com\norg=xxx\nproject=ticket-platform\n\n[auth]\ntoken=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\n```\n\n修改项目本身的 webpack 配置\n\n```javascript\nconst SentryCliPlugin = require('@sentry/webpack-plugin');\n\nconst config = {\n  plugins: [\n    new SentryCliPlugin({\n      include: './dist/js',\n      ignore: ['node_modules']\n      urlPrefix: '~/js/'\n    }),\n  ],\n};\n```\n\n可以看到默认提供的插件也是按照 commitid，在我们项目中在构建的过程时流程大概如下：\n\n- 标准的 git coommit（commitizen/cz-cli）\n- 发版前 standard-version 生成本次的版本号\n- 打包时 获取`package.json`的 version 传入`SentryCliPlugin`的配置项`release`\n\n至此 vue 项目完美接入 sentry\n\n参考资料：\n\n1. [sentry 文档接入 vue](https://docs.sentry.io/platforms/javascript/vue/)\n2. [@sentry/webpack-plugin](https://www.npmjs.com/package/@sentry/webpack-plugin)\n3. [Sentry 前端部署拓展篇（sourcemap 关联、issue 关联、release 控制）](https://segmentfault.com/a/1190000014683598#articleHeader5)\n4. [前端日志监控平台 sentry 使用 @sentry/browser @sentry/webpack-plugin](https://juejin.im/post/5bfe0d5be51d4562587b40b9)\n","slug":"vue项目接入sentry","published":1,"updated":"2019-10-27T09:08:51.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5n0000qh91p5rklyxvl","content":"<p>首先需要下载官方提供的 sdk，在项目入口处加入进去。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add @sentry/browser</span><br><span class=\"line\">yarn add @sentry/integrations</span><br></pre></td></tr></table></figure>\n<p>在应用的入口文件，比如 app.js，加入如下配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Sentry <span class=\"keyword\">from</span> <span class=\"string\">'@sentry/browser'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Integrations <span class=\"keyword\">from</span> <span class=\"string\">'@sentry/integrations'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Sentry.init(&#123;</span><br><span class=\"line\">\tdsn: <span class=\"string\">'https://xxxx@sentry.io/1772852'</span>,</span><br><span class=\"line\">\tintegrations: [<span class=\"keyword\">new</span> Integrations.Vue(&#123; Vue, <span class=\"attr\">attachProps</span>: <span class=\"literal\">true</span> &#125;)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中 dsn 是在 sentry 创建的项目的设置中，找到 dsn 的选项 tab，找到项目的默认 dsn</p>\n<p>当然如果 application 打包的时候，觉得入口文件体积很大，或者是出于打包速度优化的考虑，可以将 sentry 相关插件通过 cdn 方式引用</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;script src=\"https://browser.sentry-cdn.com/5.7.1/bundle.es6.min.js\" integrity=\"sha384-h+FyW7fMq0eyUQeRnmnwiWXMxycy0z8n5sOtIH3NJx5GfqxdletL62letiWALtKy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">src</span>=<span class=\"string\">\"https://browser.sentry-cdn.com/5.7.1/bundle.min.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">integrity</span>=<span class=\"string\">\"sha384-KMv6bBTABABhv0NI+rVWly6PIRvdippFEgjpKyxUcpEmDWZTkDOiueL5xW+cztZZ\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">\"anonymous\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- If you include the integration it will be available under Sentry.Integrations.Vue --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">src</span>=<span class=\"string\">\"https://browser.sentry-cdn.com/5.7.1/vue.min.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">\"anonymous\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>做完第一步骤之后，此时项目已经具备有异常错误向 sentry 上报日志的功能，如果我们有更精确知道某些异常错误是哪个发布版本带上的，导致相关异常的开发者是谁，还有想要统计某个版本相对于之前的发布版本，错误情况如何等需求，此时需要使用 sentry 提供的 release 功能。</p>\n<p>默认接入 release 官方有几种方式，由于我们发布版本并没有走 gitlab、github 等的 ci 流程，我们采用<code>sentry-cli</code>提供的全局命令编写脚本去集成到项目发布流程中。</p>\n<p>简单的 release 脚本如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\">export SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br><span class=\"line\">export SENTRY_ORG=poizon</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT=\"ticket-platform\"</span><br><span class=\"line\"></span><br><span class=\"line\">VERSION=`sentry-cli releases propose-version`</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> Create a release</span><br><span class=\"line\">sentry-cli releases -p PROJECT new $VERSION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> upload sourcemap</span><br><span class=\"line\"><span class=\"meta\">#</span> upload-sourcemaps 指定打包后的js文件在项目的路径</span><br><span class=\"line\"><span class=\"meta\">#</span> --url-prefix 外部通过url访问到js静态资源的路径</span><br><span class=\"line\">sentry-cli releases -p $PROJECT files $VERSION upload-sourcemaps ./dist/js/ --url-prefix ~/js/</span><br></pre></td></tr></table></figure>\n<p>同时需要在初始化 sentry 的入口出加上版本号（commitid），和后台看到的版本名称要一致，比如当前 git 的 commitid 前 6 为是 123456，需要改成如下设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sentry.init(&#123;</span><br><span class=\"line\">\trelease: <span class=\"string\">'123456'</span>,</span><br><span class=\"line\">\tdsn: <span class=\"string\">'https://xxxx@sentry.io/1772852'</span>,</span><br><span class=\"line\">\tintegrations: [<span class=\"keyword\">new</span> Integrations.Vue(&#123; Vue, <span class=\"attr\">attachProps</span>: <span class=\"literal\">true</span> &#125;)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候我们在 sentry 后台系统下查看当前项目的的 release 的 tab 下，能看到已经将 sourcemap 文件都上传到 sentry 服务器。默认<code>sentry-cli</code>提供的 release 版本号是根据最后一次 git 提交的 commitid，这样会导致我们在查看版本的时候，面对一连串的 commitid，并不能很简单明了的看到当前版本号，所以需要我们手动指定版本号。</p>\n<ol>\n<li>通过手动指定版本号</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\">export SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br><span class=\"line\">export SENTRY_ORG=poizon</span><br><span class=\"line\"></span><br><span class=\"line\">TAG=\"ticket-platform@2.10.1\"</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT=\"ticket-platform\"</span><br><span class=\"line\"></span><br><span class=\"line\">sentry-cli releases -p $PROJECT new $TAG</span><br><span class=\"line\"></span><br><span class=\"line\">sentry-cli releases -p $PROJECT files $TAG upload-sourcemaps ./dist/js/ --url-prefix ~/js/</span><br></pre></td></tr></table></figure>\n<p>初始化的入口处传入的 release 也设置为<code>ticket-platform@2.10.1</code>，可以看到这样的方式很繁琐。</p>\n<ol start=\"2\">\n<li>通过官方提供的 webpack 插件<code>@sentry/webpack-plugin</code></li>\n</ol>\n<p>前提：项目下新建一个<code>.sentryclirc</code>文件，写好 sentry 配置项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[defaults]</span><br><span class=\"line\">url=https://xxx.xxxx.com</span><br><span class=\"line\">org=xxx</span><br><span class=\"line\">project=ticket-platform</span><br><span class=\"line\"></span><br><span class=\"line\">[auth]</span><br><span class=\"line\">token=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br></pre></td></tr></table></figure>\n<p>修改项目本身的 webpack 配置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SentryCliPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'@sentry/webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> SentryCliPlugin(&#123;</span><br><span class=\"line\">      include: <span class=\"string\">'./dist/js'</span>,</span><br><span class=\"line\">      ignore: [<span class=\"string\">'node_modules'</span>]</span><br><span class=\"line\">      urlPrefix: <span class=\"string\">'~/js/'</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到默认提供的插件也是按照 commitid，在我们项目中在构建的过程时流程大概如下：</p>\n<ul>\n<li>标准的 git coommit（commitizen/cz-cli）</li>\n<li>发版前 standard-version 生成本次的版本号</li>\n<li>打包时 获取<code>package.json</code>的 version 传入<code>SentryCliPlugin</code>的配置项<code>release</code></li>\n</ul>\n<p>至此 vue 项目完美接入 sentry</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://docs.sentry.io/platforms/javascript/vue/\" target=\"_blank\" rel=\"noopener\">sentry 文档接入 vue</a></li>\n<li><a href=\"https://www.npmjs.com/package/@sentry/webpack-plugin\" target=\"_blank\" rel=\"noopener\">@sentry/webpack-plugin</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000014683598#articleHeader5\" target=\"_blank\" rel=\"noopener\">Sentry 前端部署拓展篇（sourcemap 关联、issue 关联、release 控制）</a></li>\n<li><a href=\"https://juejin.im/post/5bfe0d5be51d4562587b40b9\" target=\"_blank\" rel=\"noopener\">前端日志监控平台 sentry 使用 @sentry/browser @sentry/webpack-plugin</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>首先需要下载官方提供的 sdk，在项目入口处加入进去。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add @sentry/browser</span><br><span class=\"line\">yarn add @sentry/integrations</span><br></pre></td></tr></table></figure>\n<p>在应用的入口文件，比如 app.js，加入如下配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Sentry <span class=\"keyword\">from</span> <span class=\"string\">'@sentry/browser'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Integrations <span class=\"keyword\">from</span> <span class=\"string\">'@sentry/integrations'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Sentry.init(&#123;</span><br><span class=\"line\">\tdsn: <span class=\"string\">'https://xxxx@sentry.io/1772852'</span>,</span><br><span class=\"line\">\tintegrations: [<span class=\"keyword\">new</span> Integrations.Vue(&#123; Vue, <span class=\"attr\">attachProps</span>: <span class=\"literal\">true</span> &#125;)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中 dsn 是在 sentry 创建的项目的设置中，找到 dsn 的选项 tab，找到项目的默认 dsn</p>\n<p>当然如果 application 打包的时候，觉得入口文件体积很大，或者是出于打包速度优化的考虑，可以将 sentry 相关插件通过 cdn 方式引用</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;script src=\"https://browser.sentry-cdn.com/5.7.1/bundle.es6.min.js\" integrity=\"sha384-h+FyW7fMq0eyUQeRnmnwiWXMxycy0z8n5sOtIH3NJx5GfqxdletL62letiWALtKy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">src</span>=<span class=\"string\">\"https://browser.sentry-cdn.com/5.7.1/bundle.min.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">integrity</span>=<span class=\"string\">\"sha384-KMv6bBTABABhv0NI+rVWly6PIRvdippFEgjpKyxUcpEmDWZTkDOiueL5xW+cztZZ\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">\"anonymous\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- If you include the integration it will be available under Sentry.Integrations.Vue --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">src</span>=<span class=\"string\">\"https://browser.sentry-cdn.com/5.7.1/vue.min.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">\"anonymous\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>做完第一步骤之后，此时项目已经具备有异常错误向 sentry 上报日志的功能，如果我们有更精确知道某些异常错误是哪个发布版本带上的，导致相关异常的开发者是谁，还有想要统计某个版本相对于之前的发布版本，错误情况如何等需求，此时需要使用 sentry 提供的 release 功能。</p>\n<p>默认接入 release 官方有几种方式，由于我们发布版本并没有走 gitlab、github 等的 ci 流程，我们采用<code>sentry-cli</code>提供的全局命令编写脚本去集成到项目发布流程中。</p>\n<p>简单的 release 脚本如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\">export SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br><span class=\"line\">export SENTRY_ORG=poizon</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT=\"ticket-platform\"</span><br><span class=\"line\"></span><br><span class=\"line\">VERSION=`sentry-cli releases propose-version`</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> Create a release</span><br><span class=\"line\">sentry-cli releases -p PROJECT new $VERSION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> upload sourcemap</span><br><span class=\"line\"><span class=\"meta\">#</span> upload-sourcemaps 指定打包后的js文件在项目的路径</span><br><span class=\"line\"><span class=\"meta\">#</span> --url-prefix 外部通过url访问到js静态资源的路径</span><br><span class=\"line\">sentry-cli releases -p $PROJECT files $VERSION upload-sourcemaps ./dist/js/ --url-prefix ~/js/</span><br></pre></td></tr></table></figure>\n<p>同时需要在初始化 sentry 的入口出加上版本号（commitid），和后台看到的版本名称要一致，比如当前 git 的 commitid 前 6 为是 123456，需要改成如下设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sentry.init(&#123;</span><br><span class=\"line\">\trelease: <span class=\"string\">'123456'</span>,</span><br><span class=\"line\">\tdsn: <span class=\"string\">'https://xxxx@sentry.io/1772852'</span>,</span><br><span class=\"line\">\tintegrations: [<span class=\"keyword\">new</span> Integrations.Vue(&#123; Vue, <span class=\"attr\">attachProps</span>: <span class=\"literal\">true</span> &#125;)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候我们在 sentry 后台系统下查看当前项目的的 release 的 tab 下，能看到已经将 sourcemap 文件都上传到 sentry 服务器。默认<code>sentry-cli</code>提供的 release 版本号是根据最后一次 git 提交的 commitid，这样会导致我们在查看版本的时候，面对一连串的 commitid，并不能很简单明了的看到当前版本号，所以需要我们手动指定版本号。</p>\n<ol>\n<li>通过手动指定版本号</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\">export SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br><span class=\"line\">export SENTRY_ORG=poizon</span><br><span class=\"line\"></span><br><span class=\"line\">TAG=\"ticket-platform@2.10.1\"</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT=\"ticket-platform\"</span><br><span class=\"line\"></span><br><span class=\"line\">sentry-cli releases -p $PROJECT new $TAG</span><br><span class=\"line\"></span><br><span class=\"line\">sentry-cli releases -p $PROJECT files $TAG upload-sourcemaps ./dist/js/ --url-prefix ~/js/</span><br></pre></td></tr></table></figure>\n<p>初始化的入口处传入的 release 也设置为<code>ticket-platform@2.10.1</code>，可以看到这样的方式很繁琐。</p>\n<ol start=\"2\">\n<li>通过官方提供的 webpack 插件<code>@sentry/webpack-plugin</code></li>\n</ol>\n<p>前提：项目下新建一个<code>.sentryclirc</code>文件，写好 sentry 配置项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[defaults]</span><br><span class=\"line\">url=https://xxx.xxxx.com</span><br><span class=\"line\">org=xxx</span><br><span class=\"line\">project=ticket-platform</span><br><span class=\"line\"></span><br><span class=\"line\">[auth]</span><br><span class=\"line\">token=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br></pre></td></tr></table></figure>\n<p>修改项目本身的 webpack 配置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SentryCliPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'@sentry/webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> SentryCliPlugin(&#123;</span><br><span class=\"line\">      include: <span class=\"string\">'./dist/js'</span>,</span><br><span class=\"line\">      ignore: [<span class=\"string\">'node_modules'</span>]</span><br><span class=\"line\">      urlPrefix: <span class=\"string\">'~/js/'</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到默认提供的插件也是按照 commitid，在我们项目中在构建的过程时流程大概如下：</p>\n<ul>\n<li>标准的 git coommit（commitizen/cz-cli）</li>\n<li>发版前 standard-version 生成本次的版本号</li>\n<li>打包时 获取<code>package.json</code>的 version 传入<code>SentryCliPlugin</code>的配置项<code>release</code></li>\n</ul>\n<p>至此 vue 项目完美接入 sentry</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://docs.sentry.io/platforms/javascript/vue/\" target=\"_blank\" rel=\"noopener\">sentry 文档接入 vue</a></li>\n<li><a href=\"https://www.npmjs.com/package/@sentry/webpack-plugin\" target=\"_blank\" rel=\"noopener\">@sentry/webpack-plugin</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000014683598#articleHeader5\" target=\"_blank\" rel=\"noopener\">Sentry 前端部署拓展篇（sourcemap 关联、issue 关联、release 控制）</a></li>\n<li><a href=\"https://juejin.im/post/5bfe0d5be51d4562587b40b9\" target=\"_blank\" rel=\"noopener\">前端日志监控平台 sentry 使用 @sentry/browser @sentry/webpack-plugin</a></li>\n</ol>\n"},{"title":"一些新的api","catalog":true,"date":"2019-07-22T15:00:47.000Z","subtitle":null,"header-img":null,"_content":"\n1. IntersectionObserver\n\n懒加载实现的一种api，兼容性\n\n参考资料： [谈谈IntersectionObserver懒加载](https://www.jianshu.com/p/84a86e41eb2b)\n","source":"_posts/一些新的api.md","raw":"---\ntitle: 一些新的api\ncatalog: true\ndate: 2019-07-22 23:00:47\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n1. IntersectionObserver\n\n懒加载实现的一种api，兼容性\n\n参考资料： [谈谈IntersectionObserver懒加载](https://www.jianshu.com/p/84a86e41eb2b)\n","slug":"一些新的api","published":1,"updated":"2019-07-23T01:57:31.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5n1000sh91p2n5oonrm","content":"<ol>\n<li>IntersectionObserver</li>\n</ol>\n<p>懒加载实现的一种api，兼容性</p>\n<p>参考资料： <a href=\"https://www.jianshu.com/p/84a86e41eb2b\" target=\"_blank\" rel=\"noopener\">谈谈IntersectionObserver懒加载</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>IntersectionObserver</li>\n</ol>\n<p>懒加载实现的一种api，兼容性</p>\n<p>参考资料： <a href=\"https://www.jianshu.com/p/84a86e41eb2b\" target=\"_blank\" rel=\"noopener\">谈谈IntersectionObserver懒加载</a></p>\n"},{"title":"利用verdaccio搭建私有npm仓库","catalog":true,"date":"2019-06-16T00:25:18.000Z","subtitle":null,"header-img":null,"_content":"\n随着时间的推移，前端的工程日益庞大，越来越复杂的依赖包需要包管理器来维护。相比搭建没有优势bower仓储，更好的方式是在局域网搭建NPM仓储，维护项目中package.json中的各个插件的版本即可维护项目依赖。\n\n[verdaccio]([https://github.com/verdaccio/verdaccio](https://github.com/verdaccio/verdaccio)\n)是一个部署简易的可以实现github仓储私有化的npm组件，fork于`sinopia`项目，由于`sinopia`项目现在不太维护，存在一些bug，不建议使用。\n\n使用verdaccio的优势\n\n- 配置简单，开箱即用；\n- 不需要数据库,verdaccio内置一个数据库了；\n- 当源为verdaccio时, verdaccio不存在要安装的包时,会自动去设置的远程npm把包缓存到本地；\n\n## 1. 安装verdaccio\n\n```javascript\nnpm i verdaccio -g\n```\n\n## 2. 启动verdaccio\n\n- 默认开启方式\n\n ```shell\nverdaccio\n```\n\n启动成功截图\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-ec7bd2397fb9d6bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中`config.yaml`是配置文件，相关配置文件说明如下\n\n```shell\nstorage: ./storage  //npm包存放的路径\n\nauth:\n  htpasswd:\n    file: ./htpasswd   //保存用户的账号密码等信息\n    # Maximum amount of users allowed to register, defaults to \"+inf\".\n    # You can set this to -1 to disable registration.\n    max_users: -1  //默认为1000，改为-1，禁止注册\n\n# a list of other known repositories we can talk to\nuplinks:\n  npmjs:\n    url: http://registry.npm.taobao.org/  //默认为npm的官网，由于国情，改为淘宝源\n\npackages:  //配置权限管理\n  '@*/*':\n    # scoped packages\n    access: $all\n    publish: $authenticated\n\n  '*':\n    # allow all users (including non-authenticated users) to read and\n    # publish all packages\n    #\n    # you can specify usernames/groupnames (depending on your auth plugin)\n    # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\"\n    access: $all  // 所有人都能下载\n\n    # allow all known users to publish packages\n    # (anyone can register by default, remember?)\n    publish: $authenticated // 所有人都有发布包的权限，若想指定默认发布改成对应人的名字\n\n    # if package is not available locally, proxy requests to 'npmjs' registry\n    proxy: npmjs  // 若安装的报在simopia没有，会去配置的npmjs地址去下载\n\n# log settings\nlogs:\n  - {type: stdout, format: pretty, level: http}\n  #- {type: file, path: verdaccio.log, level: info}\n\n# you can specify listen address (or simply a port)\nlisten: 0.0.0.0:4873  // 默认没有，只能在本机访问，添加后可以通过外网访问。\n```\n\n若在服务端部署，需要以守护进程的方式，推荐使用`pm2`去开启\n\n```shell\npm2 start `which verdaccio`\n```\n\npm2启动成功截图\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-dcf94831d7b96096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n## 如何使用\n\n 打开浏览器输入对应的暴露的地址，比如`192.168.0.1:4873`，\n\n截图如下\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-d6ae317646b0afc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照截图提示，注册一个用户\n\n```shell\nnpm adduser --registry http://192.168.0.1:4873\n```\n\n安装提示输入账号，密码\n\n## 更改下载源\n\n在每一个客户端中需要更改下载源为verdaccio，这里推荐使用`nrm`，这是一个包下载源管理器。\n\n```shell\nnpm install -g nrm\n\nnrm add verdaccio http://x.x.x.x:4873/\n\nnrm use verdaccio\n```\n\n## 维护\n\n如果需要发布一个包，需要先进行登录\n\n```shell\nnpm login\n```\n\n登录成功之后，在对应的包文件夹下，改好`package.json`版本号，再执行创建发布命令\n\n```shell\nnpm publish\n```\n","source":"_posts/利用verdaccio搭建私有npm仓库.md","raw":"---\ntitle: 利用verdaccio搭建私有npm仓库\ncatalog: true\ndate: 2019-06-16 08:25:18\nsubtitle: \nheader-img:\ntags: node\n---\n\n随着时间的推移，前端的工程日益庞大，越来越复杂的依赖包需要包管理器来维护。相比搭建没有优势bower仓储，更好的方式是在局域网搭建NPM仓储，维护项目中package.json中的各个插件的版本即可维护项目依赖。\n\n[verdaccio]([https://github.com/verdaccio/verdaccio](https://github.com/verdaccio/verdaccio)\n)是一个部署简易的可以实现github仓储私有化的npm组件，fork于`sinopia`项目，由于`sinopia`项目现在不太维护，存在一些bug，不建议使用。\n\n使用verdaccio的优势\n\n- 配置简单，开箱即用；\n- 不需要数据库,verdaccio内置一个数据库了；\n- 当源为verdaccio时, verdaccio不存在要安装的包时,会自动去设置的远程npm把包缓存到本地；\n\n## 1. 安装verdaccio\n\n```javascript\nnpm i verdaccio -g\n```\n\n## 2. 启动verdaccio\n\n- 默认开启方式\n\n ```shell\nverdaccio\n```\n\n启动成功截图\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-ec7bd2397fb9d6bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中`config.yaml`是配置文件，相关配置文件说明如下\n\n```shell\nstorage: ./storage  //npm包存放的路径\n\nauth:\n  htpasswd:\n    file: ./htpasswd   //保存用户的账号密码等信息\n    # Maximum amount of users allowed to register, defaults to \"+inf\".\n    # You can set this to -1 to disable registration.\n    max_users: -1  //默认为1000，改为-1，禁止注册\n\n# a list of other known repositories we can talk to\nuplinks:\n  npmjs:\n    url: http://registry.npm.taobao.org/  //默认为npm的官网，由于国情，改为淘宝源\n\npackages:  //配置权限管理\n  '@*/*':\n    # scoped packages\n    access: $all\n    publish: $authenticated\n\n  '*':\n    # allow all users (including non-authenticated users) to read and\n    # publish all packages\n    #\n    # you can specify usernames/groupnames (depending on your auth plugin)\n    # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\"\n    access: $all  // 所有人都能下载\n\n    # allow all known users to publish packages\n    # (anyone can register by default, remember?)\n    publish: $authenticated // 所有人都有发布包的权限，若想指定默认发布改成对应人的名字\n\n    # if package is not available locally, proxy requests to 'npmjs' registry\n    proxy: npmjs  // 若安装的报在simopia没有，会去配置的npmjs地址去下载\n\n# log settings\nlogs:\n  - {type: stdout, format: pretty, level: http}\n  #- {type: file, path: verdaccio.log, level: info}\n\n# you can specify listen address (or simply a port)\nlisten: 0.0.0.0:4873  // 默认没有，只能在本机访问，添加后可以通过外网访问。\n```\n\n若在服务端部署，需要以守护进程的方式，推荐使用`pm2`去开启\n\n```shell\npm2 start `which verdaccio`\n```\n\npm2启动成功截图\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-dcf94831d7b96096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n## 如何使用\n\n 打开浏览器输入对应的暴露的地址，比如`192.168.0.1:4873`，\n\n截图如下\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-d6ae317646b0afc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照截图提示，注册一个用户\n\n```shell\nnpm adduser --registry http://192.168.0.1:4873\n```\n\n安装提示输入账号，密码\n\n## 更改下载源\n\n在每一个客户端中需要更改下载源为verdaccio，这里推荐使用`nrm`，这是一个包下载源管理器。\n\n```shell\nnpm install -g nrm\n\nnrm add verdaccio http://x.x.x.x:4873/\n\nnrm use verdaccio\n```\n\n## 维护\n\n如果需要发布一个包，需要先进行登录\n\n```shell\nnpm login\n```\n\n登录成功之后，在对应的包文件夹下，改好`package.json`版本号，再执行创建发布命令\n\n```shell\nnpm publish\n```\n","slug":"利用verdaccio搭建私有npm仓库","published":1,"updated":"2019-07-23T01:57:31.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5n2000uh91psw93899x","content":"<p>随着时间的推移，前端的工程日益庞大，越来越复杂的依赖包需要包管理器来维护。相比搭建没有优势bower仓储，更好的方式是在局域网搭建NPM仓储，维护项目中package.json中的各个插件的版本即可维护项目依赖。</p>\n<p><a href=\"%5Bhttps://github.com/verdaccio/verdaccio%5D(https://github.com/verdaccio/verdaccio)\">verdaccio</a>是一个部署简易的可以实现github仓储私有化的npm组件，fork于<code>sinopia</code>项目，由于<code>sinopia</code>项目现在不太维护，存在一些bug，不建议使用。</p>\n<p>使用verdaccio的优势</p>\n<ul>\n<li>配置简单，开箱即用；</li>\n<li>不需要数据库,verdaccio内置一个数据库了；</li>\n<li>当源为verdaccio时, verdaccio不存在要安装的包时,会自动去设置的远程npm把包缓存到本地；</li>\n</ul>\n<h2><span id=\"1-安装verdaccio\">1. 安装verdaccio</span></h2>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i verdaccio -g</span><br></pre></td></tr></table></figure>\n<h2><span id=\"2-启动verdaccio\">2. 启动verdaccio</span></h2>\n<ul>\n<li>默认开启方式</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">verdaccio</span><br></pre></td></tr></table></figure>\n<p>启动成功截图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-ec7bd2397fb9d6bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>其中<code>config.yaml</code>是配置文件，相关配置文件说明如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storage: ./storage  //npm包存放的路径</span><br><span class=\"line\"></span><br><span class=\"line\">auth:</span><br><span class=\"line\">  htpasswd:</span><br><span class=\"line\">    file: ./htpasswd   //保存用户的账号密码等信息</span><br><span class=\"line\">    # Maximum amount of users allowed to register, defaults to \"+inf\".</span><br><span class=\"line\">    # You can set this to -1 to disable registration.</span><br><span class=\"line\">    max_users: -1  //默认为1000，改为-1，禁止注册</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> a list of other known repositories we can talk to</span><br><span class=\"line\">uplinks:</span><br><span class=\"line\">  npmjs:</span><br><span class=\"line\">    url: http://registry.npm.taobao.org/  //默认为npm的官网，由于国情，改为淘宝源</span><br><span class=\"line\"></span><br><span class=\"line\">packages:  //配置权限管理</span><br><span class=\"line\">  '@*/*':</span><br><span class=\"line\">    # scoped packages</span><br><span class=\"line\">    access: $all</span><br><span class=\"line\">    publish: $authenticated</span><br><span class=\"line\"></span><br><span class=\"line\">  '*':</span><br><span class=\"line\">    # allow all users (including non-authenticated users) to read and</span><br><span class=\"line\">    # publish all packages</span><br><span class=\"line\">    #</span><br><span class=\"line\">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class=\"line\">    # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\"</span><br><span class=\"line\">    access: $all  // 所有人都能下载</span><br><span class=\"line\"></span><br><span class=\"line\">    # allow all known users to publish packages</span><br><span class=\"line\">    # (anyone can register by default, remember?)</span><br><span class=\"line\">    publish: $authenticated // 所有人都有发布包的权限，若想指定默认发布改成对应人的名字</span><br><span class=\"line\"></span><br><span class=\"line\">    # if package is not available locally, proxy requests to 'npmjs' registry</span><br><span class=\"line\">    proxy: npmjs  // 若安装的报在simopia没有，会去配置的npmjs地址去下载</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> log settings</span><br><span class=\"line\">logs:</span><br><span class=\"line\">  - &#123;type: stdout, format: pretty, level: http&#125;</span><br><span class=\"line\"><span class=\"meta\">  #</span>- &#123;type: file, path: verdaccio.log, level: info&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> you can specify listen address (or simply a port)</span><br><span class=\"line\">listen: 0.0.0.0:4873  // 默认没有，只能在本机访问，添加后可以通过外网访问。</span><br></pre></td></tr></table></figure>\n<p>若在服务端部署，需要以守护进程的方式，推荐使用<code>pm2</code>去开启</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start `which verdaccio`</span><br></pre></td></tr></table></figure>\n<p>pm2启动成功截图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-dcf94831d7b96096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<hr>\n<h2><span id=\"如何使用\">如何使用</span></h2>\n<p>打开浏览器输入对应的暴露的地址，比如<code>192.168.0.1:4873</code>，</p>\n<p>截图如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-d6ae317646b0afc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>按照截图提示，注册一个用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm adduser --registry http://192.168.0.1:4873</span><br></pre></td></tr></table></figure>\n<p>安装提示输入账号，密码</p>\n<h2><span id=\"更改下载源\">更改下载源</span></h2>\n<p>在每一个客户端中需要更改下载源为verdaccio，这里推荐使用<code>nrm</code>，这是一个包下载源管理器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g nrm</span><br><span class=\"line\"></span><br><span class=\"line\">nrm add verdaccio http://x.x.x.x:4873/</span><br><span class=\"line\"></span><br><span class=\"line\">nrm use verdaccio</span><br></pre></td></tr></table></figure>\n<h2><span id=\"维护\">维护</span></h2>\n<p>如果需要发布一个包，需要先进行登录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm login</span><br></pre></td></tr></table></figure>\n<p>登录成功之后，在对应的包文件夹下，改好<code>package.json</code>版本号，再执行创建发布命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>随着时间的推移，前端的工程日益庞大，越来越复杂的依赖包需要包管理器来维护。相比搭建没有优势bower仓储，更好的方式是在局域网搭建NPM仓储，维护项目中package.json中的各个插件的版本即可维护项目依赖。</p>\n<p><a href=\"%5Bhttps://github.com/verdaccio/verdaccio%5D(https://github.com/verdaccio/verdaccio)\">verdaccio</a>是一个部署简易的可以实现github仓储私有化的npm组件，fork于<code>sinopia</code>项目，由于<code>sinopia</code>项目现在不太维护，存在一些bug，不建议使用。</p>\n<p>使用verdaccio的优势</p>\n<ul>\n<li>配置简单，开箱即用；</li>\n<li>不需要数据库,verdaccio内置一个数据库了；</li>\n<li>当源为verdaccio时, verdaccio不存在要安装的包时,会自动去设置的远程npm把包缓存到本地；</li>\n</ul>\n<h2>1. 安装verdaccio</h2>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i verdaccio -g</span><br></pre></td></tr></table></figure>\n<h2>2. 启动verdaccio</h2>\n<ul>\n<li>默认开启方式</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">verdaccio</span><br></pre></td></tr></table></figure>\n<p>启动成功截图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-ec7bd2397fb9d6bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>其中<code>config.yaml</code>是配置文件，相关配置文件说明如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storage: ./storage  //npm包存放的路径</span><br><span class=\"line\"></span><br><span class=\"line\">auth:</span><br><span class=\"line\">  htpasswd:</span><br><span class=\"line\">    file: ./htpasswd   //保存用户的账号密码等信息</span><br><span class=\"line\">    # Maximum amount of users allowed to register, defaults to \"+inf\".</span><br><span class=\"line\">    # You can set this to -1 to disable registration.</span><br><span class=\"line\">    max_users: -1  //默认为1000，改为-1，禁止注册</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> a list of other known repositories we can talk to</span><br><span class=\"line\">uplinks:</span><br><span class=\"line\">  npmjs:</span><br><span class=\"line\">    url: http://registry.npm.taobao.org/  //默认为npm的官网，由于国情，改为淘宝源</span><br><span class=\"line\"></span><br><span class=\"line\">packages:  //配置权限管理</span><br><span class=\"line\">  '@*/*':</span><br><span class=\"line\">    # scoped packages</span><br><span class=\"line\">    access: $all</span><br><span class=\"line\">    publish: $authenticated</span><br><span class=\"line\"></span><br><span class=\"line\">  '*':</span><br><span class=\"line\">    # allow all users (including non-authenticated users) to read and</span><br><span class=\"line\">    # publish all packages</span><br><span class=\"line\">    #</span><br><span class=\"line\">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class=\"line\">    # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\"</span><br><span class=\"line\">    access: $all  // 所有人都能下载</span><br><span class=\"line\"></span><br><span class=\"line\">    # allow all known users to publish packages</span><br><span class=\"line\">    # (anyone can register by default, remember?)</span><br><span class=\"line\">    publish: $authenticated // 所有人都有发布包的权限，若想指定默认发布改成对应人的名字</span><br><span class=\"line\"></span><br><span class=\"line\">    # if package is not available locally, proxy requests to 'npmjs' registry</span><br><span class=\"line\">    proxy: npmjs  // 若安装的报在simopia没有，会去配置的npmjs地址去下载</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> log settings</span><br><span class=\"line\">logs:</span><br><span class=\"line\">  - &#123;type: stdout, format: pretty, level: http&#125;</span><br><span class=\"line\"><span class=\"meta\">  #</span>- &#123;type: file, path: verdaccio.log, level: info&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> you can specify listen address (or simply a port)</span><br><span class=\"line\">listen: 0.0.0.0:4873  // 默认没有，只能在本机访问，添加后可以通过外网访问。</span><br></pre></td></tr></table></figure>\n<p>若在服务端部署，需要以守护进程的方式，推荐使用<code>pm2</code>去开启</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start `which verdaccio`</span><br></pre></td></tr></table></figure>\n<p>pm2启动成功截图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-dcf94831d7b96096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<hr>\n<h2>如何使用</h2>\n<p>打开浏览器输入对应的暴露的地址，比如<code>192.168.0.1:4873</code>，</p>\n<p>截图如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-d6ae317646b0afc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>按照截图提示，注册一个用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm adduser --registry http://192.168.0.1:4873</span><br></pre></td></tr></table></figure>\n<p>安装提示输入账号，密码</p>\n<h2>更改下载源</h2>\n<p>在每一个客户端中需要更改下载源为verdaccio，这里推荐使用<code>nrm</code>，这是一个包下载源管理器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g nrm</span><br><span class=\"line\"></span><br><span class=\"line\">nrm add verdaccio http://x.x.x.x:4873/</span><br><span class=\"line\"></span><br><span class=\"line\">nrm use verdaccio</span><br></pre></td></tr></table></figure>\n<h2>维护</h2>\n<p>如果需要发布一个包，需要先进行登录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm login</span><br></pre></td></tr></table></figure>\n<p>登录成功之后，在对应的包文件夹下，改好<code>package.json</code>版本号，再执行创建发布命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n"},{"title":"分享个人vscode常用插件","catalog":true,"date":"2019-06-19T05:39:11.000Z","subtitle":null,"header-img":null,"_content":"\n1. Visual Studio IntelliCode 智能补全\n2. prettier 快速格式化 CMD+Shift+P\n3. Regex Previewer 正则表达式测试\n4. stylelint\n5. vetur # 开发 vue，语法补全、提示助手 （必备插件）\n6. vscode-icons # vscode 图标显示\n7. 小程序助手\n8. vscode-element-helper\n9. SVG Viewer # 预览 SVG\n10. Path Intellisense 路径自动补全\n11. minapp # 小程序开发语法补全、提示助手\n12. markdownlint markdown 语法支持和预览\n13. Live Server\n14. koroFileHeader # 函数注释、文件信息\n15. GitLens # git 辅助工具\n16. javascript code snippets # js 代码提示、补全\n17. Eslint # 代码风格提示\n18. Element UI Snippets\n19. EditorConfig for vs code\n20. Document This\n21. Debugger for Chrome\n22. Color HighLight\n23. CodeIf\n24. Code Runner\n25. Chinese Lanfguage Pack for vs code\n26. Bracket Pair Colorizer 括号以多彩颜色区分\n27. Beautify # 美化代码\n28. Auto Rename Tag # 自动重命名标签\n29. Auto Close Tag # 自动闭合标签\n","source":"_posts/分享个人vscode常用插件.md","raw":"---\ntitle: 分享个人vscode常用插件\ncatalog: true\ndate: 2019-06-19 13:39:11\nsubtitle:\nheader-img:\ntags: IDE\n---\n\n1. Visual Studio IntelliCode 智能补全\n2. prettier 快速格式化 CMD+Shift+P\n3. Regex Previewer 正则表达式测试\n4. stylelint\n5. vetur # 开发 vue，语法补全、提示助手 （必备插件）\n6. vscode-icons # vscode 图标显示\n7. 小程序助手\n8. vscode-element-helper\n9. SVG Viewer # 预览 SVG\n10. Path Intellisense 路径自动补全\n11. minapp # 小程序开发语法补全、提示助手\n12. markdownlint markdown 语法支持和预览\n13. Live Server\n14. koroFileHeader # 函数注释、文件信息\n15. GitLens # git 辅助工具\n16. javascript code snippets # js 代码提示、补全\n17. Eslint # 代码风格提示\n18. Element UI Snippets\n19. EditorConfig for vs code\n20. Document This\n21. Debugger for Chrome\n22. Color HighLight\n23. CodeIf\n24. Code Runner\n25. Chinese Lanfguage Pack for vs code\n26. Bracket Pair Colorizer 括号以多彩颜色区分\n27. Beautify # 美化代码\n28. Auto Rename Tag # 自动重命名标签\n29. Auto Close Tag # 自动闭合标签\n","slug":"分享个人vscode常用插件","published":1,"updated":"2019-07-23T01:57:31.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5n3000vh91pk4ahzwfl","content":"<ol>\n<li>Visual Studio IntelliCode 智能补全</li>\n<li>prettier 快速格式化 CMD+Shift+P</li>\n<li>Regex Previewer 正则表达式测试</li>\n<li>stylelint</li>\n<li>vetur # 开发 vue，语法补全、提示助手 （必备插件）</li>\n<li>vscode-icons # vscode 图标显示</li>\n<li>小程序助手</li>\n<li>vscode-element-helper</li>\n<li>SVG Viewer # 预览 SVG</li>\n<li>Path Intellisense 路径自动补全</li>\n<li>minapp # 小程序开发语法补全、提示助手</li>\n<li>markdownlint markdown 语法支持和预览</li>\n<li>Live Server</li>\n<li>koroFileHeader # 函数注释、文件信息</li>\n<li>GitLens # git 辅助工具</li>\n<li>javascript code snippets # js 代码提示、补全</li>\n<li>Eslint # 代码风格提示</li>\n<li>Element UI Snippets</li>\n<li>EditorConfig for vs code</li>\n<li>Document This</li>\n<li>Debugger for Chrome</li>\n<li>Color HighLight</li>\n<li>CodeIf</li>\n<li>Code Runner</li>\n<li>Chinese Lanfguage Pack for vs code</li>\n<li>Bracket Pair Colorizer 括号以多彩颜色区分</li>\n<li>Beautify # 美化代码</li>\n<li>Auto Rename Tag # 自动重命名标签</li>\n<li>Auto Close Tag # 自动闭合标签</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>Visual Studio IntelliCode 智能补全</li>\n<li>prettier 快速格式化 CMD+Shift+P</li>\n<li>Regex Previewer 正则表达式测试</li>\n<li>stylelint</li>\n<li>vetur # 开发 vue，语法补全、提示助手 （必备插件）</li>\n<li>vscode-icons # vscode 图标显示</li>\n<li>小程序助手</li>\n<li>vscode-element-helper</li>\n<li>SVG Viewer # 预览 SVG</li>\n<li>Path Intellisense 路径自动补全</li>\n<li>minapp # 小程序开发语法补全、提示助手</li>\n<li>markdownlint markdown 语法支持和预览</li>\n<li>Live Server</li>\n<li>koroFileHeader # 函数注释、文件信息</li>\n<li>GitLens # git 辅助工具</li>\n<li>javascript code snippets # js 代码提示、补全</li>\n<li>Eslint # 代码风格提示</li>\n<li>Element UI Snippets</li>\n<li>EditorConfig for vs code</li>\n<li>Document This</li>\n<li>Debugger for Chrome</li>\n<li>Color HighLight</li>\n<li>CodeIf</li>\n<li>Code Runner</li>\n<li>Chinese Lanfguage Pack for vs code</li>\n<li>Bracket Pair Colorizer 括号以多彩颜色区分</li>\n<li>Beautify # 美化代码</li>\n<li>Auto Rename Tag # 自动重命名标签</li>\n<li>Auto Close Tag # 自动闭合标签</li>\n</ol>\n"},{"title":"常用npm包整理","catalog":false,"date":"2019-07-03T01:56:32.000Z","subtitle":null,"header-img":null,"_content":"\n## git 钩子\n\n- husky\n- lint-staged\n\n## 代码风格相关\n\n- commitizen\n- eslint\n- standard-version\n- stylelint\n\n```shell\nnpm install commitizen -g\n\ncommitizen init cz-conventional-changelog --yarn --dev --exact\n\n\nyarn add standard-version -D\n\n```\n\n配置`package.json`\n\n```json\n\n\"scripts\": {\n\"release\": \"standard-version\"\n},\n\"husky\": {\n    \"hooks\": {\n        \"pre-commit\": \"lint-staged\"\n    }\n},\n\"lint-staged\": {\n    \"src/**/*.{js}\": [\n        \"eslint --fix\",\n        \"git add\"\n    ]\n}\n```\n\n参考链接：\n\n1. [commitizen](https://github.com/commitizen/cz-cli)\n\n## tildify\n\n将绝对路径转换为波形路径 比如/Users/sindresorhus/dev → ~/dev\n\n## ora\n\n这个模块用于在终端里有显示载入动画\n\n## download-git-repo\n\n一个用于下载 git 仓库的项目的模块\n\n## inquirer\n\n是一个命令行的回答的模块，你可以自己设定终端的问题，然后对这些回答给出相应的处理\n\n## commander\n\n可以将文字输出到终端当中 多用于提示 根据定义的 bin 的 name 触发对应脚本\n\n## verdaccio\n\n搭建私有 npm 库\n","source":"_posts/常用npm包整理.md","raw":"---\ntitle: 常用npm包整理\ncatalog: false\ndate: 2019-07-03 09:56:32\nsubtitle:\nheader-img:\ntags: npm\n---\n\n## git 钩子\n\n- husky\n- lint-staged\n\n## 代码风格相关\n\n- commitizen\n- eslint\n- standard-version\n- stylelint\n\n```shell\nnpm install commitizen -g\n\ncommitizen init cz-conventional-changelog --yarn --dev --exact\n\n\nyarn add standard-version -D\n\n```\n\n配置`package.json`\n\n```json\n\n\"scripts\": {\n\"release\": \"standard-version\"\n},\n\"husky\": {\n    \"hooks\": {\n        \"pre-commit\": \"lint-staged\"\n    }\n},\n\"lint-staged\": {\n    \"src/**/*.{js}\": [\n        \"eslint --fix\",\n        \"git add\"\n    ]\n}\n```\n\n参考链接：\n\n1. [commitizen](https://github.com/commitizen/cz-cli)\n\n## tildify\n\n将绝对路径转换为波形路径 比如/Users/sindresorhus/dev → ~/dev\n\n## ora\n\n这个模块用于在终端里有显示载入动画\n\n## download-git-repo\n\n一个用于下载 git 仓库的项目的模块\n\n## inquirer\n\n是一个命令行的回答的模块，你可以自己设定终端的问题，然后对这些回答给出相应的处理\n\n## commander\n\n可以将文字输出到终端当中 多用于提示 根据定义的 bin 的 name 触发对应脚本\n\n## verdaccio\n\n搭建私有 npm 库\n","slug":"常用npm包整理","published":1,"updated":"2019-07-31T01:33:13.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5n4000yh91puuadx7kx","content":"<h2><span id=\"git-钩子\">git 钩子</span></h2>\n<ul>\n<li>husky</li>\n<li>lint-staged</li>\n</ul>\n<h2><span id=\"代码风格相关\">代码风格相关</span></h2>\n<ul>\n<li>commitizen</li>\n<li>eslint</li>\n<li>standard-version</li>\n<li>stylelint</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install commitizen -g</span><br><span class=\"line\"></span><br><span class=\"line\">commitizen init cz-conventional-changelog --yarn --dev --exact</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">yarn add standard-version -D</span><br></pre></td></tr></table></figure>\n<p>配置<code>package.json</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">\"release\": \"standard-version\"</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"husky\": &#123;</span><br><span class=\"line\">    \"hooks\": &#123;</span><br><span class=\"line\">        \"pre-commit\": \"lint-staged\"</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"lint-staged\": &#123;</span><br><span class=\"line\">    \"src/**/*.&#123;js&#125;\": [</span><br><span class=\"line\">        \"eslint --fix\",</span><br><span class=\"line\">        <span class=\"string\">\"git add\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://github.com/commitizen/cz-cli\" target=\"_blank\" rel=\"noopener\">commitizen</a></li>\n</ol>\n<h2><span id=\"tildify\">tildify</span></h2>\n<p>将绝对路径转换为波形路径 比如/Users/sindresorhus/dev → ~/dev</p>\n<h2><span id=\"ora\">ora</span></h2>\n<p>这个模块用于在终端里有显示载入动画</p>\n<h2><span id=\"download-git-repo\">download-git-repo</span></h2>\n<p>一个用于下载 git 仓库的项目的模块</p>\n<h2><span id=\"inquirer\">inquirer</span></h2>\n<p>是一个命令行的回答的模块，你可以自己设定终端的问题，然后对这些回答给出相应的处理</p>\n<h2><span id=\"commander\">commander</span></h2>\n<p>可以将文字输出到终端当中 多用于提示 根据定义的 bin 的 name 触发对应脚本</p>\n<h2><span id=\"verdaccio\">verdaccio</span></h2>\n<p>搭建私有 npm 库</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>git 钩子</h2>\n<ul>\n<li>husky</li>\n<li>lint-staged</li>\n</ul>\n<h2>代码风格相关</h2>\n<ul>\n<li>commitizen</li>\n<li>eslint</li>\n<li>standard-version</li>\n<li>stylelint</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install commitizen -g</span><br><span class=\"line\"></span><br><span class=\"line\">commitizen init cz-conventional-changelog --yarn --dev --exact</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">yarn add standard-version -D</span><br></pre></td></tr></table></figure>\n<p>配置<code>package.json</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">\"release\": \"standard-version\"</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"husky\": &#123;</span><br><span class=\"line\">    \"hooks\": &#123;</span><br><span class=\"line\">        \"pre-commit\": \"lint-staged\"</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"lint-staged\": &#123;</span><br><span class=\"line\">    \"src/**/*.&#123;js&#125;\": [</span><br><span class=\"line\">        \"eslint --fix\",</span><br><span class=\"line\">        <span class=\"string\">\"git add\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://github.com/commitizen/cz-cli\" target=\"_blank\" rel=\"noopener\">commitizen</a></li>\n</ol>\n<h2>tildify</h2>\n<p>将绝对路径转换为波形路径 比如/Users/sindresorhus/dev → ~/dev</p>\n<h2>ora</h2>\n<p>这个模块用于在终端里有显示载入动画</p>\n<h2>download-git-repo</h2>\n<p>一个用于下载 git 仓库的项目的模块</p>\n<h2>inquirer</h2>\n<p>是一个命令行的回答的模块，你可以自己设定终端的问题，然后对这些回答给出相应的处理</p>\n<h2>commander</h2>\n<p>可以将文字输出到终端当中 多用于提示 根据定义的 bin 的 name 触发对应脚本</p>\n<h2>verdaccio</h2>\n<p>搭建私有 npm 库</p>\n"},{"title":"前端多项目公共模块管理实践","catalog":false,"date":"2019-06-21T06:12:19.000Z","subtitle":null,"header-img":null,"_content":"\n### 1、背景\n\n由于现在公司业务发展比较迅速，产品数量急剧增多，对应的项目也越来越多，光是前端项目目前就已经拥有几十个项目，目测项目的数量会越来越多，这个时候就需要我们将一些公共模块、方法、组件提取出来单独维护和管理，避免同样功能的代码在各个项目中重复开发、复制粘贴以及不好统一维护的难题。\n\n### 2、调研\n\n参考别的一些开源项目以及现在的一些解决方案，梳理下大概有现在几种解决方案：\n\n1. 搭建私有npm仓库；\n2. git submodule；\n3. 外部脚本SDK形式；\n4. iframe；\n\n其中方案1、2比较符合现在工程化和模块化开发形式；\n\n方案2会将远程代码拉下来，在项目中存在多个node_modules文件夹，优点比较适合前期频繁迭代开发；\n\n方案3存在受到浏览器缓存影响，需要及时更新资源的时候在多项目使用的时候会比较难处理；\n\n方案4存在资源隔离，代码不方便控制以及存在影响性能等问题；\n","source":"_posts/前端多项目公共模块管理实践.md","raw":"---\ntitle: 前端多项目公共模块管理实践\ncatalog: false\ndate: 2019-06-21 14:12:19\nsubtitle:\nheader-img:\ntags: web\n---\n\n### 1、背景\n\n由于现在公司业务发展比较迅速，产品数量急剧增多，对应的项目也越来越多，光是前端项目目前就已经拥有几十个项目，目测项目的数量会越来越多，这个时候就需要我们将一些公共模块、方法、组件提取出来单独维护和管理，避免同样功能的代码在各个项目中重复开发、复制粘贴以及不好统一维护的难题。\n\n### 2、调研\n\n参考别的一些开源项目以及现在的一些解决方案，梳理下大概有现在几种解决方案：\n\n1. 搭建私有npm仓库；\n2. git submodule；\n3. 外部脚本SDK形式；\n4. iframe；\n\n其中方案1、2比较符合现在工程化和模块化开发形式；\n\n方案2会将远程代码拉下来，在项目中存在多个node_modules文件夹，优点比较适合前期频繁迭代开发；\n\n方案3存在受到浏览器缓存影响，需要及时更新资源的时候在多项目使用的时候会比较难处理；\n\n方案4存在资源隔离，代码不方便控制以及存在影响性能等问题；\n","slug":"前端多项目公共模块管理实践","published":1,"updated":"2019-07-23T01:57:31.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5n5000zh91pel55o4s3","content":"<h3><span id=\"1-背景\">1、背景</span></h3>\n<p>由于现在公司业务发展比较迅速，产品数量急剧增多，对应的项目也越来越多，光是前端项目目前就已经拥有几十个项目，目测项目的数量会越来越多，这个时候就需要我们将一些公共模块、方法、组件提取出来单独维护和管理，避免同样功能的代码在各个项目中重复开发、复制粘贴以及不好统一维护的难题。</p>\n<h3><span id=\"2-调研\">2、调研</span></h3>\n<p>参考别的一些开源项目以及现在的一些解决方案，梳理下大概有现在几种解决方案：</p>\n<ol>\n<li>搭建私有npm仓库；</li>\n<li>git submodule；</li>\n<li>外部脚本SDK形式；</li>\n<li>iframe；</li>\n</ol>\n<p>其中方案1、2比较符合现在工程化和模块化开发形式；</p>\n<p>方案2会将远程代码拉下来，在项目中存在多个node_modules文件夹，优点比较适合前期频繁迭代开发；</p>\n<p>方案3存在受到浏览器缓存影响，需要及时更新资源的时候在多项目使用的时候会比较难处理；</p>\n<p>方案4存在资源隔离，代码不方便控制以及存在影响性能等问题；</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>1、背景</h3>\n<p>由于现在公司业务发展比较迅速，产品数量急剧增多，对应的项目也越来越多，光是前端项目目前就已经拥有几十个项目，目测项目的数量会越来越多，这个时候就需要我们将一些公共模块、方法、组件提取出来单独维护和管理，避免同样功能的代码在各个项目中重复开发、复制粘贴以及不好统一维护的难题。</p>\n<h3>2、调研</h3>\n<p>参考别的一些开源项目以及现在的一些解决方案，梳理下大概有现在几种解决方案：</p>\n<ol>\n<li>搭建私有npm仓库；</li>\n<li>git submodule；</li>\n<li>外部脚本SDK形式；</li>\n<li>iframe；</li>\n</ol>\n<p>其中方案1、2比较符合现在工程化和模块化开发形式；</p>\n<p>方案2会将远程代码拉下来，在项目中存在多个node_modules文件夹，优点比较适合前期频繁迭代开发；</p>\n<p>方案3存在受到浏览器缓存影响，需要及时更新资源的时候在多项目使用的时候会比较难处理；</p>\n<p>方案4存在资源隔离，代码不方便控制以及存在影响性能等问题；</p>\n"},{"title":"掉坑记录","catalog":true,"date":"2019-08-28T01:57:42.000Z","subtitle":null,"header-img":null,"_content":"\n1. fetch 的 mode 设置 no-cors 返回的 response 永远都是无效信息\n","source":"_posts/掉坑记录.md","raw":"---\ntitle: 掉坑记录\ncatalog: true\ndate: 2019-08-28 09:57:42\nsubtitle:\nheader-img:\ntags:\n---\n\n1. fetch 的 mode 设置 no-cors 返回的 response 永远都是无效信息\n","slug":"掉坑记录","published":1,"updated":"2019-08-28T07:13:13.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5n70012h91phtbfucdy","content":"<ol>\n<li>fetch 的 mode 设置 no-cors 返回的 response 永远都是无效信息</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>fetch 的 mode 设置 no-cors 返回的 response 永远都是无效信息</li>\n</ol>\n"},{"title":"序","catalog":true,"date":"2019-06-15T06:00:06.000Z","subtitle":null,"header-img":null,"_content":"\nhello，大家好，我是黄晨，来自江苏泰州，前端开发一枚。\n\n搭建这个博客的原因，主要受限于以下几点：\n\n1. 平时学习、积累的知识需要有一个平台去记录，之前也使用了比如掘金、简书、博客园、github这些网站去在线记录，一开始还能满足自己的需求，后来慢慢觉得还是需要有一个自己的博客，提供一种更自由、个性化的编写体验以及阅读体验；\n2. 知识点需要查阅，温故知新，查漏补缺；\n3. 分享自己遇到的一些知识和经验给其他人去参考和借鉴；\n4. 锻炼书写表达能力；\n5. 希望五年、十年以后回头再查阅自己博客的时候会有另一番风味体验；\n\n如果有任何疑问或者问题咨询，欢迎留言向我咨询；\n\n谢谢。\n","source":"_posts/序.md","raw":"---\ntitle: 序\ncatalog: true\ndate: 2019-06-15 14:00:06\nsubtitle:\nheader-img:\ntags: 随笔\n---\n\nhello，大家好，我是黄晨，来自江苏泰州，前端开发一枚。\n\n搭建这个博客的原因，主要受限于以下几点：\n\n1. 平时学习、积累的知识需要有一个平台去记录，之前也使用了比如掘金、简书、博客园、github这些网站去在线记录，一开始还能满足自己的需求，后来慢慢觉得还是需要有一个自己的博客，提供一种更自由、个性化的编写体验以及阅读体验；\n2. 知识点需要查阅，温故知新，查漏补缺；\n3. 分享自己遇到的一些知识和经验给其他人去参考和借鉴；\n4. 锻炼书写表达能力；\n5. 希望五年、十年以后回头再查阅自己博客的时候会有另一番风味体验；\n\n如果有任何疑问或者问题咨询，欢迎留言向我咨询；\n\n谢谢。\n","slug":"序","published":1,"updated":"2019-07-23T01:57:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5n80014h91pnzujcdjr","content":"<p>hello，大家好，我是黄晨，来自江苏泰州，前端开发一枚。</p>\n<p>搭建这个博客的原因，主要受限于以下几点：</p>\n<ol>\n<li>平时学习、积累的知识需要有一个平台去记录，之前也使用了比如掘金、简书、博客园、github这些网站去在线记录，一开始还能满足自己的需求，后来慢慢觉得还是需要有一个自己的博客，提供一种更自由、个性化的编写体验以及阅读体验；</li>\n<li>知识点需要查阅，温故知新，查漏补缺；</li>\n<li>分享自己遇到的一些知识和经验给其他人去参考和借鉴；</li>\n<li>锻炼书写表达能力；</li>\n<li>希望五年、十年以后回头再查阅自己博客的时候会有另一番风味体验；</li>\n</ol>\n<p>如果有任何疑问或者问题咨询，欢迎留言向我咨询；</p>\n<p>谢谢。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>hello，大家好，我是黄晨，来自江苏泰州，前端开发一枚。</p>\n<p>搭建这个博客的原因，主要受限于以下几点：</p>\n<ol>\n<li>平时学习、积累的知识需要有一个平台去记录，之前也使用了比如掘金、简书、博客园、github这些网站去在线记录，一开始还能满足自己的需求，后来慢慢觉得还是需要有一个自己的博客，提供一种更自由、个性化的编写体验以及阅读体验；</li>\n<li>知识点需要查阅，温故知新，查漏补缺；</li>\n<li>分享自己遇到的一些知识和经验给其他人去参考和借鉴；</li>\n<li>锻炼书写表达能力；</li>\n<li>希望五年、十年以后回头再查阅自己博客的时候会有另一番风味体验；</li>\n</ol>\n<p>如果有任何疑问或者问题咨询，欢迎留言向我咨询；</p>\n<p>谢谢。</p>\n"},{"title":"记录typescript使用的几个注意点","catalog":true,"date":"2019-07-22T05:38:34.000Z","subtitle":null,"header-img":null,"_content":"\n近期在做前端团队公共模块和方法的私有 npm 包的时候，采用`typescript`保证包的代码质量，在使用`ts`的过程遇到一些小问题，特此记录下遇到的一些小问题。\n\n1. 不想一个个导入类型文件，希望有全局引用类型文件\n\n一开始在给每个文件定义类型的时候，都会将文件类型放在`types`文件夹下，通过`es6`模块暴露出来并在项目中引入对应的类型文件，开始引用方式如下：\n\n```javascript\n// types/test.d.ts\nexport declare const test = '123'\n\n// src/test.ts\nimport { test } from '../types/test'\n\n```\n\n这样的话默认也是把`.d.ts`文件当做一个模块，但是每次都引入的时候会比较麻烦，有没有更简便的方法，不需要引入类型文件？\n\n答案是有的：利用全局的`namespace`和`tsconfig.json`配置\n\n以下是`tsconfig.json`一些配置项：\n\n```javascript\n{\n    \"compilerOptions\": {\n      \"target\": \"es5\",\n      \"module\": \"commonjs\",\n      \"outDir\": \"./dist/lib\",\n      \"declaration\": true,  // 开启打包之后会输出.d.ts文件\n      \"declarationDir\": \"./dist/types\",  // 默认.d.ts会输出到文件所在目录下，也可以指定.d.ts存放路径\n      \"strict\": true,\n      \"jsx\": \"preserve\",\n      \"importHelpers\": true,\n      \"removeComments\": true,\n      \"moduleResolution\": \"node\",\n      \"experimentalDecorators\": true,\n      \"allowJs\": false,\n      \"esModuleInterop\": true,\n      \"allowSyntheticDefaultImports\": true,\n      \"sourceMap\": false,\n      \"baseUrl\": \".\",\n      \"types\": [\n        \"node\",\n        \"./types\"  // 本地types所在目录，必须在此引入\n      ],\n      \"lib\": [\n        \"esnext\",\n        \"dom\",\n        \"dom.iterable\",\n        \"scripthost\"\n      ]\n    },\n    \"include\": [\n      \"src/**/*.ts\",\n      \"src/**/**/*.ts\"\n    ],\n    \"exclude\": [\n      \"node_modules\"\n    ]\n}\n\n```\n\n注意上面的 types 配置需要将自己定义的`types`文件导入进来，这样一个未知类型会在这个指定范围去查找。\n\n项目代码使用：\n\n```javascript\n//types/test.d.ts\ndeclare namespace Test {\n    interface Detail {\n        name: string\n    }\n}\n\n// src/test.ts\nfunction getTestDetail (detail: Test.Detail){}\n\n```\n\n这样就不需要项目代码去引用类型文件，缺点是暴露全局的`namespace`，需要自己根据情况作出取舍。\n\n2. 定义自定义对象的属性枚举值\n\n定义一个配置对象，除了`key`之外其他属性一样，利用枚举特性定义`key`\n\n```javascript\ndeclare enum ENV {\n  dev = 'dev',\n  prod = 'prod'\n}\n\nexport interface ConfigResult {\n  region: string\n  accessKeyId: string\n  accessKeySecret: string\n  expAfter: number\n  bucket: string\n  maxSize: number\n  startsWith: string\n  ossHost: string\n  host: string\n}\n\nexport interface Config {\n  [key: string]: {\n    [key in ENV]: ConfigResult\n  }\n}\n\n```\n\n3. 类型文件里面不能导出/定义`枚举值`，枚举值需要单独定义在代码层面，不然会报\n\n```shell\nError: Debug Failure. False expression: Output generation failed\n```\n\n4. 开发第三方库的时候遇到，开发完之后库打包之后，在项目中导入相关方法并没有相关方法的提示，别人是怎么定义包内部方法的提示呢？在 github 上查阅了几个库，在`https://github.com/alibaba/pont`这个项目下发现别人`typing`指向的路径指向本身项目暴露出来的 ts 入口文件，这样就达到使用 ts 的时候有对应的方法提示。\n\n```json\n\"main\": \"lib/index.js\",   // 这个是编译后的库入口文件，一般是js\n\"typings\": \"src/index.ts\", // 这个是给ts用的本身项目开发的出口文件\n```\n\n5. 使用`paths`做路径映射时候，一定要当前项目配置文件指定`baseUrl`为当前目录，遇到继承外部项目公共基础配置，公共基础配置设置`baseUrl`之后，`paths`路径映射是以外部项目为基准；\n\n6. `paths`做了映射之后，利用提供的`tsc`编译后的代码并没有做响应的路径转换，比如`$src/index.ts`，最后编译出来的代码依然是原样，后来是采用`rollup.js`做了打包处理这个问题。\n","source":"_posts/记录typescript使用的几个注意点.md","raw":"---\ntitle: 记录typescript使用的几个注意点\ncatalog: true\ndate: 2019-07-22 13:38:34\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n近期在做前端团队公共模块和方法的私有 npm 包的时候，采用`typescript`保证包的代码质量，在使用`ts`的过程遇到一些小问题，特此记录下遇到的一些小问题。\n\n1. 不想一个个导入类型文件，希望有全局引用类型文件\n\n一开始在给每个文件定义类型的时候，都会将文件类型放在`types`文件夹下，通过`es6`模块暴露出来并在项目中引入对应的类型文件，开始引用方式如下：\n\n```javascript\n// types/test.d.ts\nexport declare const test = '123'\n\n// src/test.ts\nimport { test } from '../types/test'\n\n```\n\n这样的话默认也是把`.d.ts`文件当做一个模块，但是每次都引入的时候会比较麻烦，有没有更简便的方法，不需要引入类型文件？\n\n答案是有的：利用全局的`namespace`和`tsconfig.json`配置\n\n以下是`tsconfig.json`一些配置项：\n\n```javascript\n{\n    \"compilerOptions\": {\n      \"target\": \"es5\",\n      \"module\": \"commonjs\",\n      \"outDir\": \"./dist/lib\",\n      \"declaration\": true,  // 开启打包之后会输出.d.ts文件\n      \"declarationDir\": \"./dist/types\",  // 默认.d.ts会输出到文件所在目录下，也可以指定.d.ts存放路径\n      \"strict\": true,\n      \"jsx\": \"preserve\",\n      \"importHelpers\": true,\n      \"removeComments\": true,\n      \"moduleResolution\": \"node\",\n      \"experimentalDecorators\": true,\n      \"allowJs\": false,\n      \"esModuleInterop\": true,\n      \"allowSyntheticDefaultImports\": true,\n      \"sourceMap\": false,\n      \"baseUrl\": \".\",\n      \"types\": [\n        \"node\",\n        \"./types\"  // 本地types所在目录，必须在此引入\n      ],\n      \"lib\": [\n        \"esnext\",\n        \"dom\",\n        \"dom.iterable\",\n        \"scripthost\"\n      ]\n    },\n    \"include\": [\n      \"src/**/*.ts\",\n      \"src/**/**/*.ts\"\n    ],\n    \"exclude\": [\n      \"node_modules\"\n    ]\n}\n\n```\n\n注意上面的 types 配置需要将自己定义的`types`文件导入进来，这样一个未知类型会在这个指定范围去查找。\n\n项目代码使用：\n\n```javascript\n//types/test.d.ts\ndeclare namespace Test {\n    interface Detail {\n        name: string\n    }\n}\n\n// src/test.ts\nfunction getTestDetail (detail: Test.Detail){}\n\n```\n\n这样就不需要项目代码去引用类型文件，缺点是暴露全局的`namespace`，需要自己根据情况作出取舍。\n\n2. 定义自定义对象的属性枚举值\n\n定义一个配置对象，除了`key`之外其他属性一样，利用枚举特性定义`key`\n\n```javascript\ndeclare enum ENV {\n  dev = 'dev',\n  prod = 'prod'\n}\n\nexport interface ConfigResult {\n  region: string\n  accessKeyId: string\n  accessKeySecret: string\n  expAfter: number\n  bucket: string\n  maxSize: number\n  startsWith: string\n  ossHost: string\n  host: string\n}\n\nexport interface Config {\n  [key: string]: {\n    [key in ENV]: ConfigResult\n  }\n}\n\n```\n\n3. 类型文件里面不能导出/定义`枚举值`，枚举值需要单独定义在代码层面，不然会报\n\n```shell\nError: Debug Failure. False expression: Output generation failed\n```\n\n4. 开发第三方库的时候遇到，开发完之后库打包之后，在项目中导入相关方法并没有相关方法的提示，别人是怎么定义包内部方法的提示呢？在 github 上查阅了几个库，在`https://github.com/alibaba/pont`这个项目下发现别人`typing`指向的路径指向本身项目暴露出来的 ts 入口文件，这样就达到使用 ts 的时候有对应的方法提示。\n\n```json\n\"main\": \"lib/index.js\",   // 这个是编译后的库入口文件，一般是js\n\"typings\": \"src/index.ts\", // 这个是给ts用的本身项目开发的出口文件\n```\n\n5. 使用`paths`做路径映射时候，一定要当前项目配置文件指定`baseUrl`为当前目录，遇到继承外部项目公共基础配置，公共基础配置设置`baseUrl`之后，`paths`路径映射是以外部项目为基准；\n\n6. `paths`做了映射之后，利用提供的`tsc`编译后的代码并没有做响应的路径转换，比如`$src/index.ts`，最后编译出来的代码依然是原样，后来是采用`rollup.js`做了打包处理这个问题。\n","slug":"记录typescript使用的几个注意点","published":1,"updated":"2019-09-24T04:22:23.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5na0016h91p4g9m8df0","content":"<p>近期在做前端团队公共模块和方法的私有 npm 包的时候，采用<code>typescript</code>保证包的代码质量，在使用<code>ts</code>的过程遇到一些小问题，特此记录下遇到的一些小问题。</p>\n<ol>\n<li>不想一个个导入类型文件，希望有全局引用类型文件</li>\n</ol>\n<p>一开始在给每个文件定义类型的时候，都会将文件类型放在<code>types</code>文件夹下，通过<code>es6</code>模块暴露出来并在项目中引入对应的类型文件，开始引用方式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// types/test.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> declare <span class=\"keyword\">const</span> test = <span class=\"string\">'123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/test.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; test &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../types/test'</span></span><br></pre></td></tr></table></figure>\n<p>这样的话默认也是把<code>.d.ts</code>文件当做一个模块，但是每次都引入的时候会比较麻烦，有没有更简便的方法，不需要引入类型文件？</p>\n<p>答案是有的：利用全局的<code>namespace</code>和<code>tsconfig.json</code>配置</p>\n<p>以下是<code>tsconfig.json</code>一些配置项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"target\"</span>: <span class=\"string\">\"es5\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"module\"</span>: <span class=\"string\">\"commonjs\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"outDir\"</span>: <span class=\"string\">\"./dist/lib\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"declaration\"</span>: <span class=\"literal\">true</span>,  <span class=\"comment\">// 开启打包之后会输出.d.ts文件</span></span><br><span class=\"line\">      <span class=\"string\">\"declarationDir\"</span>: <span class=\"string\">\"./dist/types\"</span>,  <span class=\"comment\">// 默认.d.ts会输出到文件所在目录下，也可以指定.d.ts存放路径</span></span><br><span class=\"line\">      <span class=\"string\">\"strict\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"jsx\"</span>: <span class=\"string\">\"preserve\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"importHelpers\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"removeComments\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"moduleResolution\"</span>: <span class=\"string\">\"node\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"experimentalDecorators\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"allowJs\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"esModuleInterop\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"allowSyntheticDefaultImports\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"sourceMap\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"baseUrl\"</span>: <span class=\"string\">\".\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"types\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"node\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"./types\"</span>  <span class=\"comment\">// 本地types所在目录，必须在此引入</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"string\">\"lib\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"esnext\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"dom\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"dom.iterable\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"scripthost\"</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"include\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"src/**/*.ts\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"src/**/**/*.ts\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"exclude\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"node_modules\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意上面的 types 配置需要将自己定义的<code>types</code>文件导入进来，这样一个未知类型会在这个指定范围去查找。</p>\n<p>项目代码使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//types/test.d.ts</span></span><br><span class=\"line\">declare namespace Test &#123;</span><br><span class=\"line\">    interface Detail &#123;</span><br><span class=\"line\">        name: string</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/test.ts</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTestDetail</span> (<span class=\"params\">detail: Test.Detail</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就不需要项目代码去引用类型文件，缺点是暴露全局的<code>namespace</code>，需要自己根据情况作出取舍。</p>\n<ol start=\"2\">\n<li>定义自定义对象的属性枚举值</li>\n</ol>\n<p>定义一个配置对象，除了<code>key</code>之外其他属性一样，利用枚举特性定义<code>key</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare enum ENV &#123;</span><br><span class=\"line\">  dev = <span class=\"string\">'dev'</span>,</span><br><span class=\"line\">  prod = <span class=\"string\">'prod'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface ConfigResult &#123;</span><br><span class=\"line\">  region: string</span><br><span class=\"line\">  accessKeyId: string</span><br><span class=\"line\">  accessKeySecret: string</span><br><span class=\"line\">  expAfter: number</span><br><span class=\"line\">  bucket: string</span><br><span class=\"line\">  maxSize: number</span><br><span class=\"line\">  startsWith: string</span><br><span class=\"line\">  ossHost: string</span><br><span class=\"line\">  host: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface Config &#123;</span><br><span class=\"line\">  [key: string]: &#123;</span><br><span class=\"line\">    [key <span class=\"keyword\">in</span> ENV]: ConfigResult</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>类型文件里面不能导出/定义<code>枚举值</code>，枚举值需要单独定义在代码层面，不然会报</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Debug Failure. False expression: Output generation failed</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>开发第三方库的时候遇到，开发完之后库打包之后，在项目中导入相关方法并没有相关方法的提示，别人是怎么定义包内部方法的提示呢？在 github 上查阅了几个库，在<code>https://github.com/alibaba/pont</code>这个项目下发现别人<code>typing</code>指向的路径指向本身项目暴露出来的 ts 入口文件，这样就达到使用 ts 的时候有对应的方法提示。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"main\": \"lib/index.js\",   // 这个是编译后的库入口文件，一般是js</span><br><span class=\"line\">\"typings\": \"src/index.ts\", // 这个是给ts用的本身项目开发的出口文件</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>\n<p>使用<code>paths</code>做路径映射时候，一定要当前项目配置文件指定<code>baseUrl</code>为当前目录，遇到继承外部项目公共基础配置，公共基础配置设置<code>baseUrl</code>之后，<code>paths</code>路径映射是以外部项目为基准；</p>\n</li>\n<li>\n<p><code>paths</code>做了映射之后，利用提供的<code>tsc</code>编译后的代码并没有做响应的路径转换，比如<code>$src/index.ts</code>，最后编译出来的代码依然是原样，后来是采用<code>rollup.js</code>做了打包处理这个问题。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>近期在做前端团队公共模块和方法的私有 npm 包的时候，采用<code>typescript</code>保证包的代码质量，在使用<code>ts</code>的过程遇到一些小问题，特此记录下遇到的一些小问题。</p>\n<ol>\n<li>不想一个个导入类型文件，希望有全局引用类型文件</li>\n</ol>\n<p>一开始在给每个文件定义类型的时候，都会将文件类型放在<code>types</code>文件夹下，通过<code>es6</code>模块暴露出来并在项目中引入对应的类型文件，开始引用方式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// types/test.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> declare <span class=\"keyword\">const</span> test = <span class=\"string\">'123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/test.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; test &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../types/test'</span></span><br></pre></td></tr></table></figure>\n<p>这样的话默认也是把<code>.d.ts</code>文件当做一个模块，但是每次都引入的时候会比较麻烦，有没有更简便的方法，不需要引入类型文件？</p>\n<p>答案是有的：利用全局的<code>namespace</code>和<code>tsconfig.json</code>配置</p>\n<p>以下是<code>tsconfig.json</code>一些配置项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"target\"</span>: <span class=\"string\">\"es5\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"module\"</span>: <span class=\"string\">\"commonjs\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"outDir\"</span>: <span class=\"string\">\"./dist/lib\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"declaration\"</span>: <span class=\"literal\">true</span>,  <span class=\"comment\">// 开启打包之后会输出.d.ts文件</span></span><br><span class=\"line\">      <span class=\"string\">\"declarationDir\"</span>: <span class=\"string\">\"./dist/types\"</span>,  <span class=\"comment\">// 默认.d.ts会输出到文件所在目录下，也可以指定.d.ts存放路径</span></span><br><span class=\"line\">      <span class=\"string\">\"strict\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"jsx\"</span>: <span class=\"string\">\"preserve\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"importHelpers\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"removeComments\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"moduleResolution\"</span>: <span class=\"string\">\"node\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"experimentalDecorators\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"allowJs\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"esModuleInterop\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"allowSyntheticDefaultImports\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"sourceMap\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"baseUrl\"</span>: <span class=\"string\">\".\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"types\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"node\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"./types\"</span>  <span class=\"comment\">// 本地types所在目录，必须在此引入</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"string\">\"lib\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"esnext\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"dom\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"dom.iterable\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"scripthost\"</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"include\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"src/**/*.ts\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"src/**/**/*.ts\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"exclude\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"node_modules\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意上面的 types 配置需要将自己定义的<code>types</code>文件导入进来，这样一个未知类型会在这个指定范围去查找。</p>\n<p>项目代码使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//types/test.d.ts</span></span><br><span class=\"line\">declare namespace Test &#123;</span><br><span class=\"line\">    interface Detail &#123;</span><br><span class=\"line\">        name: string</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/test.ts</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTestDetail</span> (<span class=\"params\">detail: Test.Detail</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就不需要项目代码去引用类型文件，缺点是暴露全局的<code>namespace</code>，需要自己根据情况作出取舍。</p>\n<ol start=\"2\">\n<li>定义自定义对象的属性枚举值</li>\n</ol>\n<p>定义一个配置对象，除了<code>key</code>之外其他属性一样，利用枚举特性定义<code>key</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare enum ENV &#123;</span><br><span class=\"line\">  dev = <span class=\"string\">'dev'</span>,</span><br><span class=\"line\">  prod = <span class=\"string\">'prod'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface ConfigResult &#123;</span><br><span class=\"line\">  region: string</span><br><span class=\"line\">  accessKeyId: string</span><br><span class=\"line\">  accessKeySecret: string</span><br><span class=\"line\">  expAfter: number</span><br><span class=\"line\">  bucket: string</span><br><span class=\"line\">  maxSize: number</span><br><span class=\"line\">  startsWith: string</span><br><span class=\"line\">  ossHost: string</span><br><span class=\"line\">  host: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface Config &#123;</span><br><span class=\"line\">  [key: string]: &#123;</span><br><span class=\"line\">    [key <span class=\"keyword\">in</span> ENV]: ConfigResult</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>类型文件里面不能导出/定义<code>枚举值</code>，枚举值需要单独定义在代码层面，不然会报</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Debug Failure. False expression: Output generation failed</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>开发第三方库的时候遇到，开发完之后库打包之后，在项目中导入相关方法并没有相关方法的提示，别人是怎么定义包内部方法的提示呢？在 github 上查阅了几个库，在<code>https://github.com/alibaba/pont</code>这个项目下发现别人<code>typing</code>指向的路径指向本身项目暴露出来的 ts 入口文件，这样就达到使用 ts 的时候有对应的方法提示。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"main\": \"lib/index.js\",   // 这个是编译后的库入口文件，一般是js</span><br><span class=\"line\">\"typings\": \"src/index.ts\", // 这个是给ts用的本身项目开发的出口文件</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>\n<p>使用<code>paths</code>做路径映射时候，一定要当前项目配置文件指定<code>baseUrl</code>为当前目录，遇到继承外部项目公共基础配置，公共基础配置设置<code>baseUrl</code>之后，<code>paths</code>路径映射是以外部项目为基准；</p>\n</li>\n<li>\n<p><code>paths</code>做了映射之后，利用提供的<code>tsc</code>编译后的代码并没有做响应的路径转换，比如<code>$src/index.ts</code>，最后编译出来的代码依然是原样，后来是采用<code>rollup.js</code>做了打包处理这个问题。</p>\n</li>\n</ol>\n"},{"title":"正则实战","catalog":true,"date":"2019-08-30T06:11:43.000Z","subtitle":null,"header-img":null,"_content":"\n## 10. 正则表达式\n\n> 常用规则\n\n- \\n 回车\n- \\t 制表符\n- \\r 换行符\n- \\s 空格\n- \\u4e00-\\u9fa5 中文\n- \\w 大小写字母\\_数字\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- {n, m} 至少出现 n 次 最多 m 次\n- {n,} 至少 n 次\n- - 任意次\n- - 至少一次\n- {n} 至少 n 次\n- () 分组符号\n- [\\s\\S] 任意字符\n- ^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。\n- 正则的最后位置 , 就代表结束的意思\n\n匹配中文: [\\u4e00-\\u9fa5]\n\n例如：\n\n```\nvar str = '2013-6-7';\nvar re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-\nvar re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-\nvar re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-\n\n--------------------------\nvar str = '2013-6-7';\nvar re = /(\\d+)(-)/g;\n\nstr = str.replace(re,function($0,$1,$2){\n\n    //replace()中如果有子项，\n    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,\n    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )\n    return $1 + '.';  //分别返回2013.   6.\n\n});\n\n```\n\n- [] 表示某个集合中的任意一个\n- [^a] 排除 a\n\n```\n// var re = /\\bclassname\\b/;\n\n// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会\n// 把classname当做一个字符串去匹配。\n\nvar re = new RegExp('\\\\b'+classname+'\\\\b');\n\n// 匹配的时候，classname前面必须是起始或者空格，后面也是。\n\n默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。\n```\n\n---\n\n实战 1\n\n```javascript\n//去掉a标签\na =\n\t'度假：原价购页面<a href=\"jumpType:22,jumplink:273\" style=\"font-size:16px\">sss</a>'\n\n// 其中[\\s\\S]表示任意字符 *? 是一个组合 尽可能匹配少的内容 即不会贪婪匹配到</a>结束\na.replace(/<\\/?a[\\s\\S]*?>/g, '')\n```\n","source":"_posts/正则实战.md","raw":"---\ntitle: 正则实战\ncatalog: true\ndate: 2019-08-30 14:11:43\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n## 10. 正则表达式\n\n> 常用规则\n\n- \\n 回车\n- \\t 制表符\n- \\r 换行符\n- \\s 空格\n- \\u4e00-\\u9fa5 中文\n- \\w 大小写字母\\_数字\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- {n, m} 至少出现 n 次 最多 m 次\n- {n,} 至少 n 次\n- - 任意次\n- - 至少一次\n- {n} 至少 n 次\n- () 分组符号\n- [\\s\\S] 任意字符\n- ^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。\n- 正则的最后位置 , 就代表结束的意思\n\n匹配中文: [\\u4e00-\\u9fa5]\n\n例如：\n\n```\nvar str = '2013-6-7';\nvar re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-\nvar re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-\nvar re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-\n\n--------------------------\nvar str = '2013-6-7';\nvar re = /(\\d+)(-)/g;\n\nstr = str.replace(re,function($0,$1,$2){\n\n    //replace()中如果有子项，\n    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,\n    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )\n    return $1 + '.';  //分别返回2013.   6.\n\n});\n\n```\n\n- [] 表示某个集合中的任意一个\n- [^a] 排除 a\n\n```\n// var re = /\\bclassname\\b/;\n\n// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会\n// 把classname当做一个字符串去匹配。\n\nvar re = new RegExp('\\\\b'+classname+'\\\\b');\n\n// 匹配的时候，classname前面必须是起始或者空格，后面也是。\n\n默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。\n```\n\n---\n\n实战 1\n\n```javascript\n//去掉a标签\na =\n\t'度假：原价购页面<a href=\"jumpType:22,jumplink:273\" style=\"font-size:16px\">sss</a>'\n\n// 其中[\\s\\S]表示任意字符 *? 是一个组合 尽可能匹配少的内容 即不会贪婪匹配到</a>结束\na.replace(/<\\/?a[\\s\\S]*?>/g, '')\n```\n","slug":"正则实战","published":1,"updated":"2019-08-30T06:38:24.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5na0018h91pann1krne","content":"<h2><span id=\"10-正则表达式\">10. 正则表达式</span></h2>\n<blockquote>\n<p>常用规则</p>\n</blockquote>\n<ul>\n<li>\\n 回车</li>\n<li>\\t 制表符</li>\n<li>\\r 换行符</li>\n<li>\\s 空格</li>\n<li>\\u4e00-\\u9fa5 中文</li>\n<li>\\w 大小写字母_数字</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>{n, m} 至少出现 n 次 最多 m 次</li>\n<li>{n,} 至少 n 次</li>\n<li>\n<ul>\n<li>任意次</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>至少一次</li>\n</ul>\n</li>\n<li>{n} 至少 n 次</li>\n<li>() 分组符号</li>\n<li>[\\s\\S] 任意字符</li>\n<li>^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。</li>\n<li>正则的最后位置 , 就代表结束的意思</li>\n</ul>\n<p>匹配中文: [\\u4e00-\\u9fa5]</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-</span><br><span class=\"line\">var re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-</span><br><span class=\"line\">var re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------</span><br><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //replace()中如果有子项，</span><br><span class=\"line\">    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[] 表示某个集合中的任意一个</li>\n<li>[^a] 排除 a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var re = /\\bclassname\\b/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会</span><br><span class=\"line\">// 把classname当做一个字符串去匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">var re = new RegExp(&apos;\\\\b&apos;+classname+&apos;\\\\b&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配的时候，classname前面必须是起始或者空格，后面也是。</span><br><span class=\"line\"></span><br><span class=\"line\">默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</span><br></pre></td></tr></table></figure>\n<hr>\n<p>实战 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//去掉a标签</span></span><br><span class=\"line\">a =</span><br><span class=\"line\">\t<span class=\"string\">'度假：原价购页面&lt;a href=\"jumpType:22,jumplink:273\" style=\"font-size:16px\"&gt;sss&lt;/a&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其中[\\s\\S]表示任意字符 *? 是一个组合 尽可能匹配少的内容 即不会贪婪匹配到&lt;/a&gt;结束</span></span><br><span class=\"line\">a.replace(<span class=\"regexp\">/&lt;\\/?a[\\s\\S]*?&gt;/g</span>, <span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>10. 正则表达式</h2>\n<blockquote>\n<p>常用规则</p>\n</blockquote>\n<ul>\n<li>\\n 回车</li>\n<li>\\t 制表符</li>\n<li>\\r 换行符</li>\n<li>\\s 空格</li>\n<li>\\u4e00-\\u9fa5 中文</li>\n<li>\\w 大小写字母_数字</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>{n, m} 至少出现 n 次 最多 m 次</li>\n<li>{n,} 至少 n 次</li>\n<li>\n<ul>\n<li>任意次</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>至少一次</li>\n</ul>\n</li>\n<li>{n} 至少 n 次</li>\n<li>() 分组符号</li>\n<li>[\\s\\S] 任意字符</li>\n<li>^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。</li>\n<li>正则的最后位置 , 就代表结束的意思</li>\n</ul>\n<p>匹配中文: [\\u4e00-\\u9fa5]</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-</span><br><span class=\"line\">var re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-</span><br><span class=\"line\">var re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------</span><br><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //replace()中如果有子项，</span><br><span class=\"line\">    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[] 表示某个集合中的任意一个</li>\n<li>[^a] 排除 a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var re = /\\bclassname\\b/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会</span><br><span class=\"line\">// 把classname当做一个字符串去匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">var re = new RegExp(&apos;\\\\b&apos;+classname+&apos;\\\\b&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配的时候，classname前面必须是起始或者空格，后面也是。</span><br><span class=\"line\"></span><br><span class=\"line\">默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</span><br></pre></td></tr></table></figure>\n<hr>\n<p>实战 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//去掉a标签</span></span><br><span class=\"line\">a =</span><br><span class=\"line\">\t<span class=\"string\">'度假：原价购页面&lt;a href=\"jumpType:22,jumplink:273\" style=\"font-size:16px\"&gt;sss&lt;/a&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其中[\\s\\S]表示任意字符 *? 是一个组合 尽可能匹配少的内容 即不会贪婪匹配到&lt;/a&gt;结束</span></span><br><span class=\"line\">a.replace(<span class=\"regexp\">/&lt;\\/?a[\\s\\S]*?&gt;/g</span>, <span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"记录一次node爬虫开发","catalog":true,"date":"2019-05-07T14:42:51.000Z","subtitle":null,"header-img":null,"_content":"\n在做一个爬虫开发需求的使用，由于目标网站是动态的，无法直接处理静态资源，这时候想到使用`google`推出的`node`无头浏览器`puppeteer`，借此尝试一下。\n\n因为我当时开发的时候，在`mac`上开发，开发完毕之后需要部署到远程`centos7`的远程服务器上，部署的时候就有个小问题，如何判断系统环境是 mac、window 还是 linux，来决定导出的文件存放的目录。\n\n```javascript\nconst os = require('os')\n//Linux系统上'Linux'\n//macOS 系统上'Darwin'\n//Windows系统上'Windows_NT'\nlet sysType = os.type()\nif (sysType === 'Windows_NT') {\n\tconsole.log(\"It's windows\")\n}\n```\n\n一切开发顺利，在`centos7`上部署的时候，遇到`pupeteer`几个问题：\n\n- 无法下载（需要翻墙）\n- 无法启动（具体解决见参考链接）\n\n参考链接：\n\n1. [centos 安装 puppeteer 启动失败解决处理](<[https://segmentfault.com/a/1190000011382062](https://segmentfault.com/a/1190000011382062)>)\n","source":"_posts/记录一次node爬虫开发.md","raw":"---\ntitle: 记录一次node爬虫开发\ncatalog: true\ndate: 2019-05-07 22:42:51\nsubtitle:\nheader-img:\ntags: node\n---\n\n在做一个爬虫开发需求的使用，由于目标网站是动态的，无法直接处理静态资源，这时候想到使用`google`推出的`node`无头浏览器`puppeteer`，借此尝试一下。\n\n因为我当时开发的时候，在`mac`上开发，开发完毕之后需要部署到远程`centos7`的远程服务器上，部署的时候就有个小问题，如何判断系统环境是 mac、window 还是 linux，来决定导出的文件存放的目录。\n\n```javascript\nconst os = require('os')\n//Linux系统上'Linux'\n//macOS 系统上'Darwin'\n//Windows系统上'Windows_NT'\nlet sysType = os.type()\nif (sysType === 'Windows_NT') {\n\tconsole.log(\"It's windows\")\n}\n```\n\n一切开发顺利，在`centos7`上部署的时候，遇到`pupeteer`几个问题：\n\n- 无法下载（需要翻墙）\n- 无法启动（具体解决见参考链接）\n\n参考链接：\n\n1. [centos 安装 puppeteer 启动失败解决处理](<[https://segmentfault.com/a/1190000011382062](https://segmentfault.com/a/1190000011382062)>)\n","slug":"记录一次node爬虫开发","published":1,"updated":"2019-07-25T14:49:48.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5nc001bh91pm9foc7zm","content":"<p>在做一个爬虫开发需求的使用，由于目标网站是动态的，无法直接处理静态资源，这时候想到使用<code>google</code>推出的<code>node</code>无头浏览器<code>puppeteer</code>，借此尝试一下。</p>\n<p>因为我当时开发的时候，在<code>mac</code>上开发，开发完毕之后需要部署到远程<code>centos7</code>的远程服务器上，部署的时候就有个小问题，如何判断系统环境是 mac、window 还是 linux，来决定导出的文件存放的目录。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> os = <span class=\"built_in\">require</span>(<span class=\"string\">'os'</span>)</span><br><span class=\"line\"><span class=\"comment\">//Linux系统上'Linux'</span></span><br><span class=\"line\"><span class=\"comment\">//macOS 系统上'Darwin'</span></span><br><span class=\"line\"><span class=\"comment\">//Windows系统上'Windows_NT'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sysType = os.type()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sysType === <span class=\"string\">'Windows_NT'</span>) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"It's windows\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一切开发顺利，在<code>centos7</code>上部署的时候，遇到<code>pupeteer</code>几个问题：</p>\n<ul>\n<li>无法下载（需要翻墙）</li>\n<li>无法启动（具体解决见参考链接）</li>\n</ul>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"%5Bhttps://segmentfault.com/a/1190000011382062%5D(https://segmentfault.com/a/1190000011382062)\">centos 安装 puppeteer 启动失败解决处理</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>在做一个爬虫开发需求的使用，由于目标网站是动态的，无法直接处理静态资源，这时候想到使用<code>google</code>推出的<code>node</code>无头浏览器<code>puppeteer</code>，借此尝试一下。</p>\n<p>因为我当时开发的时候，在<code>mac</code>上开发，开发完毕之后需要部署到远程<code>centos7</code>的远程服务器上，部署的时候就有个小问题，如何判断系统环境是 mac、window 还是 linux，来决定导出的文件存放的目录。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> os = <span class=\"built_in\">require</span>(<span class=\"string\">'os'</span>)</span><br><span class=\"line\"><span class=\"comment\">//Linux系统上'Linux'</span></span><br><span class=\"line\"><span class=\"comment\">//macOS 系统上'Darwin'</span></span><br><span class=\"line\"><span class=\"comment\">//Windows系统上'Windows_NT'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sysType = os.type()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sysType === <span class=\"string\">'Windows_NT'</span>) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"It's windows\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一切开发顺利，在<code>centos7</code>上部署的时候，遇到<code>pupeteer</code>几个问题：</p>\n<ul>\n<li>无法下载（需要翻墙）</li>\n<li>无法启动（具体解决见参考链接）</li>\n</ul>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"%5Bhttps://segmentfault.com/a/1190000011382062%5D(https://segmentfault.com/a/1190000011382062)\">centos 安装 puppeteer 启动失败解决处理</a></li>\n</ol>\n"},{"title":"记录工单系统的前端性能优化","catalog":true,"date":"2019-07-22T06:01:38.000Z","subtitle":null,"header-img":null,"_content":"\n","source":"_posts/记录工单系统的前端性能优化.md","raw":"---\ntitle: 记录工单系统的前端性能优化\ncatalog: true\ndate: 2019-07-22 14:01:38\nsubtitle:\nheader-img:\ntags: 前端\n---\n\n","slug":"记录工单系统的前端性能优化","published":1,"updated":"2019-07-23T01:57:31.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5nd001dh91pyttsvep9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"记录平时jenkins使用遇到的问题","catalog":true,"date":"2019-05-21T05:51:07.000Z","subtitle":null,"header-img":null,"_content":"\n1. `gitlab`通过`webhooks`在项目指定的分支 push 之后触发 jekins 自动打包\n\n   - 在 jekins 安装 `gitlab-hook-plugin`和 `gitlab-plugin`插件，安装成功的话会在创建项目的`Build Triggers`构建地方看到一个选项 `Build when a change is pushed to GitLab. GitLab webhook URL`\n\n   ![WechatIMG1.png](https://upload-images.jianshu.io/upload_images/6655013-f765101312bb25b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照如下配置方式在`jekins`里指定`dev-hc`分支触发打包\n\n![WechatIMG2.jpeg](https://upload-images.jianshu.io/upload_images/6655013-16a3ba489550681e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在`gitlab`指定的项目设置`webhooks`，在项目的 url 写上`jekins`的项目 url 以及对应的`token`,完成之后保存下，按下对应的 Test 按钮可以测试下是否返回 200 状态码\n\n![WechatIMG3.png](https://upload-images.jianshu.io/upload_images/6655013-82715e7e25e1f667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![WechatIMG4.png](https://upload-images.jianshu.io/upload_images/6655013-4d8f7dcfa20e6b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. jekins 的时间不正确\n\n打开 【系统管理】->【脚本命令行】运行下面的命令\n\n```shell\nSystem.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')\n```\n\n如果是在 docker 下运行的 jenkins 的话，可能上述还不生效，需要切换到`/etc`目录下\n如果`timezone`\n\n3. jenkins 配置执行的 shell 对接构建参数\n\n比如构建参数有`job`，在 shell 里面对应的参数就为`$job`\n","source":"_posts/记录平时jenkins使用遇到的问题.md","raw":"---\ntitle: 记录平时jenkins使用遇到的问题\ncatalog: true\ndate: 2019-05-21 13:51:07\nsubtitle:\nheader-img:\ntags: jenkins\n---\n\n1. `gitlab`通过`webhooks`在项目指定的分支 push 之后触发 jekins 自动打包\n\n   - 在 jekins 安装 `gitlab-hook-plugin`和 `gitlab-plugin`插件，安装成功的话会在创建项目的`Build Triggers`构建地方看到一个选项 `Build when a change is pushed to GitLab. GitLab webhook URL`\n\n   ![WechatIMG1.png](https://upload-images.jianshu.io/upload_images/6655013-f765101312bb25b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照如下配置方式在`jekins`里指定`dev-hc`分支触发打包\n\n![WechatIMG2.jpeg](https://upload-images.jianshu.io/upload_images/6655013-16a3ba489550681e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在`gitlab`指定的项目设置`webhooks`，在项目的 url 写上`jekins`的项目 url 以及对应的`token`,完成之后保存下，按下对应的 Test 按钮可以测试下是否返回 200 状态码\n\n![WechatIMG3.png](https://upload-images.jianshu.io/upload_images/6655013-82715e7e25e1f667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![WechatIMG4.png](https://upload-images.jianshu.io/upload_images/6655013-4d8f7dcfa20e6b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. jekins 的时间不正确\n\n打开 【系统管理】->【脚本命令行】运行下面的命令\n\n```shell\nSystem.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')\n```\n\n如果是在 docker 下运行的 jenkins 的话，可能上述还不生效，需要切换到`/etc`目录下\n如果`timezone`\n\n3. jenkins 配置执行的 shell 对接构建参数\n\n比如构建参数有`job`，在 shell 里面对应的参数就为`$job`\n","slug":"记录平时jenkins使用遇到的问题","published":1,"updated":"2019-07-25T14:55:00.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5ne001gh91pyjswnw5f","content":"<ol>\n<li>\n<p><code>gitlab</code>通过<code>webhooks</code>在项目指定的分支 push 之后触发 jekins 自动打包</p>\n<ul>\n<li>在 jekins 安装 <code>gitlab-hook-plugin</code>和 <code>gitlab-plugin</code>插件，安装成功的话会在创建项目的<code>Build Triggers</code>构建地方看到一个选项 <code>Build when a change is pushed to GitLab. GitLab webhook URL</code></li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-f765101312bb25b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG1.png\"></p>\n</li>\n</ol>\n<p>按照如下配置方式在<code>jekins</code>里指定<code>dev-hc</code>分支触发打包</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-16a3ba489550681e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG2.jpeg\"></p>\n<p>在<code>gitlab</code>指定的项目设置<code>webhooks</code>，在项目的 url 写上<code>jekins</code>的项目 url 以及对应的<code>token</code>,完成之后保存下，按下对应的 Test 按钮可以测试下是否返回 200 状态码</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-82715e7e25e1f667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG3.png\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-4d8f7dcfa20e6b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG4.png\"></p>\n<ol start=\"2\">\n<li>jekins 的时间不正确</li>\n</ol>\n<p>打开 【系统管理】-&gt;【脚本命令行】运行下面的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')</span><br></pre></td></tr></table></figure>\n<p>如果是在 docker 下运行的 jenkins 的话，可能上述还不生效，需要切换到<code>/etc</code>目录下<br>\n如果<code>timezone</code></p>\n<ol start=\"3\">\n<li>jenkins 配置执行的 shell 对接构建参数</li>\n</ol>\n<p>比如构建参数有<code>job</code>，在 shell 里面对应的参数就为<code>$job</code></p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>\n<p><code>gitlab</code>通过<code>webhooks</code>在项目指定的分支 push 之后触发 jekins 自动打包</p>\n<ul>\n<li>在 jekins 安装 <code>gitlab-hook-plugin</code>和 <code>gitlab-plugin</code>插件，安装成功的话会在创建项目的<code>Build Triggers</code>构建地方看到一个选项 <code>Build when a change is pushed to GitLab. GitLab webhook URL</code></li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-f765101312bb25b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG1.png\"></p>\n</li>\n</ol>\n<p>按照如下配置方式在<code>jekins</code>里指定<code>dev-hc</code>分支触发打包</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-16a3ba489550681e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG2.jpeg\"></p>\n<p>在<code>gitlab</code>指定的项目设置<code>webhooks</code>，在项目的 url 写上<code>jekins</code>的项目 url 以及对应的<code>token</code>,完成之后保存下，按下对应的 Test 按钮可以测试下是否返回 200 状态码</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-82715e7e25e1f667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG3.png\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-4d8f7dcfa20e6b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG4.png\"></p>\n<ol start=\"2\">\n<li>jekins 的时间不正确</li>\n</ol>\n<p>打开 【系统管理】-&gt;【脚本命令行】运行下面的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')</span><br></pre></td></tr></table></figure>\n<p>如果是在 docker 下运行的 jenkins 的话，可能上述还不生效，需要切换到<code>/etc</code>目录下<br>\n如果<code>timezone</code></p>\n<ol start=\"3\">\n<li>jenkins 配置执行的 shell 对接构建参数</li>\n</ol>\n<p>比如构建参数有<code>job</code>，在 shell 里面对应的参数就为<code>$job</code></p>\n"},{"title":"nginx入门","catalog":true,"date":"2019-06-19T05:34:23.000Z","subtitle":null,"header-img":null,"_content":"\n1. 环境\n\n   CENTOS>=7.0,位数 X64 CENTOS 7.2\n\n2. 关闭 iptables\n\n   iptables 命令是 Linux 上常用的防火墙软件\n\n   | 功能           | 命令                                |\n   | :------------- | :---------------------------------- |\n   | 停止防火墙     | systemctl stop firewalld.service    |\n   | 永久关闭防火墙 | systemctl disable firewalld.service |\n\n3. 安装依赖\n\n   ```shell\n   yum  -y install gcc gcc-c++ autoconf pcre pcre-devel make automake\n   yum  -y install wget httpd-tools vim\n   ```\n\n4. 开始安装 nginx\n\n   新建一个文件\n\n   ```shell\n   vi /etc/yum.repos.d/nginx.repo\n   ```\n\n   内容输入如下：\n\n   ```shell\n   [nginx]\n   name=nginx repo\n   baseurl=http://nginx.org/packages/centos/7/$basearch/\n   gpgcheck=0\n   enabled=1\n   ```\n\n   其中 centos/7 根据自己运行环境配置 系统名/版本号\n\n   下载 nginx\n\n   ```shell\n   yum install nginx -y\n   nginx -v\n   nginx -V\n   ```\n\n---\n\n## nginx 常用操作\n\n1. 查看配置文件和目录\n\n   ```shell\n   rpm -ql nginx\n   ```\n\n   相关文件说明：\n\n   | 类型     | 路径                                                                                                                              | 用途                                           |\n   | :------- | :-------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------- |\n   | 配置文件 | /etc/logrotate.d/nginx                                                                                                            | 用于 logrotate 服务的日志切割                  |\n   | 配置文件 | /etc/nginx /etc/nginx/nginx.conf /etc/nginx/conf.d /etc/nginx/conf.d/default.conf                                                 | 主配置文件                                     |\n   | 配置文件 | /etc/nginx/fastcgi_params /etc/nginx/scgi_params /etc/nginx/uwsgi_params                                                          | cgi 配置,fastcgi 配置                          |\n   | 配置文件 | /etc/nginx/koi-utf /etc/nginx/koi-win /etc/nginx/win-utf                                                                          | 编码转换映射转化文件                           |\n   | 配置文件 | /etc/nginx/mime.types                                                                                                             | 设置 http 协议的 Content-Type 与扩展名对应关系 |\n   | 配置文件 | /usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug | 用于配置系统守护进程管理器管理方式             |\n   | 配置文件 | /etc/nginx/modules /usr/lib64/nginx/modules                                                                                       | nginx 模块目录                                 |\n   | 命令     | /usr/share/doc/nginx-1.14.0 /usr/share/doc/nginx-1.14.0/COPYRIGHT                                                                 | nginx 的手册和帮助文件                         |\n   | 目录     | /var/cache/nginx                                                                                                                  | nginx 的缓存目录                               |\n   | 目录     | /var/log/nginx                                                                                                                    | nginx 的日志目录                               |\n\n2. 启动和重新加载以及关闭\n\n   ```shell\n   systemctl restart nginx.service\n   systemctl reload nginx.service\n   systemctl stop nginx.service\n\n   nginx -s reload\n   ```\n\n   如果在启动的时候可能会遇到下列问题：\n\n   1. 端口被占用；\n\n   ```shell\n   Starting nginx: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] still could not bind\n\n   ```\n\n   可以先查看进程，再杀死对应进程\n\n   ```shell\n   netstat -ntpl\n\n   kill 进程号\n   ```\n\n3. 配置 nginx\n\n> /etc/nginx/nginx.conf\n\n查看日志命令 tailf -f log 目录\n\n```shell\n  user  nginx;   设置nginx服务的系统使用用户\n  worker_processes  1;  工作进程数,一般和CPU数量相同\n\n  error_log  /var/log/nginx/error.log warn;   nginx的错误日志\n  pid        /var/run/nginx.pid;   nginx服务启动时的pid\n\n  events {\n      worker_connections  1024;每个进程允许的最大连接数 10000\n  }\n\n  http {\n      include       /etc/nginx/mime.types;//文件后缀和类型类型的对应关系\n      default_type  application/octet-stream;//默认content-type\n\n      log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';  //日志记录格式\n\n      access_log  /var/log/nginx/access.log  main;//默认访问日志 日志格式与log_format main 对应\n\n      sendfile        on;//启用sendfile\n      #tcp_nopush     on;//懒发送 客户端请求数据不会每次都时时相应 让数据塞满一次性发送给客户端（多用于下载、断点 续传）\n      #tcp_nodelay on; // 默认开启 与nopush互斥 提高实时请求响应效率\n\n      keepalive_timeout  65;//超时时间是65秒\n\n      #gzip  on;gzip压缩\n\n      include /etc/nginx/conf.d/*.conf;//包含的子配置文件\n  }\n```\n\n> /etc/default.conf\n\n```shell\n  server {\n      listen       80;\n      # 用域名方式访问的地址\n      server_name  localhost;\n\n      #charset koi8-r; //编码\n      #access_log  /var/log/nginx/host.access.log  main;  //访问日志文件和名称\n\n      # 代理\n      location / {\n          proxy_pass http://localhost:3000\n      }\n\n\n      # 转发请求静态资源（js、css）规则\n      location ~ .*\\.(html|js|css)$ {\n          # CORS\n          add_header Access-Control-Allow-Origin *;\n          add_header Access-Control-Allow-Methods GET,POST,DELETE;\n          add_header Access-Control-Allow-Headers Content-Type;\n          # 默认带上客户端cookie\n          add_header Access-Control-Allow-Credentials true;\n          # 缓存1h\n          expires 1h;\n          # 开启gzip\n          gzip on;\n          # gzip压缩HTTP版本号 一般是1.1\n          gzip_http_version 1.1;\n          # gzip压缩等级 越大压缩率越高 1-9\n          gzip_comp_level 2;\n          # 默认不指定不会缓存css资源 需要指定text/css类型\n          gzip_types application/javascript text/css;\n          # 资源目录\n          root /data/html;\n      }\n\n      # 设置图片请求规则\n      location ~ .*\\.(gif|png|jpg|webp)$ {\n          expires 1h;\n          gzip on;\n          gzip_http_version 1.1;\n          gzip_comp_level 3;\n          gzip_types image/jpeg image/png image/gif image/webp;\n          ## 防盗链\n          ## valid_referers 合法的域名 *.baidu.com\n          ## <meta name=\"referrer\" content=\"never\">\n          valid_referers none blocked xx.xxx.xxx.xx;\n          if ($invalid_referer) {\n              return 403;\n          }\n          # 资源目录\n          root /data/html;\n      }\n\n      location ~ ^/download {\n          # 默认先查找当前目录下的后缀为.gz文件 有直接返回给客户端 不需要再压缩\n          # linux下运行gzip 文件名会生成压缩gz文件\n          # url最直接访问该文件路径就会自动启动下载该资源\n          gzip_static on;\n          tcp_nopush on;\n          root /data/download;\n      }\n\n      location / {\n          root   /usr/share/nginx/html;  //静态文件根目录\n          index  index.html index.htm;  //首页的索引文件\n      }\n\n      #error_page  404              /404.html;  //指定错误页面\n\n      # redirect server error pages to the static page /50x.html\n      # 把后台错误重定向到静态的50x.html页面\n      error_page   500 502 503 504  /50x.html;\n      location = /50x.html {\n          root   /usr/share/nginx/html;\n      }\n\n      # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n      # 把PHP脚本9000端口上监听的FastCGI服务\n      #location ~ \\.php$ {\n      #    root           html;\n      #    fastcgi_pass   127.0.0.1:9000;\n      #    fastcgi_index  index.php;\n      #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n      #    include        fastcgi_params;\n      #}\n\n      # 不允许访问.htaccess文件 只允许指定的ip访问\n      location ~ /\\.ht {\n          allow 127.0.0.1\n          deny  all;\n      }\n  }\n```\n\n> 实现负载均衡\n\n1. 解决高并发、海量数据问题\n2. 配置类型\n\n   1. 轮询（默认） 每个请求按照时间顺序逐一分配不同的后端服务器；\n   2. ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定放一个后端服务器，可以解决 session 的问题；\n   3. weight（加权轮询）指定轮询策略，weight 和访问比率成正比，用于后端服务器性能不均的情况；\n   4. least_conn 最小连接数，哪个连接少就分给谁。\n\n   集群状态：\n\n| 状态         | 描述                                  |\n| :----------- | :------------------------------------ |\n| down         | 不参与负载均衡                        |\n| backup       | 备份的服务器                          |\n| max_fails    | 允许请求失败的次数                    |\n| fail_timeout | 经过 max_fails 失败后，服务暂停的时间 |\n| max_conts    | 限制最大的接收的连接数                |\n\n```shell\n    upstream test1 {\n        ip_hsah;\n        server http://localhost:3000 weight=2;\n        server http://localhost:4000 weight=1;\n        server http://localhost:5000 down;\n    }\n\n    server {\n        # 访问负载均衡构造的集群\n        location / {\n            # 和upstrem的name对应\n            proxy_pass http://test1;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test1.com;\n        location / {\n            proxy_pass http://localhost:3000;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test2.com;\n        location / {\n            proxy_pass http://localhost:4000;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test3.com;\n        location / {\n            proxy_pass http://localhost:5000;\n        }\n    }\n\n```\n\n此时访问`www.test.com`通过代理到访问`www.test1.com`，而访问 test1 的请求被负载均衡按照策略访问 test1 或者 test2\n","source":"_posts/nginx入门.md","raw":"---\ntitle: nginx入门\ncatalog: true\ndate: 2019-06-19 13:34:23\nsubtitle:\nheader-img:\ntags: nginx\n---\n\n1. 环境\n\n   CENTOS>=7.0,位数 X64 CENTOS 7.2\n\n2. 关闭 iptables\n\n   iptables 命令是 Linux 上常用的防火墙软件\n\n   | 功能           | 命令                                |\n   | :------------- | :---------------------------------- |\n   | 停止防火墙     | systemctl stop firewalld.service    |\n   | 永久关闭防火墙 | systemctl disable firewalld.service |\n\n3. 安装依赖\n\n   ```shell\n   yum  -y install gcc gcc-c++ autoconf pcre pcre-devel make automake\n   yum  -y install wget httpd-tools vim\n   ```\n\n4. 开始安装 nginx\n\n   新建一个文件\n\n   ```shell\n   vi /etc/yum.repos.d/nginx.repo\n   ```\n\n   内容输入如下：\n\n   ```shell\n   [nginx]\n   name=nginx repo\n   baseurl=http://nginx.org/packages/centos/7/$basearch/\n   gpgcheck=0\n   enabled=1\n   ```\n\n   其中 centos/7 根据自己运行环境配置 系统名/版本号\n\n   下载 nginx\n\n   ```shell\n   yum install nginx -y\n   nginx -v\n   nginx -V\n   ```\n\n---\n\n## nginx 常用操作\n\n1. 查看配置文件和目录\n\n   ```shell\n   rpm -ql nginx\n   ```\n\n   相关文件说明：\n\n   | 类型     | 路径                                                                                                                              | 用途                                           |\n   | :------- | :-------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------- |\n   | 配置文件 | /etc/logrotate.d/nginx                                                                                                            | 用于 logrotate 服务的日志切割                  |\n   | 配置文件 | /etc/nginx /etc/nginx/nginx.conf /etc/nginx/conf.d /etc/nginx/conf.d/default.conf                                                 | 主配置文件                                     |\n   | 配置文件 | /etc/nginx/fastcgi_params /etc/nginx/scgi_params /etc/nginx/uwsgi_params                                                          | cgi 配置,fastcgi 配置                          |\n   | 配置文件 | /etc/nginx/koi-utf /etc/nginx/koi-win /etc/nginx/win-utf                                                                          | 编码转换映射转化文件                           |\n   | 配置文件 | /etc/nginx/mime.types                                                                                                             | 设置 http 协议的 Content-Type 与扩展名对应关系 |\n   | 配置文件 | /usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug | 用于配置系统守护进程管理器管理方式             |\n   | 配置文件 | /etc/nginx/modules /usr/lib64/nginx/modules                                                                                       | nginx 模块目录                                 |\n   | 命令     | /usr/share/doc/nginx-1.14.0 /usr/share/doc/nginx-1.14.0/COPYRIGHT                                                                 | nginx 的手册和帮助文件                         |\n   | 目录     | /var/cache/nginx                                                                                                                  | nginx 的缓存目录                               |\n   | 目录     | /var/log/nginx                                                                                                                    | nginx 的日志目录                               |\n\n2. 启动和重新加载以及关闭\n\n   ```shell\n   systemctl restart nginx.service\n   systemctl reload nginx.service\n   systemctl stop nginx.service\n\n   nginx -s reload\n   ```\n\n   如果在启动的时候可能会遇到下列问题：\n\n   1. 端口被占用；\n\n   ```shell\n   Starting nginx: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] still could not bind\n\n   ```\n\n   可以先查看进程，再杀死对应进程\n\n   ```shell\n   netstat -ntpl\n\n   kill 进程号\n   ```\n\n3. 配置 nginx\n\n> /etc/nginx/nginx.conf\n\n查看日志命令 tailf -f log 目录\n\n```shell\n  user  nginx;   设置nginx服务的系统使用用户\n  worker_processes  1;  工作进程数,一般和CPU数量相同\n\n  error_log  /var/log/nginx/error.log warn;   nginx的错误日志\n  pid        /var/run/nginx.pid;   nginx服务启动时的pid\n\n  events {\n      worker_connections  1024;每个进程允许的最大连接数 10000\n  }\n\n  http {\n      include       /etc/nginx/mime.types;//文件后缀和类型类型的对应关系\n      default_type  application/octet-stream;//默认content-type\n\n      log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';  //日志记录格式\n\n      access_log  /var/log/nginx/access.log  main;//默认访问日志 日志格式与log_format main 对应\n\n      sendfile        on;//启用sendfile\n      #tcp_nopush     on;//懒发送 客户端请求数据不会每次都时时相应 让数据塞满一次性发送给客户端（多用于下载、断点 续传）\n      #tcp_nodelay on; // 默认开启 与nopush互斥 提高实时请求响应效率\n\n      keepalive_timeout  65;//超时时间是65秒\n\n      #gzip  on;gzip压缩\n\n      include /etc/nginx/conf.d/*.conf;//包含的子配置文件\n  }\n```\n\n> /etc/default.conf\n\n```shell\n  server {\n      listen       80;\n      # 用域名方式访问的地址\n      server_name  localhost;\n\n      #charset koi8-r; //编码\n      #access_log  /var/log/nginx/host.access.log  main;  //访问日志文件和名称\n\n      # 代理\n      location / {\n          proxy_pass http://localhost:3000\n      }\n\n\n      # 转发请求静态资源（js、css）规则\n      location ~ .*\\.(html|js|css)$ {\n          # CORS\n          add_header Access-Control-Allow-Origin *;\n          add_header Access-Control-Allow-Methods GET,POST,DELETE;\n          add_header Access-Control-Allow-Headers Content-Type;\n          # 默认带上客户端cookie\n          add_header Access-Control-Allow-Credentials true;\n          # 缓存1h\n          expires 1h;\n          # 开启gzip\n          gzip on;\n          # gzip压缩HTTP版本号 一般是1.1\n          gzip_http_version 1.1;\n          # gzip压缩等级 越大压缩率越高 1-9\n          gzip_comp_level 2;\n          # 默认不指定不会缓存css资源 需要指定text/css类型\n          gzip_types application/javascript text/css;\n          # 资源目录\n          root /data/html;\n      }\n\n      # 设置图片请求规则\n      location ~ .*\\.(gif|png|jpg|webp)$ {\n          expires 1h;\n          gzip on;\n          gzip_http_version 1.1;\n          gzip_comp_level 3;\n          gzip_types image/jpeg image/png image/gif image/webp;\n          ## 防盗链\n          ## valid_referers 合法的域名 *.baidu.com\n          ## <meta name=\"referrer\" content=\"never\">\n          valid_referers none blocked xx.xxx.xxx.xx;\n          if ($invalid_referer) {\n              return 403;\n          }\n          # 资源目录\n          root /data/html;\n      }\n\n      location ~ ^/download {\n          # 默认先查找当前目录下的后缀为.gz文件 有直接返回给客户端 不需要再压缩\n          # linux下运行gzip 文件名会生成压缩gz文件\n          # url最直接访问该文件路径就会自动启动下载该资源\n          gzip_static on;\n          tcp_nopush on;\n          root /data/download;\n      }\n\n      location / {\n          root   /usr/share/nginx/html;  //静态文件根目录\n          index  index.html index.htm;  //首页的索引文件\n      }\n\n      #error_page  404              /404.html;  //指定错误页面\n\n      # redirect server error pages to the static page /50x.html\n      # 把后台错误重定向到静态的50x.html页面\n      error_page   500 502 503 504  /50x.html;\n      location = /50x.html {\n          root   /usr/share/nginx/html;\n      }\n\n      # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n      # 把PHP脚本9000端口上监听的FastCGI服务\n      #location ~ \\.php$ {\n      #    root           html;\n      #    fastcgi_pass   127.0.0.1:9000;\n      #    fastcgi_index  index.php;\n      #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n      #    include        fastcgi_params;\n      #}\n\n      # 不允许访问.htaccess文件 只允许指定的ip访问\n      location ~ /\\.ht {\n          allow 127.0.0.1\n          deny  all;\n      }\n  }\n```\n\n> 实现负载均衡\n\n1. 解决高并发、海量数据问题\n2. 配置类型\n\n   1. 轮询（默认） 每个请求按照时间顺序逐一分配不同的后端服务器；\n   2. ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定放一个后端服务器，可以解决 session 的问题；\n   3. weight（加权轮询）指定轮询策略，weight 和访问比率成正比，用于后端服务器性能不均的情况；\n   4. least_conn 最小连接数，哪个连接少就分给谁。\n\n   集群状态：\n\n| 状态         | 描述                                  |\n| :----------- | :------------------------------------ |\n| down         | 不参与负载均衡                        |\n| backup       | 备份的服务器                          |\n| max_fails    | 允许请求失败的次数                    |\n| fail_timeout | 经过 max_fails 失败后，服务暂停的时间 |\n| max_conts    | 限制最大的接收的连接数                |\n\n```shell\n    upstream test1 {\n        ip_hsah;\n        server http://localhost:3000 weight=2;\n        server http://localhost:4000 weight=1;\n        server http://localhost:5000 down;\n    }\n\n    server {\n        # 访问负载均衡构造的集群\n        location / {\n            # 和upstrem的name对应\n            proxy_pass http://test1;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test1.com;\n        location / {\n            proxy_pass http://localhost:3000;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test2.com;\n        location / {\n            proxy_pass http://localhost:4000;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test3.com;\n        location / {\n            proxy_pass http://localhost:5000;\n        }\n    }\n\n```\n\n此时访问`www.test.com`通过代理到访问`www.test1.com`，而访问 test1 的请求被负载均衡按照策略访问 test1 或者 test2\n","slug":"nginx入门","published":1,"updated":"2019-08-01T05:38:03.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5nq0020h91p4mesbm48","content":"<ol>\n<li>\n<p>环境</p>\n<p>CENTOS&gt;=7.0,位数 X64 CENTOS 7.2</p>\n</li>\n<li>\n<p>关闭 iptables</p>\n<p>iptables 命令是 Linux 上常用的防火墙软件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">功能</th>\n<th style=\"text-align:left\">命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">停止防火墙</td>\n<td style=\"text-align:left\">systemctl stop firewalld.service</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">永久关闭防火墙</td>\n<td style=\"text-align:left\">systemctl disable firewalld.service</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>安装依赖</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum  -y install gcc gcc-c++ autoconf pcre pcre-devel make automake</span><br><span class=\"line\">yum  -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>开始安装 nginx</p>\n<p>新建一个文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure>\n<p>内容输入如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[nginx]</span><br><span class=\"line\">name=nginx repo</span><br><span class=\"line\">baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">enabled=1</span><br></pre></td></tr></table></figure>\n<p>其中 centos/7 根据自己运行环境配置 系统名/版本号</p>\n<p>下载 nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install nginx -y</span><br><span class=\"line\">nginx -v</span><br><span class=\"line\">nginx -V</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2><span id=\"nginx-常用操作\">nginx 常用操作</span></h2>\n<ol>\n<li>\n<p>查看配置文件和目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ql nginx</span><br></pre></td></tr></table></figure>\n<p>相关文件说明：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">路径</th>\n<th style=\"text-align:left\">用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/logrotate.d/nginx</td>\n<td style=\"text-align:left\">用于 logrotate 服务的日志切割</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx /etc/nginx/nginx.conf /etc/nginx/conf.d /etc/nginx/conf.d/default.conf</td>\n<td style=\"text-align:left\">主配置文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/fastcgi_params /etc/nginx/scgi_params /etc/nginx/uwsgi_params</td>\n<td style=\"text-align:left\">cgi 配置,fastcgi 配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/koi-utf /etc/nginx/koi-win /etc/nginx/win-utf</td>\n<td style=\"text-align:left\">编码转换映射转化文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/mime.types</td>\n<td style=\"text-align:left\">设置 http 协议的 Content-Type 与扩展名对应关系</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug</td>\n<td style=\"text-align:left\">用于配置系统守护进程管理器管理方式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/modules /usr/lib64/nginx/modules</td>\n<td style=\"text-align:left\">nginx 模块目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">命令</td>\n<td style=\"text-align:left\">/usr/share/doc/nginx-1.14.0 /usr/share/doc/nginx-1.14.0/COPYRIGHT</td>\n<td style=\"text-align:left\">nginx 的手册和帮助文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目录</td>\n<td style=\"text-align:left\">/var/cache/nginx</td>\n<td style=\"text-align:left\">nginx 的缓存目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目录</td>\n<td style=\"text-align:left\">/var/log/nginx</td>\n<td style=\"text-align:left\">nginx 的日志目录</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>启动和重新加载以及关闭</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx.service</span><br><span class=\"line\">systemctl reload nginx.service</span><br><span class=\"line\">systemctl stop nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>如果在启动的时候可能会遇到下列问题：</p>\n<ol>\n<li>端口被占用；</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting nginx: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\"></span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] still could not bind</span><br></pre></td></tr></table></figure>\n<p>可以先查看进程，再杀死对应进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntpl</span><br><span class=\"line\"></span><br><span class=\"line\">kill 进程号</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>配置 nginx</p>\n</li>\n</ol>\n<blockquote>\n<p>/etc/nginx/nginx.conf</p>\n</blockquote>\n<p>查看日志命令 tailf -f log 目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user  nginx;   设置nginx服务的系统使用用户</span><br><span class=\"line\">worker_processes  1;  工作进程数,一般和CPU数量相同</span><br><span class=\"line\"></span><br><span class=\"line\">error_log  /var/log/nginx/error.log warn;   nginx的错误日志</span><br><span class=\"line\">pid        /var/run/nginx.pid;   nginx服务启动时的pid</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;每个进程允许的最大连接数 10000</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       /etc/nginx/mime.types;//文件后缀和类型类型的对应关系</span><br><span class=\"line\">    default_type  application/octet-stream;//默认content-type</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '</span><br><span class=\"line\">                    '$status $body_bytes_sent \"$http_referer\" '</span><br><span class=\"line\">                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';  //日志记录格式</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;//默认访问日志 日志格式与log_format main 对应</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;//启用sendfile</span><br><span class=\"line\">    #tcp_nopush     on;//懒发送 客户端请求数据不会每次都时时相应 让数据塞满一次性发送给客户端（多用于下载、断点 续传）</span><br><span class=\"line\">    #tcp_nodelay on; // 默认开启 与nopush互斥 提高实时请求响应效率</span><br><span class=\"line\"></span><br><span class=\"line\">    keepalive_timeout  65;//超时时间是65秒</span><br><span class=\"line\"></span><br><span class=\"line\">    #gzip  on;gzip压缩</span><br><span class=\"line\"></span><br><span class=\"line\">    include /etc/nginx/conf.d/*.conf;//包含的子配置文件</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>/etc/default.conf</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    # 用域名方式访问的地址</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    #charset koi8-r; //编码</span><br><span class=\"line\">    #access_log  /var/log/nginx/host.access.log  main;  //访问日志文件和名称</span><br><span class=\"line\"></span><br><span class=\"line\">    # 代理</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:3000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    # 转发请求静态资源（js、css）规则</span><br><span class=\"line\">    location ~ .*\\.(html|js|css)$ &#123;</span><br><span class=\"line\">        # CORS</span><br><span class=\"line\">        add_header Access-Control-Allow-Origin *;</span><br><span class=\"line\">        add_header Access-Control-Allow-Methods GET,POST,DELETE;</span><br><span class=\"line\">        add_header Access-Control-Allow-Headers Content-Type;</span><br><span class=\"line\">        # 默认带上客户端cookie</span><br><span class=\"line\">        add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">        # 缓存1h</span><br><span class=\"line\">        expires 1h;</span><br><span class=\"line\">        # 开启gzip</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        # gzip压缩HTTP版本号 一般是1.1</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        # gzip压缩等级 越大压缩率越高 1-9</span><br><span class=\"line\">        gzip_comp_level 2;</span><br><span class=\"line\">        # 默认不指定不会缓存css资源 需要指定text/css类型</span><br><span class=\"line\">        gzip_types application/javascript text/css;</span><br><span class=\"line\">        # 资源目录</span><br><span class=\"line\">        root /data/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置图片请求规则</span><br><span class=\"line\">    location ~ .*\\.(gif|png|jpg|webp)$ &#123;</span><br><span class=\"line\">        expires 1h;</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        gzip_comp_level 3;</span><br><span class=\"line\">        gzip_types image/jpeg image/png image/gif image/webp;</span><br><span class=\"line\">        ## 防盗链</span><br><span class=\"line\">        ## valid_referers 合法的域名 *.baidu.com</span><br><span class=\"line\">        ## &lt;meta name=\"referrer\" content=\"never\"&gt;</span><br><span class=\"line\">        valid_referers none blocked xx.xxx.xxx.xx;</span><br><span class=\"line\">        if ($invalid_referer) &#123;</span><br><span class=\"line\">            return 403;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        # 资源目录</span><br><span class=\"line\">        root /data/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ ^/download &#123;</span><br><span class=\"line\">        # 默认先查找当前目录下的后缀为.gz文件 有直接返回给客户端 不需要再压缩</span><br><span class=\"line\">        # linux下运行gzip 文件名会生成压缩gz文件</span><br><span class=\"line\">        # url最直接访问该文件路径就会自动启动下载该资源</span><br><span class=\"line\">        gzip_static on;</span><br><span class=\"line\">        tcp_nopush on;</span><br><span class=\"line\">        root /data/download;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   /usr/share/nginx/html;  //静态文件根目录</span><br><span class=\"line\">        index  index.html index.htm;  //首页的索引文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #error_page  404              /404.html;  //指定错误页面</span><br><span class=\"line\"></span><br><span class=\"line\">    # redirect server error pages to the static page /50x.html</span><br><span class=\"line\">    # 把后台错误重定向到静态的50x.html页面</span><br><span class=\"line\">    error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">    location = /50x.html &#123;</span><br><span class=\"line\">        root   /usr/share/nginx/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">    # 把PHP脚本9000端口上监听的FastCGI服务</span><br><span class=\"line\">    #location ~ \\.php$ &#123;</span><br><span class=\"line\">    #    root           html;</span><br><span class=\"line\">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">    #    fastcgi_index  index.php;</span><br><span class=\"line\">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class=\"line\">    #    include        fastcgi_params;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 不允许访问.htaccess文件 只允许指定的ip访问</span><br><span class=\"line\">    location ~ /\\.ht &#123;</span><br><span class=\"line\">        allow 127.0.0.1</span><br><span class=\"line\">        deny  all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>实现负载均衡</p>\n</blockquote>\n<ol>\n<li>\n<p>解决高并发、海量数据问题</p>\n</li>\n<li>\n<p>配置类型</p>\n<ol>\n<li>轮询（默认） 每个请求按照时间顺序逐一分配不同的后端服务器；</li>\n<li>ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定放一个后端服务器，可以解决 session 的问题；</li>\n<li>weight（加权轮询）指定轮询策略，weight 和访问比率成正比，用于后端服务器性能不均的情况；</li>\n<li>least_conn 最小连接数，哪个连接少就分给谁。</li>\n</ol>\n<p>集群状态：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">down</td>\n<td style=\"text-align:left\">不参与负载均衡</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">backup</td>\n<td style=\"text-align:left\">备份的服务器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">max_fails</td>\n<td style=\"text-align:left\">允许请求失败的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fail_timeout</td>\n<td style=\"text-align:left\">经过 max_fails 失败后，服务暂停的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">max_conts</td>\n<td style=\"text-align:left\">限制最大的接收的连接数</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream test1 &#123;</span><br><span class=\"line\">    ip_hsah;</span><br><span class=\"line\">    server http://localhost:3000 weight=2;</span><br><span class=\"line\">    server http://localhost:4000 weight=1;</span><br><span class=\"line\">    server http://localhost:5000 down;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    # 访问负载均衡构造的集群</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        # 和upstrem的name对应</span><br><span class=\"line\">        proxy_pass http://test1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test1.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:3000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test2.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:4000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test3.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:5000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时访问<code>www.test.com</code>通过代理到访问<code>www.test1.com</code>，而访问 test1 的请求被负载均衡按照策略访问 test1 或者 test2</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>\n<p>环境</p>\n<p>CENTOS&gt;=7.0,位数 X64 CENTOS 7.2</p>\n</li>\n<li>\n<p>关闭 iptables</p>\n<p>iptables 命令是 Linux 上常用的防火墙软件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">功能</th>\n<th style=\"text-align:left\">命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">停止防火墙</td>\n<td style=\"text-align:left\">systemctl stop firewalld.service</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">永久关闭防火墙</td>\n<td style=\"text-align:left\">systemctl disable firewalld.service</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>安装依赖</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum  -y install gcc gcc-c++ autoconf pcre pcre-devel make automake</span><br><span class=\"line\">yum  -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>开始安装 nginx</p>\n<p>新建一个文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure>\n<p>内容输入如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[nginx]</span><br><span class=\"line\">name=nginx repo</span><br><span class=\"line\">baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">enabled=1</span><br></pre></td></tr></table></figure>\n<p>其中 centos/7 根据自己运行环境配置 系统名/版本号</p>\n<p>下载 nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install nginx -y</span><br><span class=\"line\">nginx -v</span><br><span class=\"line\">nginx -V</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2>nginx 常用操作</h2>\n<ol>\n<li>\n<p>查看配置文件和目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ql nginx</span><br></pre></td></tr></table></figure>\n<p>相关文件说明：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">路径</th>\n<th style=\"text-align:left\">用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/logrotate.d/nginx</td>\n<td style=\"text-align:left\">用于 logrotate 服务的日志切割</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx /etc/nginx/nginx.conf /etc/nginx/conf.d /etc/nginx/conf.d/default.conf</td>\n<td style=\"text-align:left\">主配置文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/fastcgi_params /etc/nginx/scgi_params /etc/nginx/uwsgi_params</td>\n<td style=\"text-align:left\">cgi 配置,fastcgi 配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/koi-utf /etc/nginx/koi-win /etc/nginx/win-utf</td>\n<td style=\"text-align:left\">编码转换映射转化文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/mime.types</td>\n<td style=\"text-align:left\">设置 http 协议的 Content-Type 与扩展名对应关系</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug</td>\n<td style=\"text-align:left\">用于配置系统守护进程管理器管理方式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/modules /usr/lib64/nginx/modules</td>\n<td style=\"text-align:left\">nginx 模块目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">命令</td>\n<td style=\"text-align:left\">/usr/share/doc/nginx-1.14.0 /usr/share/doc/nginx-1.14.0/COPYRIGHT</td>\n<td style=\"text-align:left\">nginx 的手册和帮助文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目录</td>\n<td style=\"text-align:left\">/var/cache/nginx</td>\n<td style=\"text-align:left\">nginx 的缓存目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目录</td>\n<td style=\"text-align:left\">/var/log/nginx</td>\n<td style=\"text-align:left\">nginx 的日志目录</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>启动和重新加载以及关闭</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx.service</span><br><span class=\"line\">systemctl reload nginx.service</span><br><span class=\"line\">systemctl stop nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>如果在启动的时候可能会遇到下列问题：</p>\n<ol>\n<li>端口被占用；</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting nginx: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\"></span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] still could not bind</span><br></pre></td></tr></table></figure>\n<p>可以先查看进程，再杀死对应进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntpl</span><br><span class=\"line\"></span><br><span class=\"line\">kill 进程号</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>配置 nginx</p>\n</li>\n</ol>\n<blockquote>\n<p>/etc/nginx/nginx.conf</p>\n</blockquote>\n<p>查看日志命令 tailf -f log 目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user  nginx;   设置nginx服务的系统使用用户</span><br><span class=\"line\">worker_processes  1;  工作进程数,一般和CPU数量相同</span><br><span class=\"line\"></span><br><span class=\"line\">error_log  /var/log/nginx/error.log warn;   nginx的错误日志</span><br><span class=\"line\">pid        /var/run/nginx.pid;   nginx服务启动时的pid</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;每个进程允许的最大连接数 10000</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       /etc/nginx/mime.types;//文件后缀和类型类型的对应关系</span><br><span class=\"line\">    default_type  application/octet-stream;//默认content-type</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '</span><br><span class=\"line\">                    '$status $body_bytes_sent \"$http_referer\" '</span><br><span class=\"line\">                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';  //日志记录格式</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;//默认访问日志 日志格式与log_format main 对应</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;//启用sendfile</span><br><span class=\"line\">    #tcp_nopush     on;//懒发送 客户端请求数据不会每次都时时相应 让数据塞满一次性发送给客户端（多用于下载、断点 续传）</span><br><span class=\"line\">    #tcp_nodelay on; // 默认开启 与nopush互斥 提高实时请求响应效率</span><br><span class=\"line\"></span><br><span class=\"line\">    keepalive_timeout  65;//超时时间是65秒</span><br><span class=\"line\"></span><br><span class=\"line\">    #gzip  on;gzip压缩</span><br><span class=\"line\"></span><br><span class=\"line\">    include /etc/nginx/conf.d/*.conf;//包含的子配置文件</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>/etc/default.conf</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    # 用域名方式访问的地址</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    #charset koi8-r; //编码</span><br><span class=\"line\">    #access_log  /var/log/nginx/host.access.log  main;  //访问日志文件和名称</span><br><span class=\"line\"></span><br><span class=\"line\">    # 代理</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:3000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    # 转发请求静态资源（js、css）规则</span><br><span class=\"line\">    location ~ .*\\.(html|js|css)$ &#123;</span><br><span class=\"line\">        # CORS</span><br><span class=\"line\">        add_header Access-Control-Allow-Origin *;</span><br><span class=\"line\">        add_header Access-Control-Allow-Methods GET,POST,DELETE;</span><br><span class=\"line\">        add_header Access-Control-Allow-Headers Content-Type;</span><br><span class=\"line\">        # 默认带上客户端cookie</span><br><span class=\"line\">        add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">        # 缓存1h</span><br><span class=\"line\">        expires 1h;</span><br><span class=\"line\">        # 开启gzip</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        # gzip压缩HTTP版本号 一般是1.1</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        # gzip压缩等级 越大压缩率越高 1-9</span><br><span class=\"line\">        gzip_comp_level 2;</span><br><span class=\"line\">        # 默认不指定不会缓存css资源 需要指定text/css类型</span><br><span class=\"line\">        gzip_types application/javascript text/css;</span><br><span class=\"line\">        # 资源目录</span><br><span class=\"line\">        root /data/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置图片请求规则</span><br><span class=\"line\">    location ~ .*\\.(gif|png|jpg|webp)$ &#123;</span><br><span class=\"line\">        expires 1h;</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        gzip_comp_level 3;</span><br><span class=\"line\">        gzip_types image/jpeg image/png image/gif image/webp;</span><br><span class=\"line\">        ## 防盗链</span><br><span class=\"line\">        ## valid_referers 合法的域名 *.baidu.com</span><br><span class=\"line\">        ## &lt;meta name=\"referrer\" content=\"never\"&gt;</span><br><span class=\"line\">        valid_referers none blocked xx.xxx.xxx.xx;</span><br><span class=\"line\">        if ($invalid_referer) &#123;</span><br><span class=\"line\">            return 403;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        # 资源目录</span><br><span class=\"line\">        root /data/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ ^/download &#123;</span><br><span class=\"line\">        # 默认先查找当前目录下的后缀为.gz文件 有直接返回给客户端 不需要再压缩</span><br><span class=\"line\">        # linux下运行gzip 文件名会生成压缩gz文件</span><br><span class=\"line\">        # url最直接访问该文件路径就会自动启动下载该资源</span><br><span class=\"line\">        gzip_static on;</span><br><span class=\"line\">        tcp_nopush on;</span><br><span class=\"line\">        root /data/download;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   /usr/share/nginx/html;  //静态文件根目录</span><br><span class=\"line\">        index  index.html index.htm;  //首页的索引文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #error_page  404              /404.html;  //指定错误页面</span><br><span class=\"line\"></span><br><span class=\"line\">    # redirect server error pages to the static page /50x.html</span><br><span class=\"line\">    # 把后台错误重定向到静态的50x.html页面</span><br><span class=\"line\">    error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">    location = /50x.html &#123;</span><br><span class=\"line\">        root   /usr/share/nginx/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">    # 把PHP脚本9000端口上监听的FastCGI服务</span><br><span class=\"line\">    #location ~ \\.php$ &#123;</span><br><span class=\"line\">    #    root           html;</span><br><span class=\"line\">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">    #    fastcgi_index  index.php;</span><br><span class=\"line\">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class=\"line\">    #    include        fastcgi_params;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 不允许访问.htaccess文件 只允许指定的ip访问</span><br><span class=\"line\">    location ~ /\\.ht &#123;</span><br><span class=\"line\">        allow 127.0.0.1</span><br><span class=\"line\">        deny  all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>实现负载均衡</p>\n</blockquote>\n<ol>\n<li>\n<p>解决高并发、海量数据问题</p>\n</li>\n<li>\n<p>配置类型</p>\n<ol>\n<li>轮询（默认） 每个请求按照时间顺序逐一分配不同的后端服务器；</li>\n<li>ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定放一个后端服务器，可以解决 session 的问题；</li>\n<li>weight（加权轮询）指定轮询策略，weight 和访问比率成正比，用于后端服务器性能不均的情况；</li>\n<li>least_conn 最小连接数，哪个连接少就分给谁。</li>\n</ol>\n<p>集群状态：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">down</td>\n<td style=\"text-align:left\">不参与负载均衡</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">backup</td>\n<td style=\"text-align:left\">备份的服务器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">max_fails</td>\n<td style=\"text-align:left\">允许请求失败的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fail_timeout</td>\n<td style=\"text-align:left\">经过 max_fails 失败后，服务暂停的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">max_conts</td>\n<td style=\"text-align:left\">限制最大的接收的连接数</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream test1 &#123;</span><br><span class=\"line\">    ip_hsah;</span><br><span class=\"line\">    server http://localhost:3000 weight=2;</span><br><span class=\"line\">    server http://localhost:4000 weight=1;</span><br><span class=\"line\">    server http://localhost:5000 down;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    # 访问负载均衡构造的集群</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        # 和upstrem的name对应</span><br><span class=\"line\">        proxy_pass http://test1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test1.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:3000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test2.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:4000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test3.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:5000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时访问<code>www.test.com</code>通过代理到访问<code>www.test1.com</code>，而访问 test1 的请求被负载均衡按照策略访问 test1 或者 test2</p>\n"},{"title":"js知识点总结","catalog":true,"date":"2018-07-21T02:24:38.000Z","subtitle":null,"header-img":null,"_content":"\n# js 知识点总结\n\n## 1. 解码和编码\n\n> 原因：因为链接里面会有中文或者特殊字符号无法跳转需要进行相关编码解码\n\n**编码**\n\n>\n\n    'encodeURI': 只对查询的参数做编码\n\n    'encodeURIComponent': 对整个url做编码，包括? & / #\n\n```javascript\na = 'www.baidu.com/test?name=\"zhangsan\"'\nencodeURI(a) => 'www.baidu.com/test?name=%22zhangsan%22'\nencodeURIComponent(a) => 'www.baidu.com%2Ftest%3Fname%3D%22zhangsan%22'\n```\n\n**解码**\n\n>\n\n    'decodeURI': 只对查询参数做解码\n    'decodeURIComponent': 对整个URL做解码\n\n---\n\n## 2. 序列化和反序列化\n\n>\n\n```\nJSON.stringify()        // 序列化\nJSON.parse()            // 反序列化\n```\n\n使用 ajax 需要设置请求头部信息\n\nheader: {'Content-Type': 'application/json; charset=utf-8;'}\n\n> JSON.stringify() 可以简单的用来迅速判断两个对象是否相等，但不严谨（比如：序列化失败）\n\n---\n\n## 3. 日期\n\n```\nnew Date().getTime()   // 单位  秒\n// 获取当前时间   （存在兼容性）\nnew Date().toLocaleDateString() // 2017/7/24\nnew Date().toLocaleTimeString() // 下午5:07:33\nnew Date().toLocaleString()     // 2017/7/24 下午5:07:33\n// 若要显示24进制 需要option选项\nnew Date().toLocaleTimeString(\"UTC\",{ hour12: false })  // 17:20:16\n```\n\n---\n\n## 4. 回流/重绘\n\n1. 回流：几何属性发生变化 比如：内容、结构、位置或尺寸发生变化，需要重新计算样式和渲染树；\n\n2. 重绘：元素发生的改变只影响了节点的一些样式（背景色、边框色、文字颜色等）\n\n> 回流比重绘要消耗更多的资源\n\n---\n\n## 5. 锚点定位 scrollIntoView （无兼容问题）\n\n可以用来做一些 tab 定位\n\n```\ndocument.getElementById('xx').scrollIntoView()\n```\n\n---\n\n## 6. typeof 和 instanceof\n\n> ### typeof\n\n会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,function；\n\n缺点：\n\n- 不适用于来判断数组，因为不管是数组还是对象，都会返回 object。\n- 判断不了 null null 也是对象\n\n>\n\n```\ntypeof [1]      // Object\n```\n\n> ### instanceof\n\n返回的是一个布尔值 只能用来判断对象和函数\n\n```\nvar a = {};\nalert(  a instanceof Object )     // true\nvar a  = [];\nalert(  a instanceof Array )    // true\n```\n\n最靠谱也是最方便的办法使用`Object.prototype.toString.call()`来判断\n\n```javascript\nfunction types(target) {}\n```\n\n---\n\n## 7. requestAnimationFrame （RAF） 动画 api 兼容 Ie 8/9\n\n```\nvar i = 0\n\nwindow.requestAnimFrame = (function(){\n  return  window.requestAnimationFrame       ||\n          window.webkitRequestAnimationFrame ||\n          window.mozRequestAnimationFrame    ||\n          function( callback ){\n            window.setTimeout(callback, 1000 / 60);\n          };\n})()\n\nrequestAnimFrame(animloop)\n\nfunction animloop () {\n    document.getElementById('test').style.top = i ++\n}\n\n```\n\n### 优点\n\n    1. 解决毫秒的不精确性；\n    2. 避免过渡渲染；\n    3. 浏览器可以优化并行的动画动作，将合并的动作放入一个渲染周期；\n    4. 过程可控；\n\n> 动画效率之争\n\n    css3动画高效的原因有以下三点：\n\n        1. 强制使用硬件加速（GPU）；\n        2. 使用与RAF类似的机制；\n        3. 优化DOM操作 避免内存消耗来减少卡顿；\n\n    同时因为采用GPU， 导致浏览器一直出于高负荷运转，移动端电量损耗和一定卡顿，\n    而且css不能完全被js控制\n    pc上兼容性\n\njs 动画库 （比如 Velocity.js 和 GSAP）\n\n---\n\n## 8. 跨域\n\n1. ### JSONP\n\n   > 通过 js 标签引入一个 js 文件 这个 js 文件载入成功之后会执行我们在 url 参数中指定的函数 并且会吧我们需要的 json 数据作为参数传入\n   >\n   > 例如：url?item=1&callback=filter\n   >\n   > == 原生 js 实现 jsonp 的话 定义好 callback 的函数名称,动态创建 js 标签 url 加上查询的参数写好 callback 的回调函数名称即可 ==\n\n2. ### 利用 iframe 并修改 document.domain 来跨子域\n\n   两个不同域的页面引入 iframe 标签 同时将两个页面的主域设置成相同的域名\n\n   ![页面1](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox669ialYSHxewnD1B4L5UibVqhMnFEfibLhA8vUQu2s9rltB2HZ6UTQ19iag/0?wx_fmt=png)\n   ![页面2](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6Kv2iaHanjIzQHDNeia2FsoHSz8AJPkxh0IqickdbPg0CPeFPhoQMpuv5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n3. ### window.name （可以配合 iframe）\n\n   同源窗口下 window.name 对所有页面都是共享的\n\n   每个页面对 window.name 都有读写权限\n\n   window.name 的值并不会因为新页面而重置\n\n4. widnow.postMessage （存在兼容性 IE7/8 不支持）\n\n   ！[页面 1](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6z8ibxywKPEusvEA2xS8ialrQ1Oxd0jw0V8C6f7Gicy6Obsyt5bicibxdx5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n   ！[页面 2](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6B9Fpsa9KmNAMibvfSqE8Qv2icpLzzFE6NfvEp8YxWW6JOMTacIzaQzxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n5. Nginx 反向代理\n\n## 9. selection\n\n> 获取鼠标划过文本的对象\n\n> `window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();`\n\n---\n\n## 10. 正则表达式\n\n> 常用规则\n\n- \\n 回车\n- \\t 制表符\n- \\r 换行符\n- \\s 空格\n- \\u4e00-\\u9fa5 中文\n- \\w 大小写字母\\_数字\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- {n, m} 至少出现 n 次 最多 m 次\n- {n,} 至少 n 次\n- - 任意次\n- - 至少一次\n- {n} 至少 n 次\n- () 分组符号\n- [\\s\\S] 任意字符\n- ^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。\n- 正则的最后位置 , 就代表结束的意思\n\n\n匹配中文: [\\u4e00-\\u9fa5]\n\n例如：\n\n```\nvar str = '2013-6-7';\nvar re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-\nvar re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-\nvar re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-\n\n--------------------------\nvar str = '2013-6-7';\nvar re = /(\\d+)(-)/g;\n\nstr = str.replace(re,function($0,$1,$2){\n\n    //replace()中如果有子项，\n    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,\n    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )\n    return $1 + '.';  //分别返回2013.   6.\n\n});\n\n```\n\n- [] 表示某个集合中的任意一个\n- [^a] 排除 a\n\n```\n// var re = /\\bclassname\\b/;\n\n// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会\n// 把classname当做一个字符串去匹配。\n\nvar re = new RegExp('\\\\b'+classname+'\\\\b');\n\n// 匹配的时候，classname前面必须是起始或者空格，后面也是。\n\n默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。\n```\n\n---\n\n## 11. Object\n\n    1. constructor\n\n        实例的constructor 永远指向 构造函数 的 prototype.constructor\n\n        理解成 实例是基于构造函数原型链生成的对象\n\n```\n\nfunction A(x){\n    this.x = x;\n}\nvar newA = new A(name);\n\n此时：\nnewA.constructor == A.prototype.constructor;\n\n```\n\n    2. hasOwnProperty\n\n        判断对象上某个属性是否属于自身 属于自身为true, 原型链上为false\n\n```\n    function a () {\n        this.show = 'x';\n    }\n    a.prototype.hide = function () {\n        console.log(111111);\n    }\n    var z = new a();\n    z.hasOwnProperty('show');          // true\n    z.hasOwnProperty('hide');          // false\n```\n\n    3. isPrototypeOf\n\n        判断一个对象是否是另一个对象的原型\n\n```\n    var monkey = {\n        hair : true,\n        breathes : function(){\n            alert('1')\n        }\n    }\n    function Human(name){\n        this.name = name;\n    }\n    // Human的原型链绑定monkey对象\n    Human.prototype = monkey;\n\n    var man = new Human('张三');\n    monkey.isPrototypeOf(man);      // true\n\n```\n\n    4. prototype和__proto__\n\n        prototype是一个函数的内置属性（每个函数都有一个prototype属性）\n\n        __proto__ 是一个实例对象的内置属性 实例化的对象在内部通过此属性寻找原型链\n\n```\nvar Person = function () {}\nvar zhangsan = new Person ()\n\nzhansan.__prop__ = Person.prototype\n\nnew 的过程拆分成以下三步\n\n1. var p = {}\n2. p.__proto__ = Person.prototype\n3. Person.call(p)\n```\n\n    5. Object.getPrototypeOf\n\n        获取 实例化对象 原型链 的相关属性\n\n```\nfunction Test () {\n\n}\n\ntest.prototype.showName = function () {\n    console.log(1)\n}\n\nlet obj = new Test ()\nObject.getPrototypeOf(obj) == obj.__proto__\n\n```\n\n    6. Object.keys\n\n        可以用来枚举可遍历的属性 返回一个数组\n\n    7. Object.create\n\n        在原型链上创建对象属性\n\n```\n    <!-- 属性创建在原型链上 -->\n    Object.create({\n        name: '张三'\n    })\n\n    <!-- 字面量方式创建的对象属性挂在自身 -->\n    let test = {\n        name: '张三'\n    }\n\n```\n\n    8. Object.isExtensible\n\n        判断对象是否可以新增属性\n\n    9. Object.preventExtension\n\n        锁住对象 使其不能新增属性 但是原来的属性可以修改删除\n\n    10. Object.seal\n\n        密封对象 不能增加新属性 也不能删除旧属性  但是能修改原来的属性\n\n    11. Object.isSealed\n\n        判断对象是否密封\n\n    12. Object.freeze\n\n        冻结对象 不能新增 不能修改 不能删除\n\n    13. Object.isFrozen\n\n        判断对象是否完全被冻结\n\n    14. Object.getOwnPropertyNames\n\n        获取自身属性名字 返回一个数组\n\n    15. Object.getOwnPropertyDescriptor\n\n        判断某个对象上某个属性的状态描述\n\n    16. Object.defineProperty\n\n\n\n\n    -----------\n\n## 12. 继承\n\n> **调用另一个对象的方法，以另一个对象替换当前对象的上下文**\n>\n> > 缺点\n> >\n> > > 只能继承父级本身属性，原型链的属性无法继承\n\n- **call**\n  > 第二个参数可以省略\n- **apply**\n  > 第二个参数必须是数组或者用 arguments 代替\n- **bind**\n  > bind 与 call 和 apply 的区别在于 bind 是一个函数 不会立即执行 必须在后面再加上一对括号去立即执行\n\n```\n例子1：\n\nfunction Add(a,b)\n{\n    this.add = function(a,b){\n        alert(a+b)\n    };\n    this.xx = 333;\n}\nfunction Sub()\n{\n    this.sub = '张三';\n\n    // call方法\n    Add.call(this); // call继承Add所有方法(不包含原型链上的方法)\n\n    // apply方法  参数不能指定的时候用[]或者arguments代替\n    Add.apply(this, [])\n    // 又可以写成\n    Add.apply(this, arguments)\n\n    // bind方法\n    Add.bind(this)();\n}\n\nx = new Sub();\nx.add(5,7)                  // 11\n\n=====================================\n\n例子2：\n\n若只想继承父级构造函数某一个具体方法\n需要先将父子对象都实例化后 调用父级的具体方法call\n\nfunction Add(a,b)\n{\n    this.add = function(a,b){\n        alert(a+b)\n    };\n    this.xx = 333;\n}\nfunction Sub()\n{\n    this.sub = '张三';\n}\n\nnewAdd = new Add(7,8);\nnewSub = new Sub();\n\n// Sub只继承了Add的add方法并执行相关方法\n\ncall方法：\nnewAdd.add.call(newSub, 10, 4);      // 14\n\napply方法：\nnewAdd.add.apply(newSub, [10, 4]);   // 14\n\nbind方法：\nnewAdd.add.bind(newSub, 10, 4)();   // 14\n\n```\n\n>\n\n> > **注意**\n> >\n> > > 若想要全部继承父级所有相关属性 得采用==原型链继承==的方式\n\n```\nfunction person(){\n    this.hair = 'black';\n    this.eye = 'black';\n    this.skin = 'yellow';\n    this.view = function(){\n        return this.hair + ',' + this.eye + ',' + this.skin;\n    }\n}\nfunction man(){\n    this.feature = ['beard','strong'];\n}\nman.prototype = new person();\n\n```\n\n---\n\n## 13. cookie sessionStorage localStorage\n\n    1. cookie\n        * 4k的限制；\n        * 服务端和客户端传递时都会带上cookie；\n        * 本质上是对字符串的读取 存储内容过多消耗内存空间 导致页面变卡顿；\n        * 不能被爬虫读取；\n        * 设置时间之前一直有效，到时间就清除；\n    2. sessionStorage\n        * 临时存储：引入“浏览器窗口”的概念，同源同窗口数据不会销毁，不同标签页中数据不能共享，关闭浏览器时候销毁；\n        * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n        * 性能更好，即本地读取数据比服务器获取快多了；\n        * 不能跨tab标签页传值；\n    3. localStorage\n        * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n        * 体积更大 5M；\n        * 持久存储在本地，直到手动清除；\n\n```\nlocalStorage.setItem('sss',1111);\nlocalStorage.getItem('sss');\nlocalStorage.removeItem('sss');\nlocalStorage.clear();\n```\n\n---\n\n## 14. 闭包\n\n    简单回答闭包就是 一个函数返回自身内部函数的调用\n\n    为什么使用？\n\n    因为js是链式的 一层一层向上级查找 所以外部函数无法访问内部函数;\n\n> > 优点\n>\n> - 可以读取函数内部的变量，外部无法访问到里面变量;\n> - 函数在执行完毕不会被销毁 而是一直存在内存中;\n\n> > 缺点\n>\n> - 不会被内存回收 容易出现性能问题\n\n```\nfunction foo(){\n    var a = 2;\n\n    function bar(){\n        console.log(a);\n    }\n\n    return bar;\n}\nvar newFoo = foo();\nnewFoo();               // a\n\n```\n\n---\n\n## 15. 深拷贝和浅拷贝\n\n- **浅拷贝**\n  > **复制对象的副本 指向同一内存区域 对副本的操作会影响父级对象**\n\n浅拷贝方式：\n\n1. 直接赋值；\n2. Object.assign();\n3. JSON 序列化；\n\n- **深拷贝**\n  > **复制对象的副本 指向不同的内存区域 与父级对象独立**\n\n```\n// 浅拷贝\nvar a = {\n    name : 'zhangsan'\n}\n\nvar b = a;\nb.name = 'lisi';\n\nconsole.log(a.name);    // \"lisi\"\nconsole.log(b.name);    // \"lisi\"\n\n// 深拷贝  (更完整的深拷贝还需要再详细优化)\nfunction deepCopy(p, c){\n    var c = c || {};\n    for(var i in p ){\n        // 数组和对象的时候再处理\n        if(typeof p[i] === 'object'){\n            c[i] = (p[i].constructor === Array) ? [] : {};\n            deepCopy(p[i], c[i]);\n        }else{\n            // 基本类型直接赋值\n            c[i] = p[i]\n        }\n    }\n    return c;\n}\n\nvar parent = {\n    number: [1, 2, 3],\n    obj: {\n        prop: 1\n    }\n}\n\nvar copyParent = deepCopy(parent);\ncopyParent.number.push(4)\ncopyParent.number                   // 1,2,3,4\nparent.number                       // 1,2,3\n```\n\n---\n\n## 16. 传值类型和引用类型\n\n- **传值类型（基本类型）**\n  > 值为基本类型时候为深拷贝\n  >\n  > > 基本类型就是 null，undefined，Boolean，string，number\n  > >\n  > > > ==独立不干扰==\n- **引用类型**\n  > 值为对象类型时候为浅拷贝\n  >\n  > > 值都是对对象的引用，即一个指向对象的指针\n  > >\n  > > > ==对副本的操作会影响父级对象==\n\n```\n// 传值类型\nvar  a = 1;\nfunction voo(data)\n{\n    data = 2;\n    console.log(data);   // 2\n}\nvoo(a);\nconsole.log(a);    // 1\n\n// 引用类型\nvar  a = {\n    name : \"张三\"\n};\nfunction voo(data)\n{\n    data.name = \"李四\";\n    console.log(data);   //  Object {name: \"李四\"}\n}\nvoo(a);\nconsole.log(a);         //  Object {name: \"李四\"}\n\n// 引用类型不会被基本类型覆盖\nvar  a = {\n    name : \"张三\"\n};\nfunction voo(data)\n{\n    data = 3；\n    console.log(data);   // 3\n}\nvoo(a);\nconsole.log(a);         //  Object {name: \"张三\"}\n\n// 为了解决引用类型的问题  引入深拷贝的概念  参考上面一个概念\n\n```\n\n---\n\n## 17. 函数作用域提升与预编译\n\n> 由于 js 没有其他强类型语言{}这类的块级作用域 只有函数作用域 函数的声明很随意导致各种问题出现\n>\n> > 变量预编译 > 函数预编译\n\n```\n// 第一条\n\na();\nvar a = c = function() {\n    console.log(2)\n};\na();\n\nfunction a() {\n    console.log(1)\n};\na();\n(function(b) {\n    b(), c()\n    var b = c = function a() {\n        console.log(3)\n    }\n    b();\n})(a);\nc();\n\n// 等价于：\nvar a;                      // 变量声明提升\nfunction a() {              // 函数声明提升\n    console.log(1)\n};\na();                        // 1\na = c = function() {\n    console.log(2)\n};\n\na();                        // 2\n\n(function(b) {\n    var b\n    b()                     // 2\n    c()                     // 本来以error\n    // 后来有人指正 原因就在于var b=c=xxx。\n    // c相当于没有加var 不会预编译，这里c直接查找到外部作用域的c\n    b = c = function a() {\n        console.log(3)\n    }\n    b();                    // 3\n})(a);\n\nc();                        // 3\n\n\n// 第二条\nfunction fn(){\n    function a(){console.log(1)}\n    return a;\n    function a(){console.log(2)}\n}\nfn()();                     //2 由于预编译 后面的a覆盖了前面的a\n\n// 第三条\nvar a=10;\nfunction fn(){\n    // 预编译a 赋值undefined，内部作用域存在a这个变量，\n    // 所以这里 !a 就是  !undefined，就是true，进入函数a=20;\n    if (!a) {\n        var a=20\n    }\n    console.log(a)          //  这里是20 ，\n}\nfn()\n\n// 第四条\n<script>\n    console.log(typeof a)   //undefined\n    var a='littlebear';\n    console.log(a)          //littlebear\n</script>\n<script>\n    console.log(typeof a)   //string  第二个<script>标签里的a但会往上查找。\n    var a=1;\n    console.log(a)//1\n</script>\n\n// 第五条\n<script>\n    console.log(typeof a)   //undefined\n    console.log(a)\n    // 报错，遇到<script>标签对时，会先对这一块进行预解析，\n    // 下面没预解析，所以找不到声明过的a，于是报错了\n</script>\n<script>\n    console.log(typeof a)   //undefined\n    var a=1;\n    console.log(a)          //1\n</script>\n\n// 第六条\n<script>\n    function fn(a,b){\n        console.log(a)      //容易上当 初始化a的时候已经赋值'容易上当'\n        var a=10;\n        console.log(a)      //10\n    }\n    fn('容易上当');\n</script>\n\n```\n\n---\n\n## 18. AMD 和 CMD 区别\n\n1. AMD 推崇依赖前置。 （requireJS）\n\n   CMD 推崇依赖就近， （seaJS）\n\n```\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a')\n    a.doSomething()         // 此处略去 100 行\n    var b = require('./b')  // 依赖可以就近书写\n    b.doSomething()         // ...\n\n})\n// AMD 默认推荐\ndefine(['./a', './b'], function(a, b) {\n    // 依赖必须一开始就写好\n    a.doSomething()    // 此处略去 100 行\n    b.doSomething()\n})\n```\n\n2.  对于依赖的模块，\n\n    AMD 是提前执行（预执行），\n\n    CMD 是延迟执行（懒执行）。\n\n> 不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n3.  AMD 的 API 默认是一个当多个用，\n\n    CMD 的 API 严格区分，推崇职责单一\n\n> 比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。\n\n---\n\n## 19. 常见服务器的状态码\n\n- 304\n\n  Not Modified\n\n  客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n\n- 400\n\n  Bad Request\n\n  表示该请求报文中存在语法错误，导致服务器无法理解该请求。\n\n- 403\n\n  Forbidden\n\n  该状态码表明对请求资源的访问被服务器拒绝了。\n\n- 500\n\n  Internal Server Error\n\n  该状态码表明服务器端在执行请求时发生了错误。\n\n- 502\n\n  上游网关错误\n\n- 301\n\n  永久重定向\n\n- 302\n\n  临时重定向 会出现 URL 劫持 体现在搜索引擎收录策略上 会改变原有请求方法\n\n- 307\n\n  临时重定向 与 302 区别 客户端应`保持请求方法`不变向新的地址发出请求\n\n---\n\n## 20. 事件冒泡和事件捕获\n\n    * 事件冒泡兼容写法\n\n    ```\n    if (event.cancelBubble) {\n        event.cancelBubble = true\n    } else {\n        event.stopPropagation()\n    }\n    ```\n    --------------------------\n\n## 21. 数组\n\n    1. push\n\n        向数组末尾添加指定元素\n\n    2. pop\n\n        移除数组末尾的一个元素 并返回移除的元素\n\n    3. shift\n\n        移除数组第一项 并返回该元素\n\n    4. unshift\n\n        给数组第一项加上一个元素 返回数组长度\n\n    5. join\n\n        数组按照指定的字符换转成字符串\n\n    6. sort\n\n        数组按照ASCII排序  所以要完全按照从小到大的顺序排序的话需要指定参数 1 -1 0\n\n    7. splice\n\n        从0开始\n\n    > 删除 ---------------------（**起始位置，截取个数**）\n\n    > 插入 ---------------------（**起始位置，截取个数为0，要插入的项**）\n\n    > 替换----------------------（**起始位置，截取个数为1，要插入的项**）\n\n    8. slice\n\n    9. concat\n\n    10. reverse\n\n    11. 遍历数组的方法\n\n        > forEach\n        > for in\n\n        两者区别 在于 for in 会遍历数组原型链的属性值\n\n        为了避免这样的情况 使用 hasOwnProperty 解决\n\n---\n\n## 22.正则\n\n- ()：小括号，叫做分组符。\n- \\s : 空格\n- \\S : 非空格\n- \\d : 数字\n- \\D : 非数字\n- \\w : 字符 ( 字母 ，数字，下划线\\_ )\n- \\W : 非字符\n- .（点）——任意字符\n- \\. : 真正的点\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- \\B : 非独立的部分\n- {n,m}：至少出现 n 次，最多 m 次\n- {n,} :至少 n 次\n- - :任意次 相当于{0,}\n- ？ ：零次或一次 相当于{0,1}\n- - ：一次或任意次相当于 {1,}\n- {n}： 正好 n 次\n- [] ： 表示某个集合中的任意一个 不能为空\n\n---\n\n> ### 字符串相关的正则方法\n\n- ### match()\n\n> 返回一个包含匹配内容的数组\n\n```\nvar str = 'abcdef';\n\nvar re = /B/i;\n\nstr.match(re) // [b]\n```\n\n例子 2：\n\n```\nurl = https://dimg.fws.qa.nt.ctripcorp.com/images/2d090m000000062hy59E5.jpg\"\nurl.match(/[^\\/]*$/) // 2d090m000000062hy59E5.jpg\nurl.match(/^[^\\/]*/) // https\n```\n\n- ### search()\n\n> 返回匹配到的第一个内容所在的位置\n\n```\nvar str = 'abcdef';\n\nvar re = /B/i;\n\nstr.search(re) // 1\n\n```\n\n- ### replace()\n\n> 查找符合正则的字符串并替换成==一个==对应的字符串。返回替换后的内容。\n\n```\nvar str = \"我爱北京天安门，天安门上太阳升。\";\nvar re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配\nvar str2 = str.replace(re,'*'); // 我爱**，*上太阳升。\n\n```\n\n并不能解决一个文字\\*的对应\n\n```\nvar str = \"我爱北京天安门，天安门上太阳升。\";\nvar re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配\nvar str2 = str.replace(re,function(str){\n            alert(str);\n            //用来测试：参数代表每次搜索到的符合正则的字符，\n            //所以第一次str指的是北京 第二次str是天安门 第三次str是天安门\n            var result = '';\n            for(var i=0;i<str.length;i++){\n                result += '*';\n            }\n            return result; //所以搜索到了几个字就返回几个*\n        });\nalert(str2)\n```\n\n    ```\n    var str = '2013-6-7';\n    var re = /(\\d+)(-)/g;\n\n    str = str.replace(re,function($0,$1,$2){\n            // replace()中如果有子项，\n            // 第一个参数 ：$0（匹配成功后的整体结果  2013-  6-）,\n            // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n            // 第三个参数 : $2(匹配成功的第二个分组，这里指的是-    - - )\n        return $1 + '.';  //分别返回2013.   6.\n    });\n\n    alert( str );   //2013.6.7\n    //整个过程就是利用子项把2013- 6- 分别替换成了2013. 6.  最终弹出2013.6.7\n    ```\n\n---\n\n### 正则两个方法\n\n- ### test()\n\n> 匹配到指定内容返回 true\n\n- ### ==exec()==\n\n> 返回第一匹配项信息的数组 若没有返回 null\n> 有两个属性 index input\n\n    ```\n    var text = 'mom and dad and baby'\n    var pattern = /mom( and dad( and baby)?)?/gi\n    var matches = pattern.exec(text)\n    mathes.index // 0\n    mathes.input // mom and dad and baby\n    mathes[0] // mom and dad and baby\n    mathes[1] //  and dad and baby\n    mathes[2] // and baby\n    ```\n\n## 23. 后退监听\n\n> history.back() history.forward() history.replace()触发 onpopstate 事件\n\n    ```\n    window.onpopstate = function () {\n        alert('2222')\n        history.pushState(null, null, document.URL)\n        return false\n    }\n    history.pushState(null, null, document.URL)\n    ```\n\n    onbeforeunload事件有坑 chrome51版本及以后不能自定义文字 并且 页面载入之后一定要有浏览器行为才能触发\n\n## 24. base64 图片及相关验证码\n\n> data:image/gif;base64, (base64 地址)\n\n    ```\n    if (result == null || result.length == 0) return\n    result = $.parseJSON(result)\n    var id = result['id']\n    var imgUrl = result['base64Buffer']\n    $('#js-code').attr('src', 'data:image/gif;base64,' + imgUrl)\n\n    ```\n\n## 26. from 包裹的元素 document 事件失效 必须给 from 加事件\n\n## 27. 进制转换\n\n> 十进制转十六进制\n\n    ```\n    var s = 255\n    s.toString(16) // ff\n    ```\n\n> 十六进制转十进制\n\n    ```\n    parseInt('0xFF')   // 255\n    ```\n\n## 28. label 绑定事件一定要让事件委托到触发里面的 input\n\n    所以事件委托的时候直接监听input\n\n## 29. 跨域 post 请求转为 options 类型\n\n## 30. Math\n\n    1. Math.floor 向下舍入；\n    2. Math.ceil  向上舍入;\n    3. Math.cos   余弦;\n    4. Math.round 四舍五入;\n    5. Math.sin   正弦；\n    6. Math.tan   正切；\n\n## 31. isNaN\n\n    首先需要知道 '' == 0   'abc' != 0   [] == 0  [1] != 0   null == 0  {} != 0  undefined != 0\n\n    ```\n    isNaN('')   // false\n    isNaN(' ')  // false\n    isNaN('abc') // true\n    isNaN(undefined) // true\n    isNaN([])   // false\n    isNaN({})   // true\n    isNaN(null) // false\n\n    ```\n\n## 32. Boolen\n\n    首先需要知道  0 == false    1 == true  '' == false   undefined != false != true    null != false != true\n\n    ```\n    Boolean('') // false\n    Boolean('ssss') // true\n    Boolean([])  // true\n    Boolean([1,2])  // true\n    Boolen({})      // true\n    Boolen(null)    // false\n    Boolen(undefined)   // false\n    ```\n\n## 33. 解决回调地狱 （多级回调）\n\n    1. Promise\n\n    2. aSync/await\n\n    3. generator\n\n## 34. 字符串\n\n    1. slice\n\n        在 不修改目标数组 的情况下返回截取的指定元素（ **起始位置，截止位置**）\n\n        从0开始 ==不包含最后一个数值==\n\n        负数情况下 将负数加上自身长度得到的数值作为参数\n\n    2. substr\n\n        subdtr接收的是 起始位置 和 所要返回的字符串长度\n\n        在负数情况下  将第一个参数与字符串长度相加后的数值作为第一个参数\n\n    3. substring\n\n        默认会将较小的参数作为第一个参数\n\n        在 不修改目标数组 的情况下返回截取的指定元素 （ **起始位置，截止位置**）\n\n        负数当做0处理\n\n```\nlet test = 'abcdef'\ntest.slice(0, -1)   // abcde\ntest.slice(2, -3)   => test.slice(2,3)  // c\n\ntest.substring(1, -2) => a\ntest.substring(2, -3) => ab\n```\n\n    4. split\n\n        字符串按照指定规则转换成数组\n\n## 35. let 与 var 区别\n\n    1. var存在变量提升， let不存在；\n    2. let不允许重复声明；\n    3. var挂载在window下，let挂载在块作用域下；\n\n## 36. 为什么 var 可以重复声明\n\n    因为js运行过程中，\n\n    引擎 负责整个代码编译和运行\n\n    编译器 负责词法分析、语法分析、代码生成等工作\n\n    编译器从左至右编译var a，如果a不存在则在作用域声明一个新的变量a，若存在a则忽略继续向下编译；\n\n    引擎遇到a = 2，按照作用域链向上查找 若存在变量a直接赋值，不存在则在作用域重新声明新的变量并赋值2\n\n## 37. CommonJS 中的 require/exports 和 ES6 的 import/export 有什么区别\n\n1.\n\n> CommomJS 模块 require 代码时候会立刻执行；\n\n> ES6 模块是动态引用，不会立刻执行，仅仅作为一个加载模块的对象引用；\n\n2.\n\n> CommonJs 模块输出的是一个值的拷贝， 输出后的对象会被缓存（即 如果发现一个模块被多次引用，会直接返回已经执行的部分）；\n\n```\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n```\n\n```\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n\n```\n\n> ES6 模块输出的是值的只读引用；\n\n- 接口输出的变量是只读的，重新赋值会报错；\n- export 通过接口输出的是同一个值，得到的都是同样的实例；\n- 如果需要 import 支持动态加载 提案建议引入 import() 返回一个 promise 对象；\n\n参考资料：\n\n1. [ES6 模块与 CommonJS 模块的差异 ](http://es6.ruanyifeng.com/#docs/module-loader)\n\n## 38. 浏览器缓存\n\n    浏览器缓存分为 强缓存 和 协商缓存\n\n    1. 客户端先根据资源的http header判断是否命中强缓存，如果命中直接从缓存中读取；\n\n    2. 强缓存未命中，客户端发出请求，服务端根据请求的request header验证资源是否命中协商缓存，这个过程成为http再验证。如果命中，服务器将请求返回，状态码304，但不返回资源，而是告诉客服端可以从缓存读取；\n\n    3. 当协商缓存也没有命中，直接服务端返回资源给客户端；\n\n\n    强缓存\n\n    1. Expires 代表缓存过期时间；\n\n    2. Cache-Control： max-age  代表缓存最大生命周期；\n\n    协商缓存\n\n    1. Last-Modified 代表资源最后更新时间；\n\n    2. If-Modified-Since 代表 判断两次请求之间是否有过修改 没有直接返回协商缓存；\n\n## 39. 处理 js 双精度问题\n\n    ```javascript\n        0.1 + 0.2 = 0.30000000000000004\n    ```\n\n由于计算机是做二进制运算\n\n0.1 => 0.0001 1001 1001 1001…（无限循环）\n\n0.2 => 0.0011 0011 0011 0011…（无限循环）\n\n双精度浮点数的小数部分最多支持 52 位\n\n处理方法：\n\n    1. toFixed  不够严谨；\n    2. 把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。\n\n    ```javascript\n    ;(0.1 * 10 + 0.2 * 10) / 10 == 0.3\n    ```\n\n1. [个人封装的处理双精度方法 第 7 点](https://github.com/Megan-TA/UtilsJS)\n\n2. [关于 js 浮点数计算精度不准确问题的解决办法](https://www.cnblogs.com/xinggood/p/6639022.html)\n\n## 40. postMessage\n\n1. window.postMessage() 可以安全进行跨域、跨页面通信；\n1. 页面加载完成后才能进行跨域通信；\n\n发起端可以是 open 一个新窗口 或者 创建一个 iframe 往新窗口里发送数据\n\n案例:\n\n    ```javascript\n\n<!-- 客户端两种方式 -->\n\n<!-- 当前页面地址 http://www.webhek.com -->\n<!-- open方式 -->\n\n//弹出一个新窗口\nvar domain = 'http://fanyi.youdao.com';\nvar myPopup = window.open(domain, 'myWindow');\n\n//周期性的发送消息\nsetInterval(function(){\nvar message = 'Hello! The time is: ' + (new Date().getTime());\nconsole.log('blog.local: sending message: ' + message);\n//send the message and target URI\nmyPopup.postMessage(message,domain);\n},6000);\n\n<!-- iframe方式 -->\n\n//捕获 iframe\nvar domain = \"http://fanyi.youdao.com\";\nvar iframe = document.getElementById('myIFrame').contentWindow;\n\n//发送消息\nsetInterval(function(){\nvar message = 'Hello! The time is: ' + (new Date().getTime());\nconsole.log('blog.local: sending message: ' + message);\n//send the message and target URI\niframe.postMessage(message,domain);\n},6000);\n\n<!-- 接收端 -->\n\n//监听消息反馈\nwindow.addEventListener('message',function(event) {\nif(event.origin !== 'http://www.webhek.com') return;\nconsole.log('received response: ',event.data);\n},false);\n\n    ```\n\n> 截图如下：\n\n![web骇客网站  接收端截图](https://wx4.sinaimg.cn/mw690/006ANKB8gy1fqhqrhftfmj30yu0objvr.jpg)\n![有道翻译网站 接收端截图](https://wx2.sinaimg.cn/mw690/006ANKB8gy1fqhqri8fjlj30zk0h4tbk.jpg)\n\n> 参考资料\n\n1. [用 HTML5 里的 window.postMessage 在两个网页间传递数据](http://www.webhek.com/post/window-postmessage-api.html)\n\n## 41. Service Worker\n\n> 背景\n\n为了解决 web 业务不断增加带来更多消耗资源、耗时等复杂运算带来性能问题，w3c 初期提出 Web Worker 的 API，目的为了解放主线程。原理是 将复杂 耗时的操作独立出来交给 Web Worker，完成后通过 postMessage 方法告诉主线程。\n\n缺点：临时存在，不能永久；为此提出 Service Worker，在 Web Worker 基础上增加持久缓存能力。\n\n在 Service Worker 之前有 APPCache 这个持久缓存的 API，不过存在更新机主不完善，二次更新，大小限制，回滚等问题，具体参考下方链接 1。\n\nService Worker 的特性如下：\n\n- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n\n- 一旦被 install，就永远存在，除非被 uninstall\n\n- 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\n\n- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n\n- 离线内容开发者可控\n\n- 能向客户端推送消息\n\n- 不能直接操作 DOM\n\n- 出于安全的考虑，必须在 HTTPS 环境下才能工作\n\n- 异步实现，内部大都是通过 Promise 实现\n\n- 只能运行在 HTTPS 协议下\n\n> 参考资料\n\n1. [为什么 app cache 没有得到大规模应用？它有哪些硬伤吗？](https://www.zhihu.com/question/29876535)\n2. [Service Worker 简介](https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction)\n3. [如何优雅的为 PWA 注册 Service Worker](https://zhuanlan.zhihu.com/p/28161855)\n\n## 42 加载更多/下拉刷新\n\n原理：\n\nscrollTop（滚动条滚动距离） + clientHeight（可见区域高度） == scrollHeight（元素实际高度）\n\n备注：\n\noffsetHeighgt = height + padding + border\n\nclientHeight = height + padding\n\n## 43. js 标签中`async`和`defer`的作用与区别\n\n作用：\n\n1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。\n\n2.async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。\n\n3.defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。\n\n区别：\n\ndefer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。\n在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。\n","source":"_posts/js知识点总结.md","raw":"---\ntitle: js知识点总结\ncatalog: true\ndate: 2018-07-21 10:24:38\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n# js 知识点总结\n\n## 1. 解码和编码\n\n> 原因：因为链接里面会有中文或者特殊字符号无法跳转需要进行相关编码解码\n\n**编码**\n\n>\n\n    'encodeURI': 只对查询的参数做编码\n\n    'encodeURIComponent': 对整个url做编码，包括? & / #\n\n```javascript\na = 'www.baidu.com/test?name=\"zhangsan\"'\nencodeURI(a) => 'www.baidu.com/test?name=%22zhangsan%22'\nencodeURIComponent(a) => 'www.baidu.com%2Ftest%3Fname%3D%22zhangsan%22'\n```\n\n**解码**\n\n>\n\n    'decodeURI': 只对查询参数做解码\n    'decodeURIComponent': 对整个URL做解码\n\n---\n\n## 2. 序列化和反序列化\n\n>\n\n```\nJSON.stringify()        // 序列化\nJSON.parse()            // 反序列化\n```\n\n使用 ajax 需要设置请求头部信息\n\nheader: {'Content-Type': 'application/json; charset=utf-8;'}\n\n> JSON.stringify() 可以简单的用来迅速判断两个对象是否相等，但不严谨（比如：序列化失败）\n\n---\n\n## 3. 日期\n\n```\nnew Date().getTime()   // 单位  秒\n// 获取当前时间   （存在兼容性）\nnew Date().toLocaleDateString() // 2017/7/24\nnew Date().toLocaleTimeString() // 下午5:07:33\nnew Date().toLocaleString()     // 2017/7/24 下午5:07:33\n// 若要显示24进制 需要option选项\nnew Date().toLocaleTimeString(\"UTC\",{ hour12: false })  // 17:20:16\n```\n\n---\n\n## 4. 回流/重绘\n\n1. 回流：几何属性发生变化 比如：内容、结构、位置或尺寸发生变化，需要重新计算样式和渲染树；\n\n2. 重绘：元素发生的改变只影响了节点的一些样式（背景色、边框色、文字颜色等）\n\n> 回流比重绘要消耗更多的资源\n\n---\n\n## 5. 锚点定位 scrollIntoView （无兼容问题）\n\n可以用来做一些 tab 定位\n\n```\ndocument.getElementById('xx').scrollIntoView()\n```\n\n---\n\n## 6. typeof 和 instanceof\n\n> ### typeof\n\n会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,function；\n\n缺点：\n\n- 不适用于来判断数组，因为不管是数组还是对象，都会返回 object。\n- 判断不了 null null 也是对象\n\n>\n\n```\ntypeof [1]      // Object\n```\n\n> ### instanceof\n\n返回的是一个布尔值 只能用来判断对象和函数\n\n```\nvar a = {};\nalert(  a instanceof Object )     // true\nvar a  = [];\nalert(  a instanceof Array )    // true\n```\n\n最靠谱也是最方便的办法使用`Object.prototype.toString.call()`来判断\n\n```javascript\nfunction types(target) {}\n```\n\n---\n\n## 7. requestAnimationFrame （RAF） 动画 api 兼容 Ie 8/9\n\n```\nvar i = 0\n\nwindow.requestAnimFrame = (function(){\n  return  window.requestAnimationFrame       ||\n          window.webkitRequestAnimationFrame ||\n          window.mozRequestAnimationFrame    ||\n          function( callback ){\n            window.setTimeout(callback, 1000 / 60);\n          };\n})()\n\nrequestAnimFrame(animloop)\n\nfunction animloop () {\n    document.getElementById('test').style.top = i ++\n}\n\n```\n\n### 优点\n\n    1. 解决毫秒的不精确性；\n    2. 避免过渡渲染；\n    3. 浏览器可以优化并行的动画动作，将合并的动作放入一个渲染周期；\n    4. 过程可控；\n\n> 动画效率之争\n\n    css3动画高效的原因有以下三点：\n\n        1. 强制使用硬件加速（GPU）；\n        2. 使用与RAF类似的机制；\n        3. 优化DOM操作 避免内存消耗来减少卡顿；\n\n    同时因为采用GPU， 导致浏览器一直出于高负荷运转，移动端电量损耗和一定卡顿，\n    而且css不能完全被js控制\n    pc上兼容性\n\njs 动画库 （比如 Velocity.js 和 GSAP）\n\n---\n\n## 8. 跨域\n\n1. ### JSONP\n\n   > 通过 js 标签引入一个 js 文件 这个 js 文件载入成功之后会执行我们在 url 参数中指定的函数 并且会吧我们需要的 json 数据作为参数传入\n   >\n   > 例如：url?item=1&callback=filter\n   >\n   > == 原生 js 实现 jsonp 的话 定义好 callback 的函数名称,动态创建 js 标签 url 加上查询的参数写好 callback 的回调函数名称即可 ==\n\n2. ### 利用 iframe 并修改 document.domain 来跨子域\n\n   两个不同域的页面引入 iframe 标签 同时将两个页面的主域设置成相同的域名\n\n   ![页面1](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox669ialYSHxewnD1B4L5UibVqhMnFEfibLhA8vUQu2s9rltB2HZ6UTQ19iag/0?wx_fmt=png)\n   ![页面2](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6Kv2iaHanjIzQHDNeia2FsoHSz8AJPkxh0IqickdbPg0CPeFPhoQMpuv5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n3. ### window.name （可以配合 iframe）\n\n   同源窗口下 window.name 对所有页面都是共享的\n\n   每个页面对 window.name 都有读写权限\n\n   window.name 的值并不会因为新页面而重置\n\n4. widnow.postMessage （存在兼容性 IE7/8 不支持）\n\n   ！[页面 1](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6z8ibxywKPEusvEA2xS8ialrQ1Oxd0jw0V8C6f7Gicy6Obsyt5bicibxdx5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n   ！[页面 2](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6B9Fpsa9KmNAMibvfSqE8Qv2icpLzzFE6NfvEp8YxWW6JOMTacIzaQzxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n5. Nginx 反向代理\n\n## 9. selection\n\n> 获取鼠标划过文本的对象\n\n> `window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();`\n\n---\n\n## 10. 正则表达式\n\n> 常用规则\n\n- \\n 回车\n- \\t 制表符\n- \\r 换行符\n- \\s 空格\n- \\u4e00-\\u9fa5 中文\n- \\w 大小写字母\\_数字\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- {n, m} 至少出现 n 次 最多 m 次\n- {n,} 至少 n 次\n- - 任意次\n- - 至少一次\n- {n} 至少 n 次\n- () 分组符号\n- [\\s\\S] 任意字符\n- ^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。\n- 正则的最后位置 , 就代表结束的意思\n\n\n匹配中文: [\\u4e00-\\u9fa5]\n\n例如：\n\n```\nvar str = '2013-6-7';\nvar re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-\nvar re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-\nvar re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-\n\n--------------------------\nvar str = '2013-6-7';\nvar re = /(\\d+)(-)/g;\n\nstr = str.replace(re,function($0,$1,$2){\n\n    //replace()中如果有子项，\n    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,\n    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )\n    return $1 + '.';  //分别返回2013.   6.\n\n});\n\n```\n\n- [] 表示某个集合中的任意一个\n- [^a] 排除 a\n\n```\n// var re = /\\bclassname\\b/;\n\n// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会\n// 把classname当做一个字符串去匹配。\n\nvar re = new RegExp('\\\\b'+classname+'\\\\b');\n\n// 匹配的时候，classname前面必须是起始或者空格，后面也是。\n\n默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。\n```\n\n---\n\n## 11. Object\n\n    1. constructor\n\n        实例的constructor 永远指向 构造函数 的 prototype.constructor\n\n        理解成 实例是基于构造函数原型链生成的对象\n\n```\n\nfunction A(x){\n    this.x = x;\n}\nvar newA = new A(name);\n\n此时：\nnewA.constructor == A.prototype.constructor;\n\n```\n\n    2. hasOwnProperty\n\n        判断对象上某个属性是否属于自身 属于自身为true, 原型链上为false\n\n```\n    function a () {\n        this.show = 'x';\n    }\n    a.prototype.hide = function () {\n        console.log(111111);\n    }\n    var z = new a();\n    z.hasOwnProperty('show');          // true\n    z.hasOwnProperty('hide');          // false\n```\n\n    3. isPrototypeOf\n\n        判断一个对象是否是另一个对象的原型\n\n```\n    var monkey = {\n        hair : true,\n        breathes : function(){\n            alert('1')\n        }\n    }\n    function Human(name){\n        this.name = name;\n    }\n    // Human的原型链绑定monkey对象\n    Human.prototype = monkey;\n\n    var man = new Human('张三');\n    monkey.isPrototypeOf(man);      // true\n\n```\n\n    4. prototype和__proto__\n\n        prototype是一个函数的内置属性（每个函数都有一个prototype属性）\n\n        __proto__ 是一个实例对象的内置属性 实例化的对象在内部通过此属性寻找原型链\n\n```\nvar Person = function () {}\nvar zhangsan = new Person ()\n\nzhansan.__prop__ = Person.prototype\n\nnew 的过程拆分成以下三步\n\n1. var p = {}\n2. p.__proto__ = Person.prototype\n3. Person.call(p)\n```\n\n    5. Object.getPrototypeOf\n\n        获取 实例化对象 原型链 的相关属性\n\n```\nfunction Test () {\n\n}\n\ntest.prototype.showName = function () {\n    console.log(1)\n}\n\nlet obj = new Test ()\nObject.getPrototypeOf(obj) == obj.__proto__\n\n```\n\n    6. Object.keys\n\n        可以用来枚举可遍历的属性 返回一个数组\n\n    7. Object.create\n\n        在原型链上创建对象属性\n\n```\n    <!-- 属性创建在原型链上 -->\n    Object.create({\n        name: '张三'\n    })\n\n    <!-- 字面量方式创建的对象属性挂在自身 -->\n    let test = {\n        name: '张三'\n    }\n\n```\n\n    8. Object.isExtensible\n\n        判断对象是否可以新增属性\n\n    9. Object.preventExtension\n\n        锁住对象 使其不能新增属性 但是原来的属性可以修改删除\n\n    10. Object.seal\n\n        密封对象 不能增加新属性 也不能删除旧属性  但是能修改原来的属性\n\n    11. Object.isSealed\n\n        判断对象是否密封\n\n    12. Object.freeze\n\n        冻结对象 不能新增 不能修改 不能删除\n\n    13. Object.isFrozen\n\n        判断对象是否完全被冻结\n\n    14. Object.getOwnPropertyNames\n\n        获取自身属性名字 返回一个数组\n\n    15. Object.getOwnPropertyDescriptor\n\n        判断某个对象上某个属性的状态描述\n\n    16. Object.defineProperty\n\n\n\n\n    -----------\n\n## 12. 继承\n\n> **调用另一个对象的方法，以另一个对象替换当前对象的上下文**\n>\n> > 缺点\n> >\n> > > 只能继承父级本身属性，原型链的属性无法继承\n\n- **call**\n  > 第二个参数可以省略\n- **apply**\n  > 第二个参数必须是数组或者用 arguments 代替\n- **bind**\n  > bind 与 call 和 apply 的区别在于 bind 是一个函数 不会立即执行 必须在后面再加上一对括号去立即执行\n\n```\n例子1：\n\nfunction Add(a,b)\n{\n    this.add = function(a,b){\n        alert(a+b)\n    };\n    this.xx = 333;\n}\nfunction Sub()\n{\n    this.sub = '张三';\n\n    // call方法\n    Add.call(this); // call继承Add所有方法(不包含原型链上的方法)\n\n    // apply方法  参数不能指定的时候用[]或者arguments代替\n    Add.apply(this, [])\n    // 又可以写成\n    Add.apply(this, arguments)\n\n    // bind方法\n    Add.bind(this)();\n}\n\nx = new Sub();\nx.add(5,7)                  // 11\n\n=====================================\n\n例子2：\n\n若只想继承父级构造函数某一个具体方法\n需要先将父子对象都实例化后 调用父级的具体方法call\n\nfunction Add(a,b)\n{\n    this.add = function(a,b){\n        alert(a+b)\n    };\n    this.xx = 333;\n}\nfunction Sub()\n{\n    this.sub = '张三';\n}\n\nnewAdd = new Add(7,8);\nnewSub = new Sub();\n\n// Sub只继承了Add的add方法并执行相关方法\n\ncall方法：\nnewAdd.add.call(newSub, 10, 4);      // 14\n\napply方法：\nnewAdd.add.apply(newSub, [10, 4]);   // 14\n\nbind方法：\nnewAdd.add.bind(newSub, 10, 4)();   // 14\n\n```\n\n>\n\n> > **注意**\n> >\n> > > 若想要全部继承父级所有相关属性 得采用==原型链继承==的方式\n\n```\nfunction person(){\n    this.hair = 'black';\n    this.eye = 'black';\n    this.skin = 'yellow';\n    this.view = function(){\n        return this.hair + ',' + this.eye + ',' + this.skin;\n    }\n}\nfunction man(){\n    this.feature = ['beard','strong'];\n}\nman.prototype = new person();\n\n```\n\n---\n\n## 13. cookie sessionStorage localStorage\n\n    1. cookie\n        * 4k的限制；\n        * 服务端和客户端传递时都会带上cookie；\n        * 本质上是对字符串的读取 存储内容过多消耗内存空间 导致页面变卡顿；\n        * 不能被爬虫读取；\n        * 设置时间之前一直有效，到时间就清除；\n    2. sessionStorage\n        * 临时存储：引入“浏览器窗口”的概念，同源同窗口数据不会销毁，不同标签页中数据不能共享，关闭浏览器时候销毁；\n        * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n        * 性能更好，即本地读取数据比服务器获取快多了；\n        * 不能跨tab标签页传值；\n    3. localStorage\n        * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n        * 体积更大 5M；\n        * 持久存储在本地，直到手动清除；\n\n```\nlocalStorage.setItem('sss',1111);\nlocalStorage.getItem('sss');\nlocalStorage.removeItem('sss');\nlocalStorage.clear();\n```\n\n---\n\n## 14. 闭包\n\n    简单回答闭包就是 一个函数返回自身内部函数的调用\n\n    为什么使用？\n\n    因为js是链式的 一层一层向上级查找 所以外部函数无法访问内部函数;\n\n> > 优点\n>\n> - 可以读取函数内部的变量，外部无法访问到里面变量;\n> - 函数在执行完毕不会被销毁 而是一直存在内存中;\n\n> > 缺点\n>\n> - 不会被内存回收 容易出现性能问题\n\n```\nfunction foo(){\n    var a = 2;\n\n    function bar(){\n        console.log(a);\n    }\n\n    return bar;\n}\nvar newFoo = foo();\nnewFoo();               // a\n\n```\n\n---\n\n## 15. 深拷贝和浅拷贝\n\n- **浅拷贝**\n  > **复制对象的副本 指向同一内存区域 对副本的操作会影响父级对象**\n\n浅拷贝方式：\n\n1. 直接赋值；\n2. Object.assign();\n3. JSON 序列化；\n\n- **深拷贝**\n  > **复制对象的副本 指向不同的内存区域 与父级对象独立**\n\n```\n// 浅拷贝\nvar a = {\n    name : 'zhangsan'\n}\n\nvar b = a;\nb.name = 'lisi';\n\nconsole.log(a.name);    // \"lisi\"\nconsole.log(b.name);    // \"lisi\"\n\n// 深拷贝  (更完整的深拷贝还需要再详细优化)\nfunction deepCopy(p, c){\n    var c = c || {};\n    for(var i in p ){\n        // 数组和对象的时候再处理\n        if(typeof p[i] === 'object'){\n            c[i] = (p[i].constructor === Array) ? [] : {};\n            deepCopy(p[i], c[i]);\n        }else{\n            // 基本类型直接赋值\n            c[i] = p[i]\n        }\n    }\n    return c;\n}\n\nvar parent = {\n    number: [1, 2, 3],\n    obj: {\n        prop: 1\n    }\n}\n\nvar copyParent = deepCopy(parent);\ncopyParent.number.push(4)\ncopyParent.number                   // 1,2,3,4\nparent.number                       // 1,2,3\n```\n\n---\n\n## 16. 传值类型和引用类型\n\n- **传值类型（基本类型）**\n  > 值为基本类型时候为深拷贝\n  >\n  > > 基本类型就是 null，undefined，Boolean，string，number\n  > >\n  > > > ==独立不干扰==\n- **引用类型**\n  > 值为对象类型时候为浅拷贝\n  >\n  > > 值都是对对象的引用，即一个指向对象的指针\n  > >\n  > > > ==对副本的操作会影响父级对象==\n\n```\n// 传值类型\nvar  a = 1;\nfunction voo(data)\n{\n    data = 2;\n    console.log(data);   // 2\n}\nvoo(a);\nconsole.log(a);    // 1\n\n// 引用类型\nvar  a = {\n    name : \"张三\"\n};\nfunction voo(data)\n{\n    data.name = \"李四\";\n    console.log(data);   //  Object {name: \"李四\"}\n}\nvoo(a);\nconsole.log(a);         //  Object {name: \"李四\"}\n\n// 引用类型不会被基本类型覆盖\nvar  a = {\n    name : \"张三\"\n};\nfunction voo(data)\n{\n    data = 3；\n    console.log(data);   // 3\n}\nvoo(a);\nconsole.log(a);         //  Object {name: \"张三\"}\n\n// 为了解决引用类型的问题  引入深拷贝的概念  参考上面一个概念\n\n```\n\n---\n\n## 17. 函数作用域提升与预编译\n\n> 由于 js 没有其他强类型语言{}这类的块级作用域 只有函数作用域 函数的声明很随意导致各种问题出现\n>\n> > 变量预编译 > 函数预编译\n\n```\n// 第一条\n\na();\nvar a = c = function() {\n    console.log(2)\n};\na();\n\nfunction a() {\n    console.log(1)\n};\na();\n(function(b) {\n    b(), c()\n    var b = c = function a() {\n        console.log(3)\n    }\n    b();\n})(a);\nc();\n\n// 等价于：\nvar a;                      // 变量声明提升\nfunction a() {              // 函数声明提升\n    console.log(1)\n};\na();                        // 1\na = c = function() {\n    console.log(2)\n};\n\na();                        // 2\n\n(function(b) {\n    var b\n    b()                     // 2\n    c()                     // 本来以error\n    // 后来有人指正 原因就在于var b=c=xxx。\n    // c相当于没有加var 不会预编译，这里c直接查找到外部作用域的c\n    b = c = function a() {\n        console.log(3)\n    }\n    b();                    // 3\n})(a);\n\nc();                        // 3\n\n\n// 第二条\nfunction fn(){\n    function a(){console.log(1)}\n    return a;\n    function a(){console.log(2)}\n}\nfn()();                     //2 由于预编译 后面的a覆盖了前面的a\n\n// 第三条\nvar a=10;\nfunction fn(){\n    // 预编译a 赋值undefined，内部作用域存在a这个变量，\n    // 所以这里 !a 就是  !undefined，就是true，进入函数a=20;\n    if (!a) {\n        var a=20\n    }\n    console.log(a)          //  这里是20 ，\n}\nfn()\n\n// 第四条\n<script>\n    console.log(typeof a)   //undefined\n    var a='littlebear';\n    console.log(a)          //littlebear\n</script>\n<script>\n    console.log(typeof a)   //string  第二个<script>标签里的a但会往上查找。\n    var a=1;\n    console.log(a)//1\n</script>\n\n// 第五条\n<script>\n    console.log(typeof a)   //undefined\n    console.log(a)\n    // 报错，遇到<script>标签对时，会先对这一块进行预解析，\n    // 下面没预解析，所以找不到声明过的a，于是报错了\n</script>\n<script>\n    console.log(typeof a)   //undefined\n    var a=1;\n    console.log(a)          //1\n</script>\n\n// 第六条\n<script>\n    function fn(a,b){\n        console.log(a)      //容易上当 初始化a的时候已经赋值'容易上当'\n        var a=10;\n        console.log(a)      //10\n    }\n    fn('容易上当');\n</script>\n\n```\n\n---\n\n## 18. AMD 和 CMD 区别\n\n1. AMD 推崇依赖前置。 （requireJS）\n\n   CMD 推崇依赖就近， （seaJS）\n\n```\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a')\n    a.doSomething()         // 此处略去 100 行\n    var b = require('./b')  // 依赖可以就近书写\n    b.doSomething()         // ...\n\n})\n// AMD 默认推荐\ndefine(['./a', './b'], function(a, b) {\n    // 依赖必须一开始就写好\n    a.doSomething()    // 此处略去 100 行\n    b.doSomething()\n})\n```\n\n2.  对于依赖的模块，\n\n    AMD 是提前执行（预执行），\n\n    CMD 是延迟执行（懒执行）。\n\n> 不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n3.  AMD 的 API 默认是一个当多个用，\n\n    CMD 的 API 严格区分，推崇职责单一\n\n> 比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。\n\n---\n\n## 19. 常见服务器的状态码\n\n- 304\n\n  Not Modified\n\n  客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n\n- 400\n\n  Bad Request\n\n  表示该请求报文中存在语法错误，导致服务器无法理解该请求。\n\n- 403\n\n  Forbidden\n\n  该状态码表明对请求资源的访问被服务器拒绝了。\n\n- 500\n\n  Internal Server Error\n\n  该状态码表明服务器端在执行请求时发生了错误。\n\n- 502\n\n  上游网关错误\n\n- 301\n\n  永久重定向\n\n- 302\n\n  临时重定向 会出现 URL 劫持 体现在搜索引擎收录策略上 会改变原有请求方法\n\n- 307\n\n  临时重定向 与 302 区别 客户端应`保持请求方法`不变向新的地址发出请求\n\n---\n\n## 20. 事件冒泡和事件捕获\n\n    * 事件冒泡兼容写法\n\n    ```\n    if (event.cancelBubble) {\n        event.cancelBubble = true\n    } else {\n        event.stopPropagation()\n    }\n    ```\n    --------------------------\n\n## 21. 数组\n\n    1. push\n\n        向数组末尾添加指定元素\n\n    2. pop\n\n        移除数组末尾的一个元素 并返回移除的元素\n\n    3. shift\n\n        移除数组第一项 并返回该元素\n\n    4. unshift\n\n        给数组第一项加上一个元素 返回数组长度\n\n    5. join\n\n        数组按照指定的字符换转成字符串\n\n    6. sort\n\n        数组按照ASCII排序  所以要完全按照从小到大的顺序排序的话需要指定参数 1 -1 0\n\n    7. splice\n\n        从0开始\n\n    > 删除 ---------------------（**起始位置，截取个数**）\n\n    > 插入 ---------------------（**起始位置，截取个数为0，要插入的项**）\n\n    > 替换----------------------（**起始位置，截取个数为1，要插入的项**）\n\n    8. slice\n\n    9. concat\n\n    10. reverse\n\n    11. 遍历数组的方法\n\n        > forEach\n        > for in\n\n        两者区别 在于 for in 会遍历数组原型链的属性值\n\n        为了避免这样的情况 使用 hasOwnProperty 解决\n\n---\n\n## 22.正则\n\n- ()：小括号，叫做分组符。\n- \\s : 空格\n- \\S : 非空格\n- \\d : 数字\n- \\D : 非数字\n- \\w : 字符 ( 字母 ，数字，下划线\\_ )\n- \\W : 非字符\n- .（点）——任意字符\n- \\. : 真正的点\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- \\B : 非独立的部分\n- {n,m}：至少出现 n 次，最多 m 次\n- {n,} :至少 n 次\n- - :任意次 相当于{0,}\n- ？ ：零次或一次 相当于{0,1}\n- - ：一次或任意次相当于 {1,}\n- {n}： 正好 n 次\n- [] ： 表示某个集合中的任意一个 不能为空\n\n---\n\n> ### 字符串相关的正则方法\n\n- ### match()\n\n> 返回一个包含匹配内容的数组\n\n```\nvar str = 'abcdef';\n\nvar re = /B/i;\n\nstr.match(re) // [b]\n```\n\n例子 2：\n\n```\nurl = https://dimg.fws.qa.nt.ctripcorp.com/images/2d090m000000062hy59E5.jpg\"\nurl.match(/[^\\/]*$/) // 2d090m000000062hy59E5.jpg\nurl.match(/^[^\\/]*/) // https\n```\n\n- ### search()\n\n> 返回匹配到的第一个内容所在的位置\n\n```\nvar str = 'abcdef';\n\nvar re = /B/i;\n\nstr.search(re) // 1\n\n```\n\n- ### replace()\n\n> 查找符合正则的字符串并替换成==一个==对应的字符串。返回替换后的内容。\n\n```\nvar str = \"我爱北京天安门，天安门上太阳升。\";\nvar re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配\nvar str2 = str.replace(re,'*'); // 我爱**，*上太阳升。\n\n```\n\n并不能解决一个文字\\*的对应\n\n```\nvar str = \"我爱北京天安门，天安门上太阳升。\";\nvar re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配\nvar str2 = str.replace(re,function(str){\n            alert(str);\n            //用来测试：参数代表每次搜索到的符合正则的字符，\n            //所以第一次str指的是北京 第二次str是天安门 第三次str是天安门\n            var result = '';\n            for(var i=0;i<str.length;i++){\n                result += '*';\n            }\n            return result; //所以搜索到了几个字就返回几个*\n        });\nalert(str2)\n```\n\n    ```\n    var str = '2013-6-7';\n    var re = /(\\d+)(-)/g;\n\n    str = str.replace(re,function($0,$1,$2){\n            // replace()中如果有子项，\n            // 第一个参数 ：$0（匹配成功后的整体结果  2013-  6-）,\n            // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n            // 第三个参数 : $2(匹配成功的第二个分组，这里指的是-    - - )\n        return $1 + '.';  //分别返回2013.   6.\n    });\n\n    alert( str );   //2013.6.7\n    //整个过程就是利用子项把2013- 6- 分别替换成了2013. 6.  最终弹出2013.6.7\n    ```\n\n---\n\n### 正则两个方法\n\n- ### test()\n\n> 匹配到指定内容返回 true\n\n- ### ==exec()==\n\n> 返回第一匹配项信息的数组 若没有返回 null\n> 有两个属性 index input\n\n    ```\n    var text = 'mom and dad and baby'\n    var pattern = /mom( and dad( and baby)?)?/gi\n    var matches = pattern.exec(text)\n    mathes.index // 0\n    mathes.input // mom and dad and baby\n    mathes[0] // mom and dad and baby\n    mathes[1] //  and dad and baby\n    mathes[2] // and baby\n    ```\n\n## 23. 后退监听\n\n> history.back() history.forward() history.replace()触发 onpopstate 事件\n\n    ```\n    window.onpopstate = function () {\n        alert('2222')\n        history.pushState(null, null, document.URL)\n        return false\n    }\n    history.pushState(null, null, document.URL)\n    ```\n\n    onbeforeunload事件有坑 chrome51版本及以后不能自定义文字 并且 页面载入之后一定要有浏览器行为才能触发\n\n## 24. base64 图片及相关验证码\n\n> data:image/gif;base64, (base64 地址)\n\n    ```\n    if (result == null || result.length == 0) return\n    result = $.parseJSON(result)\n    var id = result['id']\n    var imgUrl = result['base64Buffer']\n    $('#js-code').attr('src', 'data:image/gif;base64,' + imgUrl)\n\n    ```\n\n## 26. from 包裹的元素 document 事件失效 必须给 from 加事件\n\n## 27. 进制转换\n\n> 十进制转十六进制\n\n    ```\n    var s = 255\n    s.toString(16) // ff\n    ```\n\n> 十六进制转十进制\n\n    ```\n    parseInt('0xFF')   // 255\n    ```\n\n## 28. label 绑定事件一定要让事件委托到触发里面的 input\n\n    所以事件委托的时候直接监听input\n\n## 29. 跨域 post 请求转为 options 类型\n\n## 30. Math\n\n    1. Math.floor 向下舍入；\n    2. Math.ceil  向上舍入;\n    3. Math.cos   余弦;\n    4. Math.round 四舍五入;\n    5. Math.sin   正弦；\n    6. Math.tan   正切；\n\n## 31. isNaN\n\n    首先需要知道 '' == 0   'abc' != 0   [] == 0  [1] != 0   null == 0  {} != 0  undefined != 0\n\n    ```\n    isNaN('')   // false\n    isNaN(' ')  // false\n    isNaN('abc') // true\n    isNaN(undefined) // true\n    isNaN([])   // false\n    isNaN({})   // true\n    isNaN(null) // false\n\n    ```\n\n## 32. Boolen\n\n    首先需要知道  0 == false    1 == true  '' == false   undefined != false != true    null != false != true\n\n    ```\n    Boolean('') // false\n    Boolean('ssss') // true\n    Boolean([])  // true\n    Boolean([1,2])  // true\n    Boolen({})      // true\n    Boolen(null)    // false\n    Boolen(undefined)   // false\n    ```\n\n## 33. 解决回调地狱 （多级回调）\n\n    1. Promise\n\n    2. aSync/await\n\n    3. generator\n\n## 34. 字符串\n\n    1. slice\n\n        在 不修改目标数组 的情况下返回截取的指定元素（ **起始位置，截止位置**）\n\n        从0开始 ==不包含最后一个数值==\n\n        负数情况下 将负数加上自身长度得到的数值作为参数\n\n    2. substr\n\n        subdtr接收的是 起始位置 和 所要返回的字符串长度\n\n        在负数情况下  将第一个参数与字符串长度相加后的数值作为第一个参数\n\n    3. substring\n\n        默认会将较小的参数作为第一个参数\n\n        在 不修改目标数组 的情况下返回截取的指定元素 （ **起始位置，截止位置**）\n\n        负数当做0处理\n\n```\nlet test = 'abcdef'\ntest.slice(0, -1)   // abcde\ntest.slice(2, -3)   => test.slice(2,3)  // c\n\ntest.substring(1, -2) => a\ntest.substring(2, -3) => ab\n```\n\n    4. split\n\n        字符串按照指定规则转换成数组\n\n## 35. let 与 var 区别\n\n    1. var存在变量提升， let不存在；\n    2. let不允许重复声明；\n    3. var挂载在window下，let挂载在块作用域下；\n\n## 36. 为什么 var 可以重复声明\n\n    因为js运行过程中，\n\n    引擎 负责整个代码编译和运行\n\n    编译器 负责词法分析、语法分析、代码生成等工作\n\n    编译器从左至右编译var a，如果a不存在则在作用域声明一个新的变量a，若存在a则忽略继续向下编译；\n\n    引擎遇到a = 2，按照作用域链向上查找 若存在变量a直接赋值，不存在则在作用域重新声明新的变量并赋值2\n\n## 37. CommonJS 中的 require/exports 和 ES6 的 import/export 有什么区别\n\n1.\n\n> CommomJS 模块 require 代码时候会立刻执行；\n\n> ES6 模块是动态引用，不会立刻执行，仅仅作为一个加载模块的对象引用；\n\n2.\n\n> CommonJs 模块输出的是一个值的拷贝， 输出后的对象会被缓存（即 如果发现一个模块被多次引用，会直接返回已经执行的部分）；\n\n```\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n```\n\n```\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n\n```\n\n> ES6 模块输出的是值的只读引用；\n\n- 接口输出的变量是只读的，重新赋值会报错；\n- export 通过接口输出的是同一个值，得到的都是同样的实例；\n- 如果需要 import 支持动态加载 提案建议引入 import() 返回一个 promise 对象；\n\n参考资料：\n\n1. [ES6 模块与 CommonJS 模块的差异 ](http://es6.ruanyifeng.com/#docs/module-loader)\n\n## 38. 浏览器缓存\n\n    浏览器缓存分为 强缓存 和 协商缓存\n\n    1. 客户端先根据资源的http header判断是否命中强缓存，如果命中直接从缓存中读取；\n\n    2. 强缓存未命中，客户端发出请求，服务端根据请求的request header验证资源是否命中协商缓存，这个过程成为http再验证。如果命中，服务器将请求返回，状态码304，但不返回资源，而是告诉客服端可以从缓存读取；\n\n    3. 当协商缓存也没有命中，直接服务端返回资源给客户端；\n\n\n    强缓存\n\n    1. Expires 代表缓存过期时间；\n\n    2. Cache-Control： max-age  代表缓存最大生命周期；\n\n    协商缓存\n\n    1. Last-Modified 代表资源最后更新时间；\n\n    2. If-Modified-Since 代表 判断两次请求之间是否有过修改 没有直接返回协商缓存；\n\n## 39. 处理 js 双精度问题\n\n    ```javascript\n        0.1 + 0.2 = 0.30000000000000004\n    ```\n\n由于计算机是做二进制运算\n\n0.1 => 0.0001 1001 1001 1001…（无限循环）\n\n0.2 => 0.0011 0011 0011 0011…（无限循环）\n\n双精度浮点数的小数部分最多支持 52 位\n\n处理方法：\n\n    1. toFixed  不够严谨；\n    2. 把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。\n\n    ```javascript\n    ;(0.1 * 10 + 0.2 * 10) / 10 == 0.3\n    ```\n\n1. [个人封装的处理双精度方法 第 7 点](https://github.com/Megan-TA/UtilsJS)\n\n2. [关于 js 浮点数计算精度不准确问题的解决办法](https://www.cnblogs.com/xinggood/p/6639022.html)\n\n## 40. postMessage\n\n1. window.postMessage() 可以安全进行跨域、跨页面通信；\n1. 页面加载完成后才能进行跨域通信；\n\n发起端可以是 open 一个新窗口 或者 创建一个 iframe 往新窗口里发送数据\n\n案例:\n\n    ```javascript\n\n<!-- 客户端两种方式 -->\n\n<!-- 当前页面地址 http://www.webhek.com -->\n<!-- open方式 -->\n\n//弹出一个新窗口\nvar domain = 'http://fanyi.youdao.com';\nvar myPopup = window.open(domain, 'myWindow');\n\n//周期性的发送消息\nsetInterval(function(){\nvar message = 'Hello! The time is: ' + (new Date().getTime());\nconsole.log('blog.local: sending message: ' + message);\n//send the message and target URI\nmyPopup.postMessage(message,domain);\n},6000);\n\n<!-- iframe方式 -->\n\n//捕获 iframe\nvar domain = \"http://fanyi.youdao.com\";\nvar iframe = document.getElementById('myIFrame').contentWindow;\n\n//发送消息\nsetInterval(function(){\nvar message = 'Hello! The time is: ' + (new Date().getTime());\nconsole.log('blog.local: sending message: ' + message);\n//send the message and target URI\niframe.postMessage(message,domain);\n},6000);\n\n<!-- 接收端 -->\n\n//监听消息反馈\nwindow.addEventListener('message',function(event) {\nif(event.origin !== 'http://www.webhek.com') return;\nconsole.log('received response: ',event.data);\n},false);\n\n    ```\n\n> 截图如下：\n\n![web骇客网站  接收端截图](https://wx4.sinaimg.cn/mw690/006ANKB8gy1fqhqrhftfmj30yu0objvr.jpg)\n![有道翻译网站 接收端截图](https://wx2.sinaimg.cn/mw690/006ANKB8gy1fqhqri8fjlj30zk0h4tbk.jpg)\n\n> 参考资料\n\n1. [用 HTML5 里的 window.postMessage 在两个网页间传递数据](http://www.webhek.com/post/window-postmessage-api.html)\n\n## 41. Service Worker\n\n> 背景\n\n为了解决 web 业务不断增加带来更多消耗资源、耗时等复杂运算带来性能问题，w3c 初期提出 Web Worker 的 API，目的为了解放主线程。原理是 将复杂 耗时的操作独立出来交给 Web Worker，完成后通过 postMessage 方法告诉主线程。\n\n缺点：临时存在，不能永久；为此提出 Service Worker，在 Web Worker 基础上增加持久缓存能力。\n\n在 Service Worker 之前有 APPCache 这个持久缓存的 API，不过存在更新机主不完善，二次更新，大小限制，回滚等问题，具体参考下方链接 1。\n\nService Worker 的特性如下：\n\n- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n\n- 一旦被 install，就永远存在，除非被 uninstall\n\n- 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\n\n- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n\n- 离线内容开发者可控\n\n- 能向客户端推送消息\n\n- 不能直接操作 DOM\n\n- 出于安全的考虑，必须在 HTTPS 环境下才能工作\n\n- 异步实现，内部大都是通过 Promise 实现\n\n- 只能运行在 HTTPS 协议下\n\n> 参考资料\n\n1. [为什么 app cache 没有得到大规模应用？它有哪些硬伤吗？](https://www.zhihu.com/question/29876535)\n2. [Service Worker 简介](https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction)\n3. [如何优雅的为 PWA 注册 Service Worker](https://zhuanlan.zhihu.com/p/28161855)\n\n## 42 加载更多/下拉刷新\n\n原理：\n\nscrollTop（滚动条滚动距离） + clientHeight（可见区域高度） == scrollHeight（元素实际高度）\n\n备注：\n\noffsetHeighgt = height + padding + border\n\nclientHeight = height + padding\n\n## 43. js 标签中`async`和`defer`的作用与区别\n\n作用：\n\n1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。\n\n2.async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。\n\n3.defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。\n\n区别：\n\ndefer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。\n在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。\n","slug":"js知识点总结","published":1,"updated":"2019-08-30T06:12:20.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck28rx5ob0023h91pf89mwrf2","content":"<h1><span id=\"js-知识点总结\">js 知识点总结</span></h1>\n<h2><span id=\"1-解码和编码\">1. 解码和编码</span></h2>\n<blockquote>\n<p>原因：因为链接里面会有中文或者特殊字符号无法跳转需要进行相关编码解码</p>\n</blockquote>\n<p><strong>编码</strong></p>\n<blockquote></blockquote>\n<pre><code>'encodeURI': 只对查询的参数做编码\n\n'encodeURIComponent': 对整个url做编码，包括? &amp; / #\n</code></pre>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">'www.baidu.com/test?name=\"zhangsan\"'</span></span><br><span class=\"line\"><span class=\"built_in\">encodeURI</span>(a) =&gt; <span class=\"string\">'www.baidu.com/test?name=%22zhangsan%22'</span></span><br><span class=\"line\"><span class=\"built_in\">encodeURIComponent</span>(a) =&gt; <span class=\"string\">'www.baidu.com%2Ftest%3Fname%3D%22zhangsan%22'</span></span><br></pre></td></tr></table></figure>\n<p><strong>解码</strong></p>\n<blockquote></blockquote>\n<pre><code>'decodeURI': 只对查询参数做解码\n'decodeURIComponent': 对整个URL做解码\n</code></pre>\n<hr>\n<h2><span id=\"2-序列化和反序列化\">2. 序列化和反序列化</span></h2>\n<blockquote></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify()        // 序列化</span><br><span class=\"line\">JSON.parse()            // 反序列化</span><br></pre></td></tr></table></figure>\n<p>使用 ajax 需要设置请求头部信息</p>\n<p>header: {‘Content-Type’: ‘application/json; charset=utf-8;’}</p>\n<blockquote>\n<p>JSON.stringify() 可以简单的用来迅速判断两个对象是否相等，但不严谨（比如：序列化失败）</p>\n</blockquote>\n<hr>\n<h2><span id=\"3-日期\">3. 日期</span></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Date().getTime()   // 单位  秒</span><br><span class=\"line\">// 获取当前时间   （存在兼容性）</span><br><span class=\"line\">new Date().toLocaleDateString() // 2017/7/24</span><br><span class=\"line\">new Date().toLocaleTimeString() // 下午5:07:33</span><br><span class=\"line\">new Date().toLocaleString()     // 2017/7/24 下午5:07:33</span><br><span class=\"line\">// 若要显示24进制 需要option选项</span><br><span class=\"line\">new Date().toLocaleTimeString(&quot;UTC&quot;,&#123; hour12: false &#125;)  // 17:20:16</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"4-回流重绘\">4. 回流/重绘</span></h2>\n<ol>\n<li>\n<p>回流：几何属性发生变化 比如：内容、结构、位置或尺寸发生变化，需要重新计算样式和渲染树；</p>\n</li>\n<li>\n<p>重绘：元素发生的改变只影响了节点的一些样式（背景色、边框色、文字颜色等）</p>\n</li>\n</ol>\n<blockquote>\n<p>回流比重绘要消耗更多的资源</p>\n</blockquote>\n<hr>\n<h2><span id=\"5-锚点定位-scrollintoview-无兼容问题\">5. 锚点定位 scrollIntoView （无兼容问题）</span></h2>\n<p>可以用来做一些 tab 定位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;xx&apos;).scrollIntoView()</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"6-typeof-和-instanceof\">6. typeof 和 instanceof</span></h2>\n<blockquote>\n<h3><span id=\"typeof\">typeof</span></h3>\n</blockquote>\n<p>会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,function；</p>\n<p>缺点：</p>\n<ul>\n<li>不适用于来判断数组，因为不管是数组还是对象，都会返回 object。</li>\n<li>判断不了 null null 也是对象</li>\n</ul>\n<blockquote></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof [1]      // Object</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h3><span id=\"instanceof\">instanceof</span></h3>\n</blockquote>\n<p>返回的是一个布尔值 只能用来判断对象和函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;&#125;;</span><br><span class=\"line\">alert(  a instanceof Object )     // true</span><br><span class=\"line\">var a  = [];</span><br><span class=\"line\">alert(  a instanceof Array )    // true</span><br></pre></td></tr></table></figure>\n<p>最靠谱也是最方便的办法使用<code>Object.prototype.toString.call()</code>来判断</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">types</span>(<span class=\"params\">target</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"7-requestanimationframe-raf-动画-api-兼容-ie-89\">7. requestAnimationFrame （RAF） 动画 api 兼容 Ie 8/9</span></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i = 0</span><br><span class=\"line\"></span><br><span class=\"line\">window.requestAnimFrame = (function()&#123;</span><br><span class=\"line\">  return  window.requestAnimationFrame       ||</span><br><span class=\"line\">          window.webkitRequestAnimationFrame ||</span><br><span class=\"line\">          window.mozRequestAnimationFrame    ||</span><br><span class=\"line\">          function( callback )&#123;</span><br><span class=\"line\">            window.setTimeout(callback, 1000 / 60);</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\">requestAnimFrame(animloop)</span><br><span class=\"line\"></span><br><span class=\"line\">function animloop () &#123;</span><br><span class=\"line\">    document.getElementById(&apos;test&apos;).style.top = i ++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"优点\">优点</span></h3>\n<pre><code>1. 解决毫秒的不精确性；\n2. 避免过渡渲染；\n3. 浏览器可以优化并行的动画动作，将合并的动作放入一个渲染周期；\n4. 过程可控；\n</code></pre>\n<blockquote>\n<p>动画效率之争</p>\n</blockquote>\n<pre><code>css3动画高效的原因有以下三点：\n\n    1. 强制使用硬件加速（GPU）；\n    2. 使用与RAF类似的机制；\n    3. 优化DOM操作 避免内存消耗来减少卡顿；\n\n同时因为采用GPU， 导致浏览器一直出于高负荷运转，移动端电量损耗和一定卡顿，\n而且css不能完全被js控制\npc上兼容性\n</code></pre>\n<p>js 动画库 （比如 Velocity.js 和 GSAP）</p>\n<hr>\n<h2><span id=\"8-跨域\">8. 跨域</span></h2>\n<ol>\n<li>\n<h3><span id=\"jsonp\">JSONP</span></h3>\n<blockquote>\n<p>通过 js 标签引入一个 js 文件 这个 js 文件载入成功之后会执行我们在 url 参数中指定的函数 并且会吧我们需要的 json 数据作为参数传入</p>\n<p>例如：url?item=1&amp;callback=filter</p>\n<p>== 原生 js 实现 jsonp 的话 定义好 callback 的函数名称,动态创建 js 标签 url 加上查询的参数写好 callback 的回调函数名称即可 ==</p>\n</blockquote>\n</li>\n<li>\n<h3><span id=\"利用-iframe-并修改-documentdomain-来跨子域\">利用 iframe 并修改 document.domain 来跨子域</span></h3>\n<p>两个不同域的页面引入 iframe 标签 同时将两个页面的主域设置成相同的域名</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox669ialYSHxewnD1B4L5UibVqhMnFEfibLhA8vUQu2s9rltB2HZ6UTQ19iag/0?wx_fmt=png\" alt=\"页面1\"><br>\n<img src=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6Kv2iaHanjIzQHDNeia2FsoHSz8AJPkxh0IqickdbPg0CPeFPhoQMpuv5w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"页面2\"></p>\n</li>\n<li>\n<h3><span id=\"windowname-可以配合-iframe\"> （可以配合 iframe）</span></h3>\n<p>同源窗口下 <a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 对所有页面都是共享的</p>\n<p>每个页面对 <a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 都有读写权限</p>\n<p><a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 的值并不会因为新页面而重置</p>\n</li>\n<li>\n<p>widnow.postMessage （存在兼容性 IE7/8 不支持）</p>\n<p>！<a href=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6z8ibxywKPEusvEA2xS8ialrQ1Oxd0jw0V8C6f7Gicy6Obsyt5bicibxdx5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"noopener\">页面 1</a></p>\n<p>！<a href=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6B9Fpsa9KmNAMibvfSqE8Qv2icpLzzFE6NfvEp8YxWW6JOMTacIzaQzxw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"noopener\">页面 2</a></p>\n</li>\n<li>\n<p>Nginx 反向代理</p>\n</li>\n</ol>\n<h2><span id=\"9-selection\">9. selection</span></h2>\n<blockquote>\n<p>获取鼠标划过文本的对象</p>\n</blockquote>\n<blockquote>\n<p><code>window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();</code></p>\n</blockquote>\n<hr>\n<h2><span id=\"10-正则表达式\">10. 正则表达式</span></h2>\n<blockquote>\n<p>常用规则</p>\n</blockquote>\n<ul>\n<li>\\n 回车</li>\n<li>\\t 制表符</li>\n<li>\\r 换行符</li>\n<li>\\s 空格</li>\n<li>\\u4e00-\\u9fa5 中文</li>\n<li>\\w 大小写字母_数字</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>{n, m} 至少出现 n 次 最多 m 次</li>\n<li>{n,} 至少 n 次</li>\n<li>\n<ul>\n<li>任意次</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>至少一次</li>\n</ul>\n</li>\n<li>{n} 至少 n 次</li>\n<li>() 分组符号</li>\n<li>[\\s\\S] 任意字符</li>\n<li>^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。</li>\n<li>正则的最后位置 , 就代表结束的意思</li>\n</ul>\n<p>匹配中文: [\\u4e00-\\u9fa5]</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-</span><br><span class=\"line\">var re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-</span><br><span class=\"line\">var re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------</span><br><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //replace()中如果有子项，</span><br><span class=\"line\">    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[] 表示某个集合中的任意一个</li>\n<li>[^a] 排除 a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var re = /\\bclassname\\b/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会</span><br><span class=\"line\">// 把classname当做一个字符串去匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">var re = new RegExp(&apos;\\\\b&apos;+classname+&apos;\\\\b&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配的时候，classname前面必须是起始或者空格，后面也是。</span><br><span class=\"line\"></span><br><span class=\"line\">默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"11-object\">11. Object</span></h2>\n<pre><code>1. constructor\n\n    实例的constructor 永远指向 构造函数 的 prototype.constructor\n\n    理解成 实例是基于构造函数原型链生成的对象\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function A(x)&#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newA = new A(name);</span><br><span class=\"line\"></span><br><span class=\"line\">此时：</span><br><span class=\"line\">newA.constructor == A.prototype.constructor;</span><br></pre></td></tr></table></figure>\n<pre><code>2. hasOwnProperty\n\n    判断对象上某个属性是否属于自身 属于自身为true, 原型链上为false\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a () &#123;</span><br><span class=\"line\">    this.show = &apos;x&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.prototype.hide = function () &#123;</span><br><span class=\"line\">    console.log(111111);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var z = new a();</span><br><span class=\"line\">z.hasOwnProperty(&apos;show&apos;);          // true</span><br><span class=\"line\">z.hasOwnProperty(&apos;hide&apos;);          // false</span><br></pre></td></tr></table></figure>\n<pre><code>3. isPrototypeOf\n\n    判断一个对象是否是另一个对象的原型\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var monkey = &#123;</span><br><span class=\"line\">    hair : true,</span><br><span class=\"line\">    breathes : function()&#123;</span><br><span class=\"line\">        alert(&apos;1&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Human(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Human的原型链绑定monkey对象</span><br><span class=\"line\">Human.prototype = monkey;</span><br><span class=\"line\"></span><br><span class=\"line\">var man = new Human(&apos;张三&apos;);</span><br><span class=\"line\">monkey.isPrototypeOf(man);      // true</span><br></pre></td></tr></table></figure>\n<pre><code>4. prototype和__proto__\n\n    prototype是一个函数的内置属性（每个函数都有一个prototype属性）\n\n    __proto__ 是一个实例对象的内置属性 实例化的对象在内部通过此属性寻找原型链\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Person = function () &#123;&#125;</span><br><span class=\"line\">var zhangsan = new Person ()</span><br><span class=\"line\"></span><br><span class=\"line\">zhansan.__prop__ = Person.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">new 的过程拆分成以下三步</span><br><span class=\"line\"></span><br><span class=\"line\">1. var p = &#123;&#125;</span><br><span class=\"line\">2. p.__proto__ = Person.prototype</span><br><span class=\"line\">3. Person.call(p)</span><br></pre></td></tr></table></figure>\n<pre><code>5. Object.getPrototypeOf\n\n    获取 实例化对象 原型链 的相关属性\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Test () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test.prototype.showName = function () &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj = new Test ()</span><br><span class=\"line\">Object.getPrototypeOf(obj) == obj.__proto__</span><br></pre></td></tr></table></figure>\n<pre><code>6. Object.keys\n\n    可以用来枚举可遍历的属性 返回一个数组\n\n7. Object.create\n\n    在原型链上创建对象属性\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 属性创建在原型链上 --&gt;</span><br><span class=\"line\">Object.create(&#123;</span><br><span class=\"line\">    name: &apos;张三&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 字面量方式创建的对象属性挂在自身 --&gt;</span><br><span class=\"line\">let test = &#123;</span><br><span class=\"line\">    name: &apos;张三&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>8. Object.isExtensible\n\n    判断对象是否可以新增属性\n\n9. Object.preventExtension\n\n    锁住对象 使其不能新增属性 但是原来的属性可以修改删除\n\n10. Object.seal\n\n    密封对象 不能增加新属性 也不能删除旧属性  但是能修改原来的属性\n\n11. Object.isSealed\n\n    判断对象是否密封\n\n12. Object.freeze\n\n    冻结对象 不能新增 不能修改 不能删除\n\n13. Object.isFrozen\n\n    判断对象是否完全被冻结\n\n14. Object.getOwnPropertyNames\n\n    获取自身属性名字 返回一个数组\n\n15. Object.getOwnPropertyDescriptor\n\n    判断某个对象上某个属性的状态描述\n\n16. Object.defineProperty\n\n\n\n\n-----------\n</code></pre>\n<h2><span id=\"12-继承\">12. 继承</span></h2>\n<blockquote>\n<p><strong>调用另一个对象的方法，以另一个对象替换当前对象的上下文</strong></p>\n<blockquote>\n<p>缺点</p>\n<blockquote>\n<p>只能继承父级本身属性，原型链的属性无法继承</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li><strong>call</strong>\n<blockquote>\n<p>第二个参数可以省略</p>\n</blockquote>\n</li>\n<li><strong>apply</strong>\n<blockquote>\n<p>第二个参数必须是数组或者用 arguments 代替</p>\n</blockquote>\n</li>\n<li><strong>bind</strong>\n<blockquote>\n<p>bind 与 call 和 apply 的区别在于 bind 是一个函数 不会立即执行 必须在后面再加上一对括号去立即执行</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子1：</span><br><span class=\"line\"></span><br><span class=\"line\">function Add(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.add = function(a,b)&#123;</span><br><span class=\"line\">        alert(a+b)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.xx = 333;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.sub = &apos;张三&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // call方法</span><br><span class=\"line\">    Add.call(this); // call继承Add所有方法(不包含原型链上的方法)</span><br><span class=\"line\"></span><br><span class=\"line\">    // apply方法  参数不能指定的时候用[]或者arguments代替</span><br><span class=\"line\">    Add.apply(this, [])</span><br><span class=\"line\">    // 又可以写成</span><br><span class=\"line\">    Add.apply(this, arguments)</span><br><span class=\"line\"></span><br><span class=\"line\">    // bind方法</span><br><span class=\"line\">    Add.bind(this)();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">x = new Sub();</span><br><span class=\"line\">x.add(5,7)                  // 11</span><br><span class=\"line\"></span><br><span class=\"line\">=====================================</span><br><span class=\"line\"></span><br><span class=\"line\">例子2：</span><br><span class=\"line\"></span><br><span class=\"line\">若只想继承父级构造函数某一个具体方法</span><br><span class=\"line\">需要先将父子对象都实例化后 调用父级的具体方法call</span><br><span class=\"line\"></span><br><span class=\"line\">function Add(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.add = function(a,b)&#123;</span><br><span class=\"line\">        alert(a+b)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.xx = 333;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.sub = &apos;张三&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">newAdd = new Add(7,8);</span><br><span class=\"line\">newSub = new Sub();</span><br><span class=\"line\"></span><br><span class=\"line\">// Sub只继承了Add的add方法并执行相关方法</span><br><span class=\"line\"></span><br><span class=\"line\">call方法：</span><br><span class=\"line\">newAdd.add.call(newSub, 10, 4);      // 14</span><br><span class=\"line\"></span><br><span class=\"line\">apply方法：</span><br><span class=\"line\">newAdd.add.apply(newSub, [10, 4]);   // 14</span><br><span class=\"line\"></span><br><span class=\"line\">bind方法：</span><br><span class=\"line\">newAdd.add.bind(newSub, 10, 4)();   // 14</span><br></pre></td></tr></table></figure>\n<blockquote></blockquote>\n<blockquote>\n<blockquote>\n<p><strong>注意</strong></p>\n<blockquote>\n<p>若想要全部继承父级所有相关属性 得采用==原型链继承==的方式</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function person()&#123;</span><br><span class=\"line\">    this.hair = &apos;black&apos;;</span><br><span class=\"line\">    this.eye = &apos;black&apos;;</span><br><span class=\"line\">    this.skin = &apos;yellow&apos;;</span><br><span class=\"line\">    this.view = function()&#123;</span><br><span class=\"line\">        return this.hair + &apos;,&apos; + this.eye + &apos;,&apos; + this.skin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function man()&#123;</span><br><span class=\"line\">    this.feature = [&apos;beard&apos;,&apos;strong&apos;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">man.prototype = new person();</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"13-cookie-sessionstorage-localstorage\">13. cookie sessionStorage localStorage</span></h2>\n<pre><code>1. cookie\n    * 4k的限制；\n    * 服务端和客户端传递时都会带上cookie；\n    * 本质上是对字符串的读取 存储内容过多消耗内存空间 导致页面变卡顿；\n    * 不能被爬虫读取；\n    * 设置时间之前一直有效，到时间就清除；\n2. sessionStorage\n    * 临时存储：引入“浏览器窗口”的概念，同源同窗口数据不会销毁，不同标签页中数据不能共享，关闭浏览器时候销毁；\n    * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n    * 性能更好，即本地读取数据比服务器获取快多了；\n    * 不能跨tab标签页传值；\n3. localStorage\n    * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n    * 体积更大 5M；\n    * 持久存储在本地，直到手动清除；\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(&apos;sss&apos;,1111);</span><br><span class=\"line\">localStorage.getItem(&apos;sss&apos;);</span><br><span class=\"line\">localStorage.removeItem(&apos;sss&apos;);</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"14-闭包\">14. 闭包</span></h2>\n<pre><code>简单回答闭包就是 一个函数返回自身内部函数的调用\n\n为什么使用？\n\n因为js是链式的 一层一层向上级查找 所以外部函数无法访问内部函数;\n</code></pre>\n<blockquote>\n<blockquote>\n<p>优点</p>\n</blockquote>\n<ul>\n<li>可以读取函数内部的变量，外部无法访问到里面变量;</li>\n<li>函数在执行完毕不会被销毁 而是一直存在内存中;</li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>缺点</p>\n</blockquote>\n<ul>\n<li>不会被内存回收 容易出现性能问题</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function bar()&#123;</span><br><span class=\"line\">        console.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newFoo = foo();</span><br><span class=\"line\">newFoo();               // a</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"15-深拷贝和浅拷贝\">15. 深拷贝和浅拷贝</span></h2>\n<ul>\n<li><strong>浅拷贝</strong>\n<blockquote>\n<p><strong>复制对象的副本 指向同一内存区域 对副本的操作会影响父级对象</strong></p>\n</blockquote>\n</li>\n</ul>\n<p>浅拷贝方式：</p>\n<ol>\n<li>直接赋值；</li>\n<li>Object.assign();</li>\n<li>JSON 序列化；</li>\n</ol>\n<ul>\n<li><strong>深拷贝</strong>\n<blockquote>\n<p><strong>复制对象的副本 指向不同的内存区域 与父级对象独立</strong></p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 浅拷贝</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name : &apos;zhangsan&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a;</span><br><span class=\"line\">b.name = &apos;lisi&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.name);    // &quot;lisi&quot;</span><br><span class=\"line\">console.log(b.name);    // &quot;lisi&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 深拷贝  (更完整的深拷贝还需要再详细优化)</span><br><span class=\"line\">function deepCopy(p, c)&#123;</span><br><span class=\"line\">    var c = c || &#123;&#125;;</span><br><span class=\"line\">    for(var i in p )&#123;</span><br><span class=\"line\">        // 数组和对象的时候再处理</span><br><span class=\"line\">        if(typeof p[i] === &apos;object&apos;)&#123;</span><br><span class=\"line\">            c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class=\"line\">            deepCopy(p[i], c[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            // 基本类型直接赋值</span><br><span class=\"line\">            c[i] = p[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var parent = &#123;</span><br><span class=\"line\">    number: [1, 2, 3],</span><br><span class=\"line\">    obj: &#123;</span><br><span class=\"line\">        prop: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var copyParent = deepCopy(parent);</span><br><span class=\"line\">copyParent.number.push(4)</span><br><span class=\"line\">copyParent.number                   // 1,2,3,4</span><br><span class=\"line\">parent.number                       // 1,2,3</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"16-传值类型和引用类型\">16. 传值类型和引用类型</span></h2>\n<ul>\n<li><strong>传值类型（基本类型）</strong>\n<blockquote>\n<p>值为基本类型时候为深拷贝</p>\n<blockquote>\n<p>基本类型就是 null，undefined，Boolean，string，number</p>\n<blockquote>\n<p>==独立不干扰==</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li><strong>引用类型</strong>\n<blockquote>\n<p>值为对象类型时候为浅拷贝</p>\n<blockquote>\n<p>值都是对对象的引用，即一个指向对象的指针</p>\n<blockquote>\n<p>==对副本的操作会影响父级对象==</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 传值类型</span><br><span class=\"line\">var  a = 1;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data = 2;</span><br><span class=\"line\">    console.log(data);   // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);    // 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 引用类型</span><br><span class=\"line\">var  a = &#123;</span><br><span class=\"line\">    name : &quot;张三&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data.name = &quot;李四&quot;;</span><br><span class=\"line\">    console.log(data);   //  Object &#123;name: &quot;李四&quot;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);         //  Object &#123;name: &quot;李四&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 引用类型不会被基本类型覆盖</span><br><span class=\"line\">var  a = &#123;</span><br><span class=\"line\">    name : &quot;张三&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data = 3；</span><br><span class=\"line\">    console.log(data);   // 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);         //  Object &#123;name: &quot;张三&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 为了解决引用类型的问题  引入深拷贝的概念  参考上面一个概念</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"17-函数作用域提升与预编译\">17. 函数作用域提升与预编译</span></h2>\n<blockquote>\n<p>由于 js 没有其他强类型语言{}这类的块级作用域 只有函数作用域 函数的声明很随意导致各种问题出现</p>\n<blockquote>\n<p>变量预编译 &gt; 函数预编译</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一条</span><br><span class=\"line\"></span><br><span class=\"line\">a();</span><br><span class=\"line\">var a = c = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();</span><br><span class=\"line\"></span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();</span><br><span class=\"line\">(function(b) &#123;</span><br><span class=\"line\">    b(), c()</span><br><span class=\"line\">    var b = c = function a() &#123;</span><br><span class=\"line\">        console.log(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b();</span><br><span class=\"line\">&#125;)(a);</span><br><span class=\"line\">c();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等价于：</span><br><span class=\"line\">var a;                      // 变量声明提升</span><br><span class=\"line\">function a() &#123;              // 函数声明提升</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();                        // 1</span><br><span class=\"line\">a = c = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a();                        // 2</span><br><span class=\"line\"></span><br><span class=\"line\">(function(b) &#123;</span><br><span class=\"line\">    var b</span><br><span class=\"line\">    b()                     // 2</span><br><span class=\"line\">    c()                     // 本来以error</span><br><span class=\"line\">    // 后来有人指正 原因就在于var b=c=xxx。</span><br><span class=\"line\">    // c相当于没有加var 不会预编译，这里c直接查找到外部作用域的c</span><br><span class=\"line\">    b = c = function a() &#123;</span><br><span class=\"line\">        console.log(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b();                    // 3</span><br><span class=\"line\">&#125;)(a);</span><br><span class=\"line\"></span><br><span class=\"line\">c();                        // 3</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 第二条</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">    function a()&#123;console.log(1)&#125;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">    function a()&#123;console.log(2)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()();                     //2 由于预编译 后面的a覆盖了前面的a</span><br><span class=\"line\"></span><br><span class=\"line\">// 第三条</span><br><span class=\"line\">var a=10;</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">    // 预编译a 赋值undefined，内部作用域存在a这个变量，</span><br><span class=\"line\">    // 所以这里 !a 就是  !undefined，就是true，进入函数a=20;</span><br><span class=\"line\">    if (!a) &#123;</span><br><span class=\"line\">        var a=20</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(a)          //  这里是20 ，</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()</span><br><span class=\"line\"></span><br><span class=\"line\">// 第四条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    var a=&apos;littlebear&apos;;</span><br><span class=\"line\">    console.log(a)          //littlebear</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //string  第二个&lt;script&gt;标签里的a但会往上查找。</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    console.log(a)//1</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第五条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">    // 报错，遇到&lt;script&gt;标签对时，会先对这一块进行预解析，</span><br><span class=\"line\">    // 下面没预解析，所以找不到声明过的a，于是报错了</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    console.log(a)          //1</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第六条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    function fn(a,b)&#123;</span><br><span class=\"line\">        console.log(a)      //容易上当 初始化a的时候已经赋值&apos;容易上当&apos;</span><br><span class=\"line\">        var a=10;</span><br><span class=\"line\">        console.log(a)      //10</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn(&apos;容易上当&apos;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"18-amd-和-cmd-区别\">18. AMD 和 CMD 区别</span></h2>\n<ol>\n<li>\n<p>AMD 推崇依赖前置。 （requireJS）</p>\n<p>CMD 推崇依赖就近， （seaJS）</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">    var a = require(&apos;./a&apos;)</span><br><span class=\"line\">    a.doSomething()         // 此处略去 100 行</span><br><span class=\"line\">    var b = require(&apos;./b&apos;)  // 依赖可以就近书写</span><br><span class=\"line\">    b.doSomething()         // ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123;</span><br><span class=\"line\">    // 依赖必须一开始就写好</span><br><span class=\"line\">    a.doSomething()    // 此处略去 100 行</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>对于依赖的模块，</p>\n<p>AMD 是提前执行（预执行），</p>\n<p>CMD 是延迟执行（懒执行）。</p>\n</li>\n</ol>\n<blockquote>\n<p>不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>AMD 的 API 默认是一个当多个用，</p>\n<p>CMD 的 API 严格区分，推崇职责单一</p>\n</li>\n</ol>\n<blockquote>\n<p>比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</p>\n</blockquote>\n<hr>\n<h2><span id=\"19-常见服务器的状态码\">19. 常见服务器的状态码</span></h2>\n<ul>\n<li>\n<p>304</p>\n<p>Not Modified</p>\n<p>客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</p>\n</li>\n<li>\n<p>400</p>\n<p>Bad Request</p>\n<p>表示该请求报文中存在语法错误，导致服务器无法理解该请求。</p>\n</li>\n<li>\n<p>403</p>\n<p>Forbidden</p>\n<p>该状态码表明对请求资源的访问被服务器拒绝了。</p>\n</li>\n<li>\n<p>500</p>\n<p>Internal Server Error</p>\n<p>该状态码表明服务器端在执行请求时发生了错误。</p>\n</li>\n<li>\n<p>502</p>\n<p>上游网关错误</p>\n</li>\n<li>\n<p>301</p>\n<p>永久重定向</p>\n</li>\n<li>\n<p>302</p>\n<p>临时重定向 会出现 URL 劫持 体现在搜索引擎收录策略上 会改变原有请求方法</p>\n</li>\n<li>\n<p>307</p>\n<p>临时重定向 与 302 区别 客户端应<code>保持请求方法</code>不变向新的地址发出请求</p>\n</li>\n</ul>\n<hr>\n<h2><span id=\"20-事件冒泡和事件捕获\">20. 事件冒泡和事件捕获</span></h2>\n<pre><code>* 事件冒泡兼容写法\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (event.cancelBubble) &#123;</span><br><span class=\"line\">    event.cancelBubble = true</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    event.stopPropagation()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n--------------------------\n</code></pre>\n<h2><span id=\"21-数组\">21. 数组</span></h2>\n<pre><code>1. push\n\n    向数组末尾添加指定元素\n\n2. pop\n\n    移除数组末尾的一个元素 并返回移除的元素\n\n3. shift\n\n    移除数组第一项 并返回该元素\n\n4. unshift\n\n    给数组第一项加上一个元素 返回数组长度\n\n5. join\n\n    数组按照指定的字符换转成字符串\n\n6. sort\n\n    数组按照ASCII排序  所以要完全按照从小到大的顺序排序的话需要指定参数 1 -1 0\n\n7. splice\n\n    从0开始\n\n&gt; 删除 ---------------------（**起始位置，截取个数**）\n\n&gt; 插入 ---------------------（**起始位置，截取个数为0，要插入的项**）\n\n&gt; 替换----------------------（**起始位置，截取个数为1，要插入的项**）\n\n8. slice\n\n9. concat\n\n10. reverse\n\n11. 遍历数组的方法\n\n    &gt; forEach\n    &gt; for in\n\n    两者区别 在于 for in 会遍历数组原型链的属性值\n\n    为了避免这样的情况 使用 hasOwnProperty 解决\n</code></pre>\n<hr>\n<h2><span id=\"22正则\">22.正则</span></h2>\n<ul>\n<li>()：小括号，叫做分组符。</li>\n<li>\\s : 空格</li>\n<li>\\S : 非空格</li>\n<li>\\d : 数字</li>\n<li>\\D : 非数字</li>\n<li>\\w : 字符 ( 字母 ，数字，下划线_ )</li>\n<li>\\W : 非字符</li>\n<li>.（点）——任意字符</li>\n<li>. : 真正的点</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>\\B : 非独立的部分</li>\n<li>{n,m}：至少出现 n 次，最多 m 次</li>\n<li>{n,} :至少 n 次</li>\n<li>\n<ul>\n<li>:任意次 相当于{0,}</li>\n</ul>\n</li>\n<li>？ ：零次或一次 相当于{0,1}</li>\n<li>\n<ul>\n<li>：一次或任意次相当于 {1,}</li>\n</ul>\n</li>\n<li>{n}： 正好 n 次</li>\n<li>[] ： 表示某个集合中的任意一个 不能为空</li>\n</ul>\n<hr>\n<blockquote>\n<h3><span id=\"字符串相关的正则方法\">字符串相关的正则方法</span></h3>\n</blockquote>\n<ul>\n<li>\n<h3><span id=\"match\">match()</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>返回一个包含匹配内容的数组</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;abcdef&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var re = /B/i;</span><br><span class=\"line\"></span><br><span class=\"line\">str.match(re) // [b]</span><br></pre></td></tr></table></figure>\n<p>例子 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url = https://dimg.fws.qa.nt.ctripcorp.com/images/2d090m000000062hy59E5.jpg&quot;</span><br><span class=\"line\">url.match(/[^\\/]*$/) // 2d090m000000062hy59E5.jpg</span><br><span class=\"line\">url.match(/^[^\\/]*/) // https</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<h3><span id=\"search\">search()</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>返回匹配到的第一个内容所在的位置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;abcdef&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var re = /B/i;</span><br><span class=\"line\"></span><br><span class=\"line\">str.search(re) // 1</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<h3><span id=\"replace\">replace()</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>查找符合正则的字符串并替换成==一个==对应的字符串。返回替换后的内容。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;</span><br><span class=\"line\">var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配</span><br><span class=\"line\">var str2 = str.replace(re,&apos;*&apos;); // 我爱**，*上太阳升。</span><br></pre></td></tr></table></figure>\n<p>并不能解决一个文字*的对应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;</span><br><span class=\"line\">var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配</span><br><span class=\"line\">var str2 = str.replace(re,function(str)&#123;</span><br><span class=\"line\">            alert(str);</span><br><span class=\"line\">            //用来测试：参数代表每次搜索到的符合正则的字符，</span><br><span class=\"line\">            //所以第一次str指的是北京 第二次str是天安门 第三次str是天安门</span><br><span class=\"line\">            var result = &apos;&apos;;</span><br><span class=\"line\">            for(var i=0;i&lt;str.length;i++)&#123;</span><br><span class=\"line\">                result += &apos;*&apos;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return result; //所以搜索到了几个字就返回几个*</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">alert(str2)</span><br></pre></td></tr></table></figure>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\">        // replace()中如果有子项，</span><br><span class=\"line\">        // 第一个参数 ：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">        // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">        // 第三个参数 : $2(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">alert( str );   //2013.6.7</span><br><span class=\"line\">//整个过程就是利用子项把2013- 6- 分别替换成了2013. 6.  最终弹出2013.6.7</span><br></pre></td></tr></table></figure>\n</code></pre>\n<hr>\n<h3><span id=\"正则两个方法\">正则两个方法</span></h3>\n<ul>\n<li>\n<h3><span id=\"test\">test()</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>匹配到指定内容返回 true</p>\n</blockquote>\n<ul>\n<li>\n<h3><span id=\"exec\">==exec()==</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>返回第一匹配项信息的数组 若没有返回 null<br>\n有两个属性 index input</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var text = &apos;mom and dad and baby&apos;</span><br><span class=\"line\">var pattern = /mom( and dad( and baby)?)?/gi</span><br><span class=\"line\">var matches = pattern.exec(text)</span><br><span class=\"line\">mathes.index // 0</span><br><span class=\"line\">mathes.input // mom and dad and baby</span><br><span class=\"line\">mathes[0] // mom and dad and baby</span><br><span class=\"line\">mathes[1] //  and dad and baby</span><br><span class=\"line\">mathes[2] // and baby</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"23-后退监听\">23. 后退监听</span></h2>\n<blockquote>\n<p>history.back() history.forward() history.replace()触发 onpopstate 事件</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onpopstate = function () &#123;</span><br><span class=\"line\">    alert(&apos;2222&apos;)</span><br><span class=\"line\">    history.pushState(null, null, document.URL)</span><br><span class=\"line\">    return false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">history.pushState(null, null, document.URL)</span><br></pre></td></tr></table></figure>\n\nonbeforeunload事件有坑 chrome51版本及以后不能自定义文字 并且 页面载入之后一定要有浏览器行为才能触发\n</code></pre>\n<h2><span id=\"24-base64-图片及相关验证码\">24. base64 图片及相关验证码</span></h2>\n<blockquote>\n<p>data:image/gif;base64, (base64 地址)</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (result == null || result.length == 0) return</span><br><span class=\"line\">result = $.parseJSON(result)</span><br><span class=\"line\">var id = result[&apos;id&apos;]</span><br><span class=\"line\">var imgUrl = result[&apos;base64Buffer&apos;]</span><br><span class=\"line\">$(&apos;#js-code&apos;).attr(&apos;src&apos;, &apos;data:image/gif;base64,&apos; + imgUrl)</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"26-from-包裹的元素-document-事件失效-必须给-from-加事件\">26. from 包裹的元素 document 事件失效 必须给 from 加事件</span></h2>\n<h2><span id=\"27-进制转换\">27. 进制转换</span></h2>\n<blockquote>\n<p>十进制转十六进制</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = 255</span><br><span class=\"line\">s.toString(16) // ff</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n<p>十六进制转十进制</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;0xFF&apos;)   // 255</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"28-label-绑定事件一定要让事件委托到触发里面的-input\">28. label 绑定事件一定要让事件委托到触发里面的 input</span></h2>\n<pre><code>所以事件委托的时候直接监听input\n</code></pre>\n<h2><span id=\"29-跨域-post-请求转为-options-类型\">29. 跨域 post 请求转为 options 类型</span></h2>\n<h2><span id=\"30-math\">30. Math</span></h2>\n<pre><code>1. Math.floor 向下舍入；\n2. Math.ceil  向上舍入;\n3. Math.cos   余弦;\n4. Math.round 四舍五入;\n5. Math.sin   正弦；\n6. Math.tan   正切；\n</code></pre>\n<h2><span id=\"31-isnan\">31. isNaN</span></h2>\n<pre><code>首先需要知道 '' == 0   'abc' != 0   [] == 0  [1] != 0   null == 0  {} != 0  undefined != 0\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNaN(&apos;&apos;)   // false</span><br><span class=\"line\">isNaN(&apos; &apos;)  // false</span><br><span class=\"line\">isNaN(&apos;abc&apos;) // true</span><br><span class=\"line\">isNaN(undefined) // true</span><br><span class=\"line\">isNaN([])   // false</span><br><span class=\"line\">isNaN(&#123;&#125;)   // true</span><br><span class=\"line\">isNaN(null) // false</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"32-boolen\">32. Boolen</span></h2>\n<pre><code>首先需要知道  0 == false    1 == true  '' == false   undefined != false != true    null != false != true\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean(&apos;&apos;) // false</span><br><span class=\"line\">Boolean(&apos;ssss&apos;) // true</span><br><span class=\"line\">Boolean([])  // true</span><br><span class=\"line\">Boolean([1,2])  // true</span><br><span class=\"line\">Boolen(&#123;&#125;)      // true</span><br><span class=\"line\">Boolen(null)    // false</span><br><span class=\"line\">Boolen(undefined)   // false</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"33-解决回调地狱-多级回调\">33. 解决回调地狱 （多级回调）</span></h2>\n<pre><code>1. Promise\n\n2. aSync/await\n\n3. generator\n</code></pre>\n<h2><span id=\"34-字符串\">34. 字符串</span></h2>\n<pre><code>1. slice\n\n    在 不修改目标数组 的情况下返回截取的指定元素（ **起始位置，截止位置**）\n\n    从0开始 ==不包含最后一个数值==\n\n    负数情况下 将负数加上自身长度得到的数值作为参数\n\n2. substr\n\n    subdtr接收的是 起始位置 和 所要返回的字符串长度\n\n    在负数情况下  将第一个参数与字符串长度相加后的数值作为第一个参数\n\n3. substring\n\n    默认会将较小的参数作为第一个参数\n\n    在 不修改目标数组 的情况下返回截取的指定元素 （ **起始位置，截止位置**）\n\n    负数当做0处理\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let test = &apos;abcdef&apos;</span><br><span class=\"line\">test.slice(0, -1)   // abcde</span><br><span class=\"line\">test.slice(2, -3)   =&gt; test.slice(2,3)  // c</span><br><span class=\"line\"></span><br><span class=\"line\">test.substring(1, -2) =&gt; a</span><br><span class=\"line\">test.substring(2, -3) =&gt; ab</span><br></pre></td></tr></table></figure>\n<pre><code>4. split\n\n    字符串按照指定规则转换成数组\n</code></pre>\n<h2><span id=\"35-let-与-var-区别\">35. let 与 var 区别</span></h2>\n<pre><code>1. var存在变量提升， let不存在；\n2. let不允许重复声明；\n3. var挂载在window下，let挂载在块作用域下；\n</code></pre>\n<h2><span id=\"36-为什么-var-可以重复声明\">36. 为什么 var 可以重复声明</span></h2>\n<pre><code>因为js运行过程中，\n\n引擎 负责整个代码编译和运行\n\n编译器 负责词法分析、语法分析、代码生成等工作\n\n编译器从左至右编译var a，如果a不存在则在作用域声明一个新的变量a，若存在a则忽略继续向下编译；\n\n引擎遇到a = 2，按照作用域链向上查找 若存在变量a直接赋值，不存在则在作用域重新声明新的变量并赋值2\n</code></pre>\n<h2><span id=\"37-commonjs-中的-requireexports-和-es6-的-importexport-有什么区别\">37. CommonJS 中的 require/exports 和 ES6 的 import/export 有什么区别</span></h2>\n<ol>\n<li></li>\n</ol>\n<blockquote>\n<p>CommomJS 模块 require 代码时候会立刻执行；</p>\n</blockquote>\n<blockquote>\n<p>ES6 模块是动态引用，不会立刻执行，仅仅作为一个加载模块的对象引用；</p>\n</blockquote>\n<ol start=\"2\">\n<li></li>\n</ol>\n<blockquote>\n<p>CommonJs 模块输出的是一个值的拷贝， 输出后的对象会被缓存（即 如果发现一个模块被多次引用，会直接返回已经执行的部分）；</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// lib.js</span><br><span class=\"line\">var counter = 3;</span><br><span class=\"line\">function incCounter() &#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main.js</span><br><span class=\"line\">var mod = require(&apos;./lib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(mod.counter);  // 3</span><br><span class=\"line\">mod.incCounter();</span><br><span class=\"line\">console.log(mod.counter); // 3</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ES6 模块输出的是值的只读引用；</p>\n</blockquote>\n<ul>\n<li>接口输出的变量是只读的，重新赋值会报错；</li>\n<li>export 通过接口输出的是同一个值，得到的都是同样的实例；</li>\n<li>如果需要 import 支持动态加载 提案建议引入 import() 返回一个 promise 对象；</li>\n</ul>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/module-loader\" target=\"_blank\" rel=\"noopener\">ES6 模块与 CommonJS 模块的差异 </a></li>\n</ol>\n<h2><span id=\"38-浏览器缓存\">38. 浏览器缓存</span></h2>\n<pre><code>浏览器缓存分为 强缓存 和 协商缓存\n\n1. 客户端先根据资源的http header判断是否命中强缓存，如果命中直接从缓存中读取；\n\n2. 强缓存未命中，客户端发出请求，服务端根据请求的request header验证资源是否命中协商缓存，这个过程成为http再验证。如果命中，服务器将请求返回，状态码304，但不返回资源，而是告诉客服端可以从缓存读取；\n\n3. 当协商缓存也没有命中，直接服务端返回资源给客户端；\n\n\n强缓存\n\n1. Expires 代表缓存过期时间；\n\n2. Cache-Control： max-age  代表缓存最大生命周期；\n\n协商缓存\n\n1. Last-Modified 代表资源最后更新时间；\n\n2. If-Modified-Since 代表 判断两次请求之间是否有过修改 没有直接返回协商缓存；\n</code></pre>\n<h2><span id=\"39-处理-js-双精度问题\">39. 处理 js 双精度问题</span></h2>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> = <span class=\"number\">0.30000000000000004</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>由于计算机是做二进制运算</p>\n<p>0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）</p>\n<p>0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）</p>\n<p>双精度浮点数的小数部分最多支持 52 位</p>\n<p>处理方法：</p>\n<pre><code>1. toFixed  不够严谨；\n2. 把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(<span class=\"number\">0.1</span> * <span class=\"number\">10</span> + <span class=\"number\">0.2</span> * <span class=\"number\">10</span>) / <span class=\"number\">10</span> == <span class=\"number\">0.3</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<ol>\n<li>\n<p><a href=\"https://github.com/Megan-TA/UtilsJS\" target=\"_blank\" rel=\"noopener\">个人封装的处理双精度方法 第 7 点</a></p>\n</li>\n<li>\n<p><a href=\"https://www.cnblogs.com/xinggood/p/6639022.html\" target=\"_blank\" rel=\"noopener\">关于 js 浮点数计算精度不准确问题的解决办法</a></p>\n</li>\n</ol>\n<h2><span id=\"40-postmessage\">40. postMessage</span></h2>\n<ol>\n<li>window.postMessage() 可以安全进行跨域、跨页面通信；</li>\n<li>页面加载完成后才能进行跨域通信；</li>\n</ol>\n<p>发起端可以是 open 一个新窗口 或者 创建一个 iframe 往新窗口里发送数据</p>\n<p>案例:</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 客户端两种方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 当前页面地址 http:<span class=\"comment\">//www.webhek.com --&gt;</span></span><br><span class=\"line\">&lt;!-- open方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//弹出一个新窗口</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> domain = <span class=\"string\">'http://fanyi.youdao.com'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myPopup = <span class=\"built_in\">window</span>.open(domain, <span class=\"string\">'myWindow'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//周期性的发送消息</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'Hello! The time is: '</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'blog.local: sending message: '</span> + message);</span><br><span class=\"line\"><span class=\"comment\">//send the message and target URI</span></span><br><span class=\"line\">myPopup.postMessage(message,domain);</span><br><span class=\"line\">&#125;,<span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- iframe方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//捕获 iframe</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> domain = <span class=\"string\">\"http://fanyi.youdao.com\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myIFrame'</span>).contentWindow;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'Hello! The time is: '</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'blog.local: sending message: '</span> + message);</span><br><span class=\"line\"><span class=\"comment\">//send the message and target URI</span></span><br><span class=\"line\">iframe.postMessage(message,domain);</span><br><span class=\"line\">&#125;,<span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 接收端 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//监听消息反馈</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(event.origin !== <span class=\"string\">'http://www.webhek.com'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'received response: '</span>,event.data);</span><br><span class=\"line\">&#125;,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n<p>截图如下：</p>\n</blockquote>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006ANKB8gy1fqhqrhftfmj30yu0objvr.jpg\" alt=\"web骇客网站  接收端截图\"><br>\n<img src=\"https://wx2.sinaimg.cn/mw690/006ANKB8gy1fqhqri8fjlj30zk0h4tbk.jpg\" alt=\"有道翻译网站 接收端截图\"></p>\n<blockquote>\n<p>参考资料</p>\n</blockquote>\n<ol>\n<li><a href=\"http://www.webhek.com/post/window-postmessage-api.html\" target=\"_blank\" rel=\"noopener\">用 HTML5 里的 window.postMessage 在两个网页间传递数据</a></li>\n</ol>\n<h2><span id=\"41-service-worker\">41. Service Worker</span></h2>\n<blockquote>\n<p>背景</p>\n</blockquote>\n<p>为了解决 web 业务不断增加带来更多消耗资源、耗时等复杂运算带来性能问题，w3c 初期提出 Web Worker 的 API，目的为了解放主线程。原理是 将复杂 耗时的操作独立出来交给 Web Worker，完成后通过 postMessage 方法告诉主线程。</p>\n<p>缺点：临时存在，不能永久；为此提出 Service Worker，在 Web Worker 基础上增加持久缓存能力。</p>\n<p>在 Service Worker 之前有 APPCache 这个持久缓存的 API，不过存在更新机主不完善，二次更新，大小限制，回滚等问题，具体参考下方链接 1。</p>\n<p>Service Worker 的特性如下：</p>\n<ul>\n<li>\n<p>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</p>\n</li>\n<li>\n<p>一旦被 install，就永远存在，除非被 uninstall</p>\n</li>\n<li>\n<p>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）</p>\n</li>\n<li>\n<p>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</p>\n</li>\n<li>\n<p>离线内容开发者可控</p>\n</li>\n<li>\n<p>能向客户端推送消息</p>\n</li>\n<li>\n<p>不能直接操作 DOM</p>\n</li>\n<li>\n<p>出于安全的考虑，必须在 HTTPS 环境下才能工作</p>\n</li>\n<li>\n<p>异步实现，内部大都是通过 Promise 实现</p>\n</li>\n<li>\n<p>只能运行在 HTTPS 协议下</p>\n</li>\n</ul>\n<blockquote>\n<p>参考资料</p>\n</blockquote>\n<ol>\n<li><a href=\"https://www.zhihu.com/question/29876535\" target=\"_blank\" rel=\"noopener\">为什么 app cache 没有得到大规模应用？它有哪些硬伤吗？</a></li>\n<li><a href=\"https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction\" target=\"_blank\" rel=\"noopener\">Service Worker 简介</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28161855\" target=\"_blank\" rel=\"noopener\">如何优雅的为 PWA 注册 Service Worker</a></li>\n</ol>\n<h2><span id=\"42-加载更多下拉刷新\">42 加载更多/下拉刷新</span></h2>\n<p>原理：</p>\n<p>scrollTop（滚动条滚动距离） + clientHeight（可见区域高度） == scrollHeight（元素实际高度）</p>\n<p>备注：</p>\n<p>offsetHeighgt = height + padding + border</p>\n<p>clientHeight = height + padding</p>\n<h2><span id=\"43-js-标签中async和defer的作用与区别\">43. js 标签中<code>async</code>和<code>defer</code>的作用与区别</span></h2>\n<p>作用：</p>\n<p>1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>\n<p>2.async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p>\n<p>3.defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p>\n<p>区别：</p>\n<p>defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。<br>\n在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>js 知识点总结</h1>\n<h2>1. 解码和编码</h2>\n<blockquote>\n<p>原因：因为链接里面会有中文或者特殊字符号无法跳转需要进行相关编码解码</p>\n</blockquote>\n<p><strong>编码</strong></p>\n<blockquote></blockquote>\n<pre><code>'encodeURI': 只对查询的参数做编码\n\n'encodeURIComponent': 对整个url做编码，包括? &amp; / #\n</code></pre>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">'www.baidu.com/test?name=\"zhangsan\"'</span></span><br><span class=\"line\"><span class=\"built_in\">encodeURI</span>(a) =&gt; <span class=\"string\">'www.baidu.com/test?name=%22zhangsan%22'</span></span><br><span class=\"line\"><span class=\"built_in\">encodeURIComponent</span>(a) =&gt; <span class=\"string\">'www.baidu.com%2Ftest%3Fname%3D%22zhangsan%22'</span></span><br></pre></td></tr></table></figure>\n<p><strong>解码</strong></p>\n<blockquote></blockquote>\n<pre><code>'decodeURI': 只对查询参数做解码\n'decodeURIComponent': 对整个URL做解码\n</code></pre>\n<hr>\n<h2>2. 序列化和反序列化</h2>\n<blockquote></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify()        // 序列化</span><br><span class=\"line\">JSON.parse()            // 反序列化</span><br></pre></td></tr></table></figure>\n<p>使用 ajax 需要设置请求头部信息</p>\n<p>header: {‘Content-Type’: ‘application/json; charset=utf-8;’}</p>\n<blockquote>\n<p>JSON.stringify() 可以简单的用来迅速判断两个对象是否相等，但不严谨（比如：序列化失败）</p>\n</blockquote>\n<hr>\n<h2>3. 日期</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Date().getTime()   // 单位  秒</span><br><span class=\"line\">// 获取当前时间   （存在兼容性）</span><br><span class=\"line\">new Date().toLocaleDateString() // 2017/7/24</span><br><span class=\"line\">new Date().toLocaleTimeString() // 下午5:07:33</span><br><span class=\"line\">new Date().toLocaleString()     // 2017/7/24 下午5:07:33</span><br><span class=\"line\">// 若要显示24进制 需要option选项</span><br><span class=\"line\">new Date().toLocaleTimeString(&quot;UTC&quot;,&#123; hour12: false &#125;)  // 17:20:16</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>4. 回流/重绘</h2>\n<ol>\n<li>\n<p>回流：几何属性发生变化 比如：内容、结构、位置或尺寸发生变化，需要重新计算样式和渲染树；</p>\n</li>\n<li>\n<p>重绘：元素发生的改变只影响了节点的一些样式（背景色、边框色、文字颜色等）</p>\n</li>\n</ol>\n<blockquote>\n<p>回流比重绘要消耗更多的资源</p>\n</blockquote>\n<hr>\n<h2>5. 锚点定位 scrollIntoView （无兼容问题）</h2>\n<p>可以用来做一些 tab 定位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;xx&apos;).scrollIntoView()</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>6. typeof 和 instanceof</h2>\n<blockquote>\n<h3>typeof</h3>\n</blockquote>\n<p>会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,function；</p>\n<p>缺点：</p>\n<ul>\n<li>不适用于来判断数组，因为不管是数组还是对象，都会返回 object。</li>\n<li>判断不了 null null 也是对象</li>\n</ul>\n<blockquote></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof [1]      // Object</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h3>instanceof</h3>\n</blockquote>\n<p>返回的是一个布尔值 只能用来判断对象和函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;&#125;;</span><br><span class=\"line\">alert(  a instanceof Object )     // true</span><br><span class=\"line\">var a  = [];</span><br><span class=\"line\">alert(  a instanceof Array )    // true</span><br></pre></td></tr></table></figure>\n<p>最靠谱也是最方便的办法使用<code>Object.prototype.toString.call()</code>来判断</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">types</span>(<span class=\"params\">target</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>7. requestAnimationFrame （RAF） 动画 api 兼容 Ie 8/9</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i = 0</span><br><span class=\"line\"></span><br><span class=\"line\">window.requestAnimFrame = (function()&#123;</span><br><span class=\"line\">  return  window.requestAnimationFrame       ||</span><br><span class=\"line\">          window.webkitRequestAnimationFrame ||</span><br><span class=\"line\">          window.mozRequestAnimationFrame    ||</span><br><span class=\"line\">          function( callback )&#123;</span><br><span class=\"line\">            window.setTimeout(callback, 1000 / 60);</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\">requestAnimFrame(animloop)</span><br><span class=\"line\"></span><br><span class=\"line\">function animloop () &#123;</span><br><span class=\"line\">    document.getElementById(&apos;test&apos;).style.top = i ++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>优点</h3>\n<pre><code>1. 解决毫秒的不精确性；\n2. 避免过渡渲染；\n3. 浏览器可以优化并行的动画动作，将合并的动作放入一个渲染周期；\n4. 过程可控；\n</code></pre>\n<blockquote>\n<p>动画效率之争</p>\n</blockquote>\n<pre><code>css3动画高效的原因有以下三点：\n\n    1. 强制使用硬件加速（GPU）；\n    2. 使用与RAF类似的机制；\n    3. 优化DOM操作 避免内存消耗来减少卡顿；\n\n同时因为采用GPU， 导致浏览器一直出于高负荷运转，移动端电量损耗和一定卡顿，\n而且css不能完全被js控制\npc上兼容性\n</code></pre>\n<p>js 动画库 （比如 Velocity.js 和 GSAP）</p>\n<hr>\n<h2>8. 跨域</h2>\n<ol>\n<li>\n<h3>JSONP</h3>\n<blockquote>\n<p>通过 js 标签引入一个 js 文件 这个 js 文件载入成功之后会执行我们在 url 参数中指定的函数 并且会吧我们需要的 json 数据作为参数传入</p>\n<p>例如：url?item=1&amp;callback=filter</p>\n<p>== 原生 js 实现 jsonp 的话 定义好 callback 的函数名称,动态创建 js 标签 url 加上查询的参数写好 callback 的回调函数名称即可 ==</p>\n</blockquote>\n</li>\n<li>\n<h3>利用 iframe 并修改 document.domain 来跨子域</h3>\n<p>两个不同域的页面引入 iframe 标签 同时将两个页面的主域设置成相同的域名</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox669ialYSHxewnD1B4L5UibVqhMnFEfibLhA8vUQu2s9rltB2HZ6UTQ19iag/0?wx_fmt=png\" alt=\"页面1\"><br>\n<img src=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6Kv2iaHanjIzQHDNeia2FsoHSz8AJPkxh0IqickdbPg0CPeFPhoQMpuv5w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"页面2\"></p>\n</li>\n<li>\n<h3><a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> （可以配合 iframe）</h3>\n<p>同源窗口下 <a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 对所有页面都是共享的</p>\n<p>每个页面对 <a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 都有读写权限</p>\n<p><a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 的值并不会因为新页面而重置</p>\n</li>\n<li>\n<p>widnow.postMessage （存在兼容性 IE7/8 不支持）</p>\n<p>！<a href=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6z8ibxywKPEusvEA2xS8ialrQ1Oxd0jw0V8C6f7Gicy6Obsyt5bicibxdx5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"noopener\">页面 1</a></p>\n<p>！<a href=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6B9Fpsa9KmNAMibvfSqE8Qv2icpLzzFE6NfvEp8YxWW6JOMTacIzaQzxw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"noopener\">页面 2</a></p>\n</li>\n<li>\n<p>Nginx 反向代理</p>\n</li>\n</ol>\n<h2>9. selection</h2>\n<blockquote>\n<p>获取鼠标划过文本的对象</p>\n</blockquote>\n<blockquote>\n<p><code>window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();</code></p>\n</blockquote>\n<hr>\n<h2>10. 正则表达式</h2>\n<blockquote>\n<p>常用规则</p>\n</blockquote>\n<ul>\n<li>\\n 回车</li>\n<li>\\t 制表符</li>\n<li>\\r 换行符</li>\n<li>\\s 空格</li>\n<li>\\u4e00-\\u9fa5 中文</li>\n<li>\\w 大小写字母_数字</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>{n, m} 至少出现 n 次 最多 m 次</li>\n<li>{n,} 至少 n 次</li>\n<li>\n<ul>\n<li>任意次</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>至少一次</li>\n</ul>\n</li>\n<li>{n} 至少 n 次</li>\n<li>() 分组符号</li>\n<li>[\\s\\S] 任意字符</li>\n<li>^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。</li>\n<li>正则的最后位置 , 就代表结束的意思</li>\n</ul>\n<p>匹配中文: [\\u4e00-\\u9fa5]</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-</span><br><span class=\"line\">var re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-</span><br><span class=\"line\">var re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------</span><br><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //replace()中如果有子项，</span><br><span class=\"line\">    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[] 表示某个集合中的任意一个</li>\n<li>[^a] 排除 a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var re = /\\bclassname\\b/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会</span><br><span class=\"line\">// 把classname当做一个字符串去匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">var re = new RegExp(&apos;\\\\b&apos;+classname+&apos;\\\\b&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配的时候，classname前面必须是起始或者空格，后面也是。</span><br><span class=\"line\"></span><br><span class=\"line\">默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>11. Object</h2>\n<pre><code>1. constructor\n\n    实例的constructor 永远指向 构造函数 的 prototype.constructor\n\n    理解成 实例是基于构造函数原型链生成的对象\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function A(x)&#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newA = new A(name);</span><br><span class=\"line\"></span><br><span class=\"line\">此时：</span><br><span class=\"line\">newA.constructor == A.prototype.constructor;</span><br></pre></td></tr></table></figure>\n<pre><code>2. hasOwnProperty\n\n    判断对象上某个属性是否属于自身 属于自身为true, 原型链上为false\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a () &#123;</span><br><span class=\"line\">    this.show = &apos;x&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.prototype.hide = function () &#123;</span><br><span class=\"line\">    console.log(111111);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var z = new a();</span><br><span class=\"line\">z.hasOwnProperty(&apos;show&apos;);          // true</span><br><span class=\"line\">z.hasOwnProperty(&apos;hide&apos;);          // false</span><br></pre></td></tr></table></figure>\n<pre><code>3. isPrototypeOf\n\n    判断一个对象是否是另一个对象的原型\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var monkey = &#123;</span><br><span class=\"line\">    hair : true,</span><br><span class=\"line\">    breathes : function()&#123;</span><br><span class=\"line\">        alert(&apos;1&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Human(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Human的原型链绑定monkey对象</span><br><span class=\"line\">Human.prototype = monkey;</span><br><span class=\"line\"></span><br><span class=\"line\">var man = new Human(&apos;张三&apos;);</span><br><span class=\"line\">monkey.isPrototypeOf(man);      // true</span><br></pre></td></tr></table></figure>\n<pre><code>4. prototype和__proto__\n\n    prototype是一个函数的内置属性（每个函数都有一个prototype属性）\n\n    __proto__ 是一个实例对象的内置属性 实例化的对象在内部通过此属性寻找原型链\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Person = function () &#123;&#125;</span><br><span class=\"line\">var zhangsan = new Person ()</span><br><span class=\"line\"></span><br><span class=\"line\">zhansan.__prop__ = Person.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">new 的过程拆分成以下三步</span><br><span class=\"line\"></span><br><span class=\"line\">1. var p = &#123;&#125;</span><br><span class=\"line\">2. p.__proto__ = Person.prototype</span><br><span class=\"line\">3. Person.call(p)</span><br></pre></td></tr></table></figure>\n<pre><code>5. Object.getPrototypeOf\n\n    获取 实例化对象 原型链 的相关属性\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Test () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test.prototype.showName = function () &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj = new Test ()</span><br><span class=\"line\">Object.getPrototypeOf(obj) == obj.__proto__</span><br></pre></td></tr></table></figure>\n<pre><code>6. Object.keys\n\n    可以用来枚举可遍历的属性 返回一个数组\n\n7. Object.create\n\n    在原型链上创建对象属性\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 属性创建在原型链上 --&gt;</span><br><span class=\"line\">Object.create(&#123;</span><br><span class=\"line\">    name: &apos;张三&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 字面量方式创建的对象属性挂在自身 --&gt;</span><br><span class=\"line\">let test = &#123;</span><br><span class=\"line\">    name: &apos;张三&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>8. Object.isExtensible\n\n    判断对象是否可以新增属性\n\n9. Object.preventExtension\n\n    锁住对象 使其不能新增属性 但是原来的属性可以修改删除\n\n10. Object.seal\n\n    密封对象 不能增加新属性 也不能删除旧属性  但是能修改原来的属性\n\n11. Object.isSealed\n\n    判断对象是否密封\n\n12. Object.freeze\n\n    冻结对象 不能新增 不能修改 不能删除\n\n13. Object.isFrozen\n\n    判断对象是否完全被冻结\n\n14. Object.getOwnPropertyNames\n\n    获取自身属性名字 返回一个数组\n\n15. Object.getOwnPropertyDescriptor\n\n    判断某个对象上某个属性的状态描述\n\n16. Object.defineProperty\n\n\n\n\n-----------\n</code></pre>\n<h2>12. 继承</h2>\n<blockquote>\n<p><strong>调用另一个对象的方法，以另一个对象替换当前对象的上下文</strong></p>\n<blockquote>\n<p>缺点</p>\n<blockquote>\n<p>只能继承父级本身属性，原型链的属性无法继承</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li><strong>call</strong>\n<blockquote>\n<p>第二个参数可以省略</p>\n</blockquote>\n</li>\n<li><strong>apply</strong>\n<blockquote>\n<p>第二个参数必须是数组或者用 arguments 代替</p>\n</blockquote>\n</li>\n<li><strong>bind</strong>\n<blockquote>\n<p>bind 与 call 和 apply 的区别在于 bind 是一个函数 不会立即执行 必须在后面再加上一对括号去立即执行</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子1：</span><br><span class=\"line\"></span><br><span class=\"line\">function Add(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.add = function(a,b)&#123;</span><br><span class=\"line\">        alert(a+b)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.xx = 333;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.sub = &apos;张三&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // call方法</span><br><span class=\"line\">    Add.call(this); // call继承Add所有方法(不包含原型链上的方法)</span><br><span class=\"line\"></span><br><span class=\"line\">    // apply方法  参数不能指定的时候用[]或者arguments代替</span><br><span class=\"line\">    Add.apply(this, [])</span><br><span class=\"line\">    // 又可以写成</span><br><span class=\"line\">    Add.apply(this, arguments)</span><br><span class=\"line\"></span><br><span class=\"line\">    // bind方法</span><br><span class=\"line\">    Add.bind(this)();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">x = new Sub();</span><br><span class=\"line\">x.add(5,7)                  // 11</span><br><span class=\"line\"></span><br><span class=\"line\">=====================================</span><br><span class=\"line\"></span><br><span class=\"line\">例子2：</span><br><span class=\"line\"></span><br><span class=\"line\">若只想继承父级构造函数某一个具体方法</span><br><span class=\"line\">需要先将父子对象都实例化后 调用父级的具体方法call</span><br><span class=\"line\"></span><br><span class=\"line\">function Add(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.add = function(a,b)&#123;</span><br><span class=\"line\">        alert(a+b)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.xx = 333;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.sub = &apos;张三&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">newAdd = new Add(7,8);</span><br><span class=\"line\">newSub = new Sub();</span><br><span class=\"line\"></span><br><span class=\"line\">// Sub只继承了Add的add方法并执行相关方法</span><br><span class=\"line\"></span><br><span class=\"line\">call方法：</span><br><span class=\"line\">newAdd.add.call(newSub, 10, 4);      // 14</span><br><span class=\"line\"></span><br><span class=\"line\">apply方法：</span><br><span class=\"line\">newAdd.add.apply(newSub, [10, 4]);   // 14</span><br><span class=\"line\"></span><br><span class=\"line\">bind方法：</span><br><span class=\"line\">newAdd.add.bind(newSub, 10, 4)();   // 14</span><br></pre></td></tr></table></figure>\n<blockquote></blockquote>\n<blockquote>\n<blockquote>\n<p><strong>注意</strong></p>\n<blockquote>\n<p>若想要全部继承父级所有相关属性 得采用==原型链继承==的方式</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function person()&#123;</span><br><span class=\"line\">    this.hair = &apos;black&apos;;</span><br><span class=\"line\">    this.eye = &apos;black&apos;;</span><br><span class=\"line\">    this.skin = &apos;yellow&apos;;</span><br><span class=\"line\">    this.view = function()&#123;</span><br><span class=\"line\">        return this.hair + &apos;,&apos; + this.eye + &apos;,&apos; + this.skin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function man()&#123;</span><br><span class=\"line\">    this.feature = [&apos;beard&apos;,&apos;strong&apos;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">man.prototype = new person();</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>13. cookie sessionStorage localStorage</h2>\n<pre><code>1. cookie\n    * 4k的限制；\n    * 服务端和客户端传递时都会带上cookie；\n    * 本质上是对字符串的读取 存储内容过多消耗内存空间 导致页面变卡顿；\n    * 不能被爬虫读取；\n    * 设置时间之前一直有效，到时间就清除；\n2. sessionStorage\n    * 临时存储：引入“浏览器窗口”的概念，同源同窗口数据不会销毁，不同标签页中数据不能共享，关闭浏览器时候销毁；\n    * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n    * 性能更好，即本地读取数据比服务器获取快多了；\n    * 不能跨tab标签页传值；\n3. localStorage\n    * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n    * 体积更大 5M；\n    * 持久存储在本地，直到手动清除；\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(&apos;sss&apos;,1111);</span><br><span class=\"line\">localStorage.getItem(&apos;sss&apos;);</span><br><span class=\"line\">localStorage.removeItem(&apos;sss&apos;);</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>14. 闭包</h2>\n<pre><code>简单回答闭包就是 一个函数返回自身内部函数的调用\n\n为什么使用？\n\n因为js是链式的 一层一层向上级查找 所以外部函数无法访问内部函数;\n</code></pre>\n<blockquote>\n<blockquote>\n<p>优点</p>\n</blockquote>\n<ul>\n<li>可以读取函数内部的变量，外部无法访问到里面变量;</li>\n<li>函数在执行完毕不会被销毁 而是一直存在内存中;</li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>缺点</p>\n</blockquote>\n<ul>\n<li>不会被内存回收 容易出现性能问题</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function bar()&#123;</span><br><span class=\"line\">        console.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newFoo = foo();</span><br><span class=\"line\">newFoo();               // a</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>15. 深拷贝和浅拷贝</h2>\n<ul>\n<li><strong>浅拷贝</strong>\n<blockquote>\n<p><strong>复制对象的副本 指向同一内存区域 对副本的操作会影响父级对象</strong></p>\n</blockquote>\n</li>\n</ul>\n<p>浅拷贝方式：</p>\n<ol>\n<li>直接赋值；</li>\n<li>Object.assign();</li>\n<li>JSON 序列化；</li>\n</ol>\n<ul>\n<li><strong>深拷贝</strong>\n<blockquote>\n<p><strong>复制对象的副本 指向不同的内存区域 与父级对象独立</strong></p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 浅拷贝</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name : &apos;zhangsan&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a;</span><br><span class=\"line\">b.name = &apos;lisi&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.name);    // &quot;lisi&quot;</span><br><span class=\"line\">console.log(b.name);    // &quot;lisi&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 深拷贝  (更完整的深拷贝还需要再详细优化)</span><br><span class=\"line\">function deepCopy(p, c)&#123;</span><br><span class=\"line\">    var c = c || &#123;&#125;;</span><br><span class=\"line\">    for(var i in p )&#123;</span><br><span class=\"line\">        // 数组和对象的时候再处理</span><br><span class=\"line\">        if(typeof p[i] === &apos;object&apos;)&#123;</span><br><span class=\"line\">            c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class=\"line\">            deepCopy(p[i], c[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            // 基本类型直接赋值</span><br><span class=\"line\">            c[i] = p[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var parent = &#123;</span><br><span class=\"line\">    number: [1, 2, 3],</span><br><span class=\"line\">    obj: &#123;</span><br><span class=\"line\">        prop: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var copyParent = deepCopy(parent);</span><br><span class=\"line\">copyParent.number.push(4)</span><br><span class=\"line\">copyParent.number                   // 1,2,3,4</span><br><span class=\"line\">parent.number                       // 1,2,3</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>16. 传值类型和引用类型</h2>\n<ul>\n<li><strong>传值类型（基本类型）</strong>\n<blockquote>\n<p>值为基本类型时候为深拷贝</p>\n<blockquote>\n<p>基本类型就是 null，undefined，Boolean，string，number</p>\n<blockquote>\n<p>==独立不干扰==</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li><strong>引用类型</strong>\n<blockquote>\n<p>值为对象类型时候为浅拷贝</p>\n<blockquote>\n<p>值都是对对象的引用，即一个指向对象的指针</p>\n<blockquote>\n<p>==对副本的操作会影响父级对象==</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 传值类型</span><br><span class=\"line\">var  a = 1;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data = 2;</span><br><span class=\"line\">    console.log(data);   // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);    // 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 引用类型</span><br><span class=\"line\">var  a = &#123;</span><br><span class=\"line\">    name : &quot;张三&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data.name = &quot;李四&quot;;</span><br><span class=\"line\">    console.log(data);   //  Object &#123;name: &quot;李四&quot;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);         //  Object &#123;name: &quot;李四&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 引用类型不会被基本类型覆盖</span><br><span class=\"line\">var  a = &#123;</span><br><span class=\"line\">    name : &quot;张三&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data = 3；</span><br><span class=\"line\">    console.log(data);   // 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);         //  Object &#123;name: &quot;张三&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 为了解决引用类型的问题  引入深拷贝的概念  参考上面一个概念</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>17. 函数作用域提升与预编译</h2>\n<blockquote>\n<p>由于 js 没有其他强类型语言{}这类的块级作用域 只有函数作用域 函数的声明很随意导致各种问题出现</p>\n<blockquote>\n<p>变量预编译 &gt; 函数预编译</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一条</span><br><span class=\"line\"></span><br><span class=\"line\">a();</span><br><span class=\"line\">var a = c = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();</span><br><span class=\"line\"></span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();</span><br><span class=\"line\">(function(b) &#123;</span><br><span class=\"line\">    b(), c()</span><br><span class=\"line\">    var b = c = function a() &#123;</span><br><span class=\"line\">        console.log(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b();</span><br><span class=\"line\">&#125;)(a);</span><br><span class=\"line\">c();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等价于：</span><br><span class=\"line\">var a;                      // 变量声明提升</span><br><span class=\"line\">function a() &#123;              // 函数声明提升</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();                        // 1</span><br><span class=\"line\">a = c = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a();                        // 2</span><br><span class=\"line\"></span><br><span class=\"line\">(function(b) &#123;</span><br><span class=\"line\">    var b</span><br><span class=\"line\">    b()                     // 2</span><br><span class=\"line\">    c()                     // 本来以error</span><br><span class=\"line\">    // 后来有人指正 原因就在于var b=c=xxx。</span><br><span class=\"line\">    // c相当于没有加var 不会预编译，这里c直接查找到外部作用域的c</span><br><span class=\"line\">    b = c = function a() &#123;</span><br><span class=\"line\">        console.log(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b();                    // 3</span><br><span class=\"line\">&#125;)(a);</span><br><span class=\"line\"></span><br><span class=\"line\">c();                        // 3</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 第二条</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">    function a()&#123;console.log(1)&#125;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">    function a()&#123;console.log(2)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()();                     //2 由于预编译 后面的a覆盖了前面的a</span><br><span class=\"line\"></span><br><span class=\"line\">// 第三条</span><br><span class=\"line\">var a=10;</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">    // 预编译a 赋值undefined，内部作用域存在a这个变量，</span><br><span class=\"line\">    // 所以这里 !a 就是  !undefined，就是true，进入函数a=20;</span><br><span class=\"line\">    if (!a) &#123;</span><br><span class=\"line\">        var a=20</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(a)          //  这里是20 ，</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()</span><br><span class=\"line\"></span><br><span class=\"line\">// 第四条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    var a=&apos;littlebear&apos;;</span><br><span class=\"line\">    console.log(a)          //littlebear</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //string  第二个&lt;script&gt;标签里的a但会往上查找。</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    console.log(a)//1</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第五条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">    // 报错，遇到&lt;script&gt;标签对时，会先对这一块进行预解析，</span><br><span class=\"line\">    // 下面没预解析，所以找不到声明过的a，于是报错了</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    console.log(a)          //1</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第六条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    function fn(a,b)&#123;</span><br><span class=\"line\">        console.log(a)      //容易上当 初始化a的时候已经赋值&apos;容易上当&apos;</span><br><span class=\"line\">        var a=10;</span><br><span class=\"line\">        console.log(a)      //10</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn(&apos;容易上当&apos;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>18. AMD 和 CMD 区别</h2>\n<ol>\n<li>\n<p>AMD 推崇依赖前置。 （requireJS）</p>\n<p>CMD 推崇依赖就近， （seaJS）</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">    var a = require(&apos;./a&apos;)</span><br><span class=\"line\">    a.doSomething()         // 此处略去 100 行</span><br><span class=\"line\">    var b = require(&apos;./b&apos;)  // 依赖可以就近书写</span><br><span class=\"line\">    b.doSomething()         // ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123;</span><br><span class=\"line\">    // 依赖必须一开始就写好</span><br><span class=\"line\">    a.doSomething()    // 此处略去 100 行</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>对于依赖的模块，</p>\n<p>AMD 是提前执行（预执行），</p>\n<p>CMD 是延迟执行（懒执行）。</p>\n</li>\n</ol>\n<blockquote>\n<p>不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>AMD 的 API 默认是一个当多个用，</p>\n<p>CMD 的 API 严格区分，推崇职责单一</p>\n</li>\n</ol>\n<blockquote>\n<p>比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</p>\n</blockquote>\n<hr>\n<h2>19. 常见服务器的状态码</h2>\n<ul>\n<li>\n<p>304</p>\n<p>Not Modified</p>\n<p>客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</p>\n</li>\n<li>\n<p>400</p>\n<p>Bad Request</p>\n<p>表示该请求报文中存在语法错误，导致服务器无法理解该请求。</p>\n</li>\n<li>\n<p>403</p>\n<p>Forbidden</p>\n<p>该状态码表明对请求资源的访问被服务器拒绝了。</p>\n</li>\n<li>\n<p>500</p>\n<p>Internal Server Error</p>\n<p>该状态码表明服务器端在执行请求时发生了错误。</p>\n</li>\n<li>\n<p>502</p>\n<p>上游网关错误</p>\n</li>\n<li>\n<p>301</p>\n<p>永久重定向</p>\n</li>\n<li>\n<p>302</p>\n<p>临时重定向 会出现 URL 劫持 体现在搜索引擎收录策略上 会改变原有请求方法</p>\n</li>\n<li>\n<p>307</p>\n<p>临时重定向 与 302 区别 客户端应<code>保持请求方法</code>不变向新的地址发出请求</p>\n</li>\n</ul>\n<hr>\n<h2>20. 事件冒泡和事件捕获</h2>\n<pre><code>* 事件冒泡兼容写法\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (event.cancelBubble) &#123;</span><br><span class=\"line\">    event.cancelBubble = true</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    event.stopPropagation()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n--------------------------\n</code></pre>\n<h2>21. 数组</h2>\n<pre><code>1. push\n\n    向数组末尾添加指定元素\n\n2. pop\n\n    移除数组末尾的一个元素 并返回移除的元素\n\n3. shift\n\n    移除数组第一项 并返回该元素\n\n4. unshift\n\n    给数组第一项加上一个元素 返回数组长度\n\n5. join\n\n    数组按照指定的字符换转成字符串\n\n6. sort\n\n    数组按照ASCII排序  所以要完全按照从小到大的顺序排序的话需要指定参数 1 -1 0\n\n7. splice\n\n    从0开始\n\n&gt; 删除 ---------------------（**起始位置，截取个数**）\n\n&gt; 插入 ---------------------（**起始位置，截取个数为0，要插入的项**）\n\n&gt; 替换----------------------（**起始位置，截取个数为1，要插入的项**）\n\n8. slice\n\n9. concat\n\n10. reverse\n\n11. 遍历数组的方法\n\n    &gt; forEach\n    &gt; for in\n\n    两者区别 在于 for in 会遍历数组原型链的属性值\n\n    为了避免这样的情况 使用 hasOwnProperty 解决\n</code></pre>\n<hr>\n<h2>22.正则</h2>\n<ul>\n<li>()：小括号，叫做分组符。</li>\n<li>\\s : 空格</li>\n<li>\\S : 非空格</li>\n<li>\\d : 数字</li>\n<li>\\D : 非数字</li>\n<li>\\w : 字符 ( 字母 ，数字，下划线_ )</li>\n<li>\\W : 非字符</li>\n<li>.（点）——任意字符</li>\n<li>. : 真正的点</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>\\B : 非独立的部分</li>\n<li>{n,m}：至少出现 n 次，最多 m 次</li>\n<li>{n,} :至少 n 次</li>\n<li>\n<ul>\n<li>:任意次 相当于{0,}</li>\n</ul>\n</li>\n<li>？ ：零次或一次 相当于{0,1}</li>\n<li>\n<ul>\n<li>：一次或任意次相当于 {1,}</li>\n</ul>\n</li>\n<li>{n}： 正好 n 次</li>\n<li>[] ： 表示某个集合中的任意一个 不能为空</li>\n</ul>\n<hr>\n<blockquote>\n<h3>字符串相关的正则方法</h3>\n</blockquote>\n<ul>\n<li>\n<h3>match()</h3>\n</li>\n</ul>\n<blockquote>\n<p>返回一个包含匹配内容的数组</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;abcdef&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var re = /B/i;</span><br><span class=\"line\"></span><br><span class=\"line\">str.match(re) // [b]</span><br></pre></td></tr></table></figure>\n<p>例子 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url = https://dimg.fws.qa.nt.ctripcorp.com/images/2d090m000000062hy59E5.jpg&quot;</span><br><span class=\"line\">url.match(/[^\\/]*$/) // 2d090m000000062hy59E5.jpg</span><br><span class=\"line\">url.match(/^[^\\/]*/) // https</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<h3>search()</h3>\n</li>\n</ul>\n<blockquote>\n<p>返回匹配到的第一个内容所在的位置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;abcdef&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var re = /B/i;</span><br><span class=\"line\"></span><br><span class=\"line\">str.search(re) // 1</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<h3>replace()</h3>\n</li>\n</ul>\n<blockquote>\n<p>查找符合正则的字符串并替换成==一个==对应的字符串。返回替换后的内容。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;</span><br><span class=\"line\">var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配</span><br><span class=\"line\">var str2 = str.replace(re,&apos;*&apos;); // 我爱**，*上太阳升。</span><br></pre></td></tr></table></figure>\n<p>并不能解决一个文字*的对应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;</span><br><span class=\"line\">var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配</span><br><span class=\"line\">var str2 = str.replace(re,function(str)&#123;</span><br><span class=\"line\">            alert(str);</span><br><span class=\"line\">            //用来测试：参数代表每次搜索到的符合正则的字符，</span><br><span class=\"line\">            //所以第一次str指的是北京 第二次str是天安门 第三次str是天安门</span><br><span class=\"line\">            var result = &apos;&apos;;</span><br><span class=\"line\">            for(var i=0;i&lt;str.length;i++)&#123;</span><br><span class=\"line\">                result += &apos;*&apos;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return result; //所以搜索到了几个字就返回几个*</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">alert(str2)</span><br></pre></td></tr></table></figure>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\">        // replace()中如果有子项，</span><br><span class=\"line\">        // 第一个参数 ：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">        // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">        // 第三个参数 : $2(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">alert( str );   //2013.6.7</span><br><span class=\"line\">//整个过程就是利用子项把2013- 6- 分别替换成了2013. 6.  最终弹出2013.6.7</span><br></pre></td></tr></table></figure>\n</code></pre>\n<hr>\n<h3>正则两个方法</h3>\n<ul>\n<li>\n<h3>test()</h3>\n</li>\n</ul>\n<blockquote>\n<p>匹配到指定内容返回 true</p>\n</blockquote>\n<ul>\n<li>\n<h3>==exec()==</h3>\n</li>\n</ul>\n<blockquote>\n<p>返回第一匹配项信息的数组 若没有返回 null<br>\n有两个属性 index input</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var text = &apos;mom and dad and baby&apos;</span><br><span class=\"line\">var pattern = /mom( and dad( and baby)?)?/gi</span><br><span class=\"line\">var matches = pattern.exec(text)</span><br><span class=\"line\">mathes.index // 0</span><br><span class=\"line\">mathes.input // mom and dad and baby</span><br><span class=\"line\">mathes[0] // mom and dad and baby</span><br><span class=\"line\">mathes[1] //  and dad and baby</span><br><span class=\"line\">mathes[2] // and baby</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>23. 后退监听</h2>\n<blockquote>\n<p>history.back() history.forward() history.replace()触发 onpopstate 事件</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onpopstate = function () &#123;</span><br><span class=\"line\">    alert(&apos;2222&apos;)</span><br><span class=\"line\">    history.pushState(null, null, document.URL)</span><br><span class=\"line\">    return false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">history.pushState(null, null, document.URL)</span><br></pre></td></tr></table></figure>\n\nonbeforeunload事件有坑 chrome51版本及以后不能自定义文字 并且 页面载入之后一定要有浏览器行为才能触发\n</code></pre>\n<h2>24. base64 图片及相关验证码</h2>\n<blockquote>\n<p>data:image/gif;base64, (base64 地址)</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (result == null || result.length == 0) return</span><br><span class=\"line\">result = $.parseJSON(result)</span><br><span class=\"line\">var id = result[&apos;id&apos;]</span><br><span class=\"line\">var imgUrl = result[&apos;base64Buffer&apos;]</span><br><span class=\"line\">$(&apos;#js-code&apos;).attr(&apos;src&apos;, &apos;data:image/gif;base64,&apos; + imgUrl)</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>26. from 包裹的元素 document 事件失效 必须给 from 加事件</h2>\n<h2>27. 进制转换</h2>\n<blockquote>\n<p>十进制转十六进制</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = 255</span><br><span class=\"line\">s.toString(16) // ff</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n<p>十六进制转十进制</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;0xFF&apos;)   // 255</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>28. label 绑定事件一定要让事件委托到触发里面的 input</h2>\n<pre><code>所以事件委托的时候直接监听input\n</code></pre>\n<h2>29. 跨域 post 请求转为 options 类型</h2>\n<h2>30. Math</h2>\n<pre><code>1. Math.floor 向下舍入；\n2. Math.ceil  向上舍入;\n3. Math.cos   余弦;\n4. Math.round 四舍五入;\n5. Math.sin   正弦；\n6. Math.tan   正切；\n</code></pre>\n<h2>31. isNaN</h2>\n<pre><code>首先需要知道 '' == 0   'abc' != 0   [] == 0  [1] != 0   null == 0  {} != 0  undefined != 0\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNaN(&apos;&apos;)   // false</span><br><span class=\"line\">isNaN(&apos; &apos;)  // false</span><br><span class=\"line\">isNaN(&apos;abc&apos;) // true</span><br><span class=\"line\">isNaN(undefined) // true</span><br><span class=\"line\">isNaN([])   // false</span><br><span class=\"line\">isNaN(&#123;&#125;)   // true</span><br><span class=\"line\">isNaN(null) // false</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>32. Boolen</h2>\n<pre><code>首先需要知道  0 == false    1 == true  '' == false   undefined != false != true    null != false != true\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean(&apos;&apos;) // false</span><br><span class=\"line\">Boolean(&apos;ssss&apos;) // true</span><br><span class=\"line\">Boolean([])  // true</span><br><span class=\"line\">Boolean([1,2])  // true</span><br><span class=\"line\">Boolen(&#123;&#125;)      // true</span><br><span class=\"line\">Boolen(null)    // false</span><br><span class=\"line\">Boolen(undefined)   // false</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>33. 解决回调地狱 （多级回调）</h2>\n<pre><code>1. Promise\n\n2. aSync/await\n\n3. generator\n</code></pre>\n<h2>34. 字符串</h2>\n<pre><code>1. slice\n\n    在 不修改目标数组 的情况下返回截取的指定元素（ **起始位置，截止位置**）\n\n    从0开始 ==不包含最后一个数值==\n\n    负数情况下 将负数加上自身长度得到的数值作为参数\n\n2. substr\n\n    subdtr接收的是 起始位置 和 所要返回的字符串长度\n\n    在负数情况下  将第一个参数与字符串长度相加后的数值作为第一个参数\n\n3. substring\n\n    默认会将较小的参数作为第一个参数\n\n    在 不修改目标数组 的情况下返回截取的指定元素 （ **起始位置，截止位置**）\n\n    负数当做0处理\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let test = &apos;abcdef&apos;</span><br><span class=\"line\">test.slice(0, -1)   // abcde</span><br><span class=\"line\">test.slice(2, -3)   =&gt; test.slice(2,3)  // c</span><br><span class=\"line\"></span><br><span class=\"line\">test.substring(1, -2) =&gt; a</span><br><span class=\"line\">test.substring(2, -3) =&gt; ab</span><br></pre></td></tr></table></figure>\n<pre><code>4. split\n\n    字符串按照指定规则转换成数组\n</code></pre>\n<h2>35. let 与 var 区别</h2>\n<pre><code>1. var存在变量提升， let不存在；\n2. let不允许重复声明；\n3. var挂载在window下，let挂载在块作用域下；\n</code></pre>\n<h2>36. 为什么 var 可以重复声明</h2>\n<pre><code>因为js运行过程中，\n\n引擎 负责整个代码编译和运行\n\n编译器 负责词法分析、语法分析、代码生成等工作\n\n编译器从左至右编译var a，如果a不存在则在作用域声明一个新的变量a，若存在a则忽略继续向下编译；\n\n引擎遇到a = 2，按照作用域链向上查找 若存在变量a直接赋值，不存在则在作用域重新声明新的变量并赋值2\n</code></pre>\n<h2>37. CommonJS 中的 require/exports 和 ES6 的 import/export 有什么区别</h2>\n<ol>\n<li></li>\n</ol>\n<blockquote>\n<p>CommomJS 模块 require 代码时候会立刻执行；</p>\n</blockquote>\n<blockquote>\n<p>ES6 模块是动态引用，不会立刻执行，仅仅作为一个加载模块的对象引用；</p>\n</blockquote>\n<ol start=\"2\">\n<li></li>\n</ol>\n<blockquote>\n<p>CommonJs 模块输出的是一个值的拷贝， 输出后的对象会被缓存（即 如果发现一个模块被多次引用，会直接返回已经执行的部分）；</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// lib.js</span><br><span class=\"line\">var counter = 3;</span><br><span class=\"line\">function incCounter() &#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main.js</span><br><span class=\"line\">var mod = require(&apos;./lib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(mod.counter);  // 3</span><br><span class=\"line\">mod.incCounter();</span><br><span class=\"line\">console.log(mod.counter); // 3</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ES6 模块输出的是值的只读引用；</p>\n</blockquote>\n<ul>\n<li>接口输出的变量是只读的，重新赋值会报错；</li>\n<li>export 通过接口输出的是同一个值，得到的都是同样的实例；</li>\n<li>如果需要 import 支持动态加载 提案建议引入 import() 返回一个 promise 对象；</li>\n</ul>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/module-loader\" target=\"_blank\" rel=\"noopener\">ES6 模块与 CommonJS 模块的差异 </a></li>\n</ol>\n<h2>38. 浏览器缓存</h2>\n<pre><code>浏览器缓存分为 强缓存 和 协商缓存\n\n1. 客户端先根据资源的http header判断是否命中强缓存，如果命中直接从缓存中读取；\n\n2. 强缓存未命中，客户端发出请求，服务端根据请求的request header验证资源是否命中协商缓存，这个过程成为http再验证。如果命中，服务器将请求返回，状态码304，但不返回资源，而是告诉客服端可以从缓存读取；\n\n3. 当协商缓存也没有命中，直接服务端返回资源给客户端；\n\n\n强缓存\n\n1. Expires 代表缓存过期时间；\n\n2. Cache-Control： max-age  代表缓存最大生命周期；\n\n协商缓存\n\n1. Last-Modified 代表资源最后更新时间；\n\n2. If-Modified-Since 代表 判断两次请求之间是否有过修改 没有直接返回协商缓存；\n</code></pre>\n<h2>39. 处理 js 双精度问题</h2>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> = <span class=\"number\">0.30000000000000004</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>由于计算机是做二进制运算</p>\n<p>0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）</p>\n<p>0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）</p>\n<p>双精度浮点数的小数部分最多支持 52 位</p>\n<p>处理方法：</p>\n<pre><code>1. toFixed  不够严谨；\n2. 把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(<span class=\"number\">0.1</span> * <span class=\"number\">10</span> + <span class=\"number\">0.2</span> * <span class=\"number\">10</span>) / <span class=\"number\">10</span> == <span class=\"number\">0.3</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<ol>\n<li>\n<p><a href=\"https://github.com/Megan-TA/UtilsJS\" target=\"_blank\" rel=\"noopener\">个人封装的处理双精度方法 第 7 点</a></p>\n</li>\n<li>\n<p><a href=\"https://www.cnblogs.com/xinggood/p/6639022.html\" target=\"_blank\" rel=\"noopener\">关于 js 浮点数计算精度不准确问题的解决办法</a></p>\n</li>\n</ol>\n<h2>40. postMessage</h2>\n<ol>\n<li>window.postMessage() 可以安全进行跨域、跨页面通信；</li>\n<li>页面加载完成后才能进行跨域通信；</li>\n</ol>\n<p>发起端可以是 open 一个新窗口 或者 创建一个 iframe 往新窗口里发送数据</p>\n<p>案例:</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 客户端两种方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 当前页面地址 http:<span class=\"comment\">//www.webhek.com --&gt;</span></span><br><span class=\"line\">&lt;!-- open方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//弹出一个新窗口</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> domain = <span class=\"string\">'http://fanyi.youdao.com'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myPopup = <span class=\"built_in\">window</span>.open(domain, <span class=\"string\">'myWindow'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//周期性的发送消息</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'Hello! The time is: '</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'blog.local: sending message: '</span> + message);</span><br><span class=\"line\"><span class=\"comment\">//send the message and target URI</span></span><br><span class=\"line\">myPopup.postMessage(message,domain);</span><br><span class=\"line\">&#125;,<span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- iframe方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//捕获 iframe</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> domain = <span class=\"string\">\"http://fanyi.youdao.com\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myIFrame'</span>).contentWindow;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'Hello! The time is: '</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'blog.local: sending message: '</span> + message);</span><br><span class=\"line\"><span class=\"comment\">//send the message and target URI</span></span><br><span class=\"line\">iframe.postMessage(message,domain);</span><br><span class=\"line\">&#125;,<span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 接收端 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//监听消息反馈</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(event.origin !== <span class=\"string\">'http://www.webhek.com'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'received response: '</span>,event.data);</span><br><span class=\"line\">&#125;,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n<p>截图如下：</p>\n</blockquote>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006ANKB8gy1fqhqrhftfmj30yu0objvr.jpg\" alt=\"web骇客网站  接收端截图\"><br>\n<img src=\"https://wx2.sinaimg.cn/mw690/006ANKB8gy1fqhqri8fjlj30zk0h4tbk.jpg\" alt=\"有道翻译网站 接收端截图\"></p>\n<blockquote>\n<p>参考资料</p>\n</blockquote>\n<ol>\n<li><a href=\"http://www.webhek.com/post/window-postmessage-api.html\" target=\"_blank\" rel=\"noopener\">用 HTML5 里的 window.postMessage 在两个网页间传递数据</a></li>\n</ol>\n<h2>41. Service Worker</h2>\n<blockquote>\n<p>背景</p>\n</blockquote>\n<p>为了解决 web 业务不断增加带来更多消耗资源、耗时等复杂运算带来性能问题，w3c 初期提出 Web Worker 的 API，目的为了解放主线程。原理是 将复杂 耗时的操作独立出来交给 Web Worker，完成后通过 postMessage 方法告诉主线程。</p>\n<p>缺点：临时存在，不能永久；为此提出 Service Worker，在 Web Worker 基础上增加持久缓存能力。</p>\n<p>在 Service Worker 之前有 APPCache 这个持久缓存的 API，不过存在更新机主不完善，二次更新，大小限制，回滚等问题，具体参考下方链接 1。</p>\n<p>Service Worker 的特性如下：</p>\n<ul>\n<li>\n<p>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</p>\n</li>\n<li>\n<p>一旦被 install，就永远存在，除非被 uninstall</p>\n</li>\n<li>\n<p>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）</p>\n</li>\n<li>\n<p>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</p>\n</li>\n<li>\n<p>离线内容开发者可控</p>\n</li>\n<li>\n<p>能向客户端推送消息</p>\n</li>\n<li>\n<p>不能直接操作 DOM</p>\n</li>\n<li>\n<p>出于安全的考虑，必须在 HTTPS 环境下才能工作</p>\n</li>\n<li>\n<p>异步实现，内部大都是通过 Promise 实现</p>\n</li>\n<li>\n<p>只能运行在 HTTPS 协议下</p>\n</li>\n</ul>\n<blockquote>\n<p>参考资料</p>\n</blockquote>\n<ol>\n<li><a href=\"https://www.zhihu.com/question/29876535\" target=\"_blank\" rel=\"noopener\">为什么 app cache 没有得到大规模应用？它有哪些硬伤吗？</a></li>\n<li><a href=\"https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction\" target=\"_blank\" rel=\"noopener\">Service Worker 简介</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28161855\" target=\"_blank\" rel=\"noopener\">如何优雅的为 PWA 注册 Service Worker</a></li>\n</ol>\n<h2>42 加载更多/下拉刷新</h2>\n<p>原理：</p>\n<p>scrollTop（滚动条滚动距离） + clientHeight（可见区域高度） == scrollHeight（元素实际高度）</p>\n<p>备注：</p>\n<p>offsetHeighgt = height + padding + border</p>\n<p>clientHeight = height + padding</p>\n<h2>43. js 标签中<code>async</code>和<code>defer</code>的作用与区别</h2>\n<p>作用：</p>\n<p>1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>\n<p>2.async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p>\n<p>3.defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p>\n<p>区别：</p>\n<p>defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。<br>\n在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。</p>\n"}],"PostAsset":[{"_id":"source/_posts/centos下开机自动重启服务和脚本/WX20190708-113220.png","post":"ck28rx5me0004h91pc1ysdl6p","slug":"WX20190708-113220.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"ck28rx5ma0002h91pnfyhfa0j","tag_id":"ck28rx5mg0005h91pis0u27gn","_id":"ck28rx5mq000bh91p6rdv37ju"},{"post_id":"ck28rx5me0004h91pc1ysdl6p","tag_id":"ck28rx5mg0005h91pis0u27gn","_id":"ck28rx5mv000fh91pr2l605e0"},{"post_id":"ck28rx5mi0007h91pyb1xv86h","tag_id":"ck28rx5mu000eh91pm8ra51dx","_id":"ck28rx5my000kh91pl17xx734"},{"post_id":"ck28rx5my000jh91pe7y1on1w","tag_id":"ck28rx5mg0005h91pis0u27gn","_id":"ck28rx5mz000nh91p26x82q5j"},{"post_id":"ck28rx5mk0008h91pynkmg4tc","tag_id":"ck28rx5mx000ih91p9o3tqte9","_id":"ck28rx5n0000ph91phk5k98fb"},{"post_id":"ck28rx5mm0009h91pwjub60v4","tag_id":"ck28rx5mz000mh91pvbv48y6r","_id":"ck28rx5n2000th91polhgarj6"},{"post_id":"ck28rx5mq000ch91puiage7s6","tag_id":"ck28rx5n1000rh91pwwoovxjc","_id":"ck28rx5n4000xh91p3vtt2hdz"},{"post_id":"ck28rx5mt000dh91puwly65yu","tag_id":"ck28rx5n1000rh91pwwoovxjc","_id":"ck28rx5n70011h91poifjobi4"},{"post_id":"ck28rx5n5000zh91pel55o4s3","tag_id":"ck28rx5mz000mh91pvbv48y6r","_id":"ck28rx5n80013h91pdaqpc9mj"},{"post_id":"ck28rx5mv000gh91p78gp1znr","tag_id":"ck28rx5n60010h91p9iaw1brj","_id":"ck28rx5na0017h91p5lbhielf"},{"post_id":"ck28rx5na0016h91p4g9m8df0","tag_id":"ck28rx5n1000rh91pwwoovxjc","_id":"ck28rx5nb001ah91pminvtm4a"},{"post_id":"ck28rx5mw000hh91pwqm7et99","tag_id":"ck28rx5n90015h91pudfwzgpk","_id":"ck28rx5nd001ch91paaxvsj92"},{"post_id":"ck28rx5na0018h91pann1krne","tag_id":"ck28rx5n1000rh91pwwoovxjc","_id":"ck28rx5ne001fh91p4gvsv2dd"},{"post_id":"ck28rx5nc001bh91pm9foc7zm","tag_id":"ck28rx5n90015h91pudfwzgpk","_id":"ck28rx5ne001hh91pf6trpvau"},{"post_id":"ck28rx5mz000lh91pguertdi9","tag_id":"ck28rx5n1000rh91pwwoovxjc","_id":"ck28rx5nf001ih91p541ouagp"},{"post_id":"ck28rx5n0000oh91pny3y8fge","tag_id":"ck28rx5nd001eh91pd8214s4j","_id":"ck28rx5nf001kh91p40yqjj5l"},{"post_id":"ck28rx5n0000qh91p5rklyxvl","tag_id":"ck28rx5nf001jh91p92r6yej4","_id":"ck28rx5nf001mh91pk9dezxsa"},{"post_id":"ck28rx5n1000sh91p2n5oonrm","tag_id":"ck28rx5n1000rh91pwwoovxjc","_id":"ck28rx5ng001oh91pzma2xawo"},{"post_id":"ck28rx5n2000uh91psw93899x","tag_id":"ck28rx5n90015h91pudfwzgpk","_id":"ck28rx5nh001qh91p8tt8po0l"},{"post_id":"ck28rx5n3000vh91pk4ahzwfl","tag_id":"ck28rx5ng001ph91plgtgmvzt","_id":"ck28rx5nh001sh91p1uftu2j0"},{"post_id":"ck28rx5n4000yh91puuadx7kx","tag_id":"ck28rx5nh001rh91pzz55ayc2","_id":"ck28rx5nh001uh91pasxa4fhb"},{"post_id":"ck28rx5n80014h91pnzujcdjr","tag_id":"ck28rx5nh001th91pl1jriv3b","_id":"ck28rx5ni001wh91ps7yb29uj"},{"post_id":"ck28rx5nd001dh91pyttsvep9","tag_id":"ck28rx5nh001vh91po0wgkf6r","_id":"ck28rx5ni001yh91phixkacg1"},{"post_id":"ck28rx5ne001gh91pyjswnw5f","tag_id":"ck28rx5ni001xh91psl2x1yat","_id":"ck28rx5ni001zh91pzo2ooebr"},{"post_id":"ck28rx5nq0020h91p4mesbm48","tag_id":"ck28rx5nr0021h91p25qi37gx","_id":"ck28rx5nr0022h91px4xzy9bs"},{"post_id":"ck28rx5ob0023h91pf89mwrf2","tag_id":"ck28rx5n1000rh91pwwoovxjc","_id":"ck28rx5oc0024h91pancxr5xw"}],"Tag":[{"name":"linux","_id":"ck28rx5mg0005h91pis0u27gn"},{"name":"git","_id":"ck28rx5mu000eh91pm8ra51dx"},{"name":"docker","_id":"ck28rx5mx000ih91p9o3tqte9"},{"name":"web","_id":"ck28rx5mz000mh91pvbv48y6r"},{"name":"javascript","_id":"ck28rx5n1000rh91pwwoovxjc"},{"name":"python","_id":"ck28rx5n60010h91p9iaw1brj"},{"name":"node","_id":"ck28rx5n90015h91pudfwzgpk"},{"name":"vue react","_id":"ck28rx5nd001eh91pd8214s4j"},{"name":"监控","_id":"ck28rx5nf001jh91p92r6yej4"},{"name":"IDE","_id":"ck28rx5ng001ph91plgtgmvzt"},{"name":"npm","_id":"ck28rx5nh001rh91pzz55ayc2"},{"name":"随笔","_id":"ck28rx5nh001th91pl1jriv3b"},{"name":"前端","_id":"ck28rx5nh001vh91po0wgkf6r"},{"name":"jenkins","_id":"ck28rx5ni001xh91psl2x1yat"},{"name":"nginx","_id":"ck28rx5nr0021h91p25qi37gx"}]}}