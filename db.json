{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/article/tag.png","path":"img/article/tag.png","modified":0,"renderable":0},{"_id":"themes/hu/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/hu/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/hu/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/hu/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/hu/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/hu/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/hu/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/hu/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/hu/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/hu/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/hu/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/hu/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/hu/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/hu/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/hu/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/hu/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/hu/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":0,"renderable":0},{"_id":"themes/hu/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/hu/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hu/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":0,"renderable":0},{"_id":"themes/hu/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/hu/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/hu/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"source/img/avatar/ironman.png","path":"img/avatar/ironman.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/hu/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/article/huweihuang_blog.png","path":"img/article/huweihuang_blog.png","modified":0,"renderable":0},{"_id":"source/img/blog.jpg","path":"img/blog.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":0,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1563847051723},{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1563847051723},{"_id":"themes/hu/_config.yml","hash":"e800e32847df32dacddb5202823a004557023bcd","modified":1563847051867},{"_id":"themes/hu/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1563847051866},{"_id":"source/_posts/centos下利用nvm安装node.md","hash":"6e23fd302849fd653ad441b9d5ee43599f5483a6","modified":1563950696567},{"_id":"source/about/index.md","hash":"56b5f984a91bba5206db3b3fe1b1a02cf6f830e7","modified":1563847051737},{"_id":"source/_posts/centos下开机自动重启服务和脚本.md","hash":"9156114c42ea391ec849408a8565f884cdb659c7","modified":1563847051724},{"_id":"source/_posts/docker基本使用.md","hash":"cfecf7ae5ef68eef3c5233d8062a4fef05ebf70b","modified":1567568435849},{"_id":"source/_posts/git-submodule.md","hash":"b906140520df7411ecb8cbe466dce79281002aae","modified":1563847051727},{"_id":"source/_posts/git常用命令.md","hash":"7d2a2794670f6df759d2cc56dbd99e2c370bc3c1","modified":1568967104198},{"_id":"source/_posts/js中几种设计模式.md","hash":"302889da49a4891d763abe5554edddcab0df9359","modified":1563847051728},{"_id":"source/_posts/js知识点总结.md","hash":"883fea43acbe244463ed5ec8facd7260412139b8","modified":1576678388318},{"_id":"source/_posts/nginx入门.md","hash":"493ea73a06cdd85ff523ebdafcf1537c2ebda572","modified":1574991977034},{"_id":"source/_posts/node性能优化.md","hash":"bdb0f74397f9caf4ce45460572a6294dbe1b7414","modified":1577115933794},{"_id":"source/_posts/js继承问题总结.md","hash":"8498df3ce598d69ca07ea3f6fa7cff9ed9e1fc31","modified":1569379793341},{"_id":"source/_posts/pm2常用命令整理.md","hash":"58358ca2e8881715655cf8987d196b0bfc9bcf29","modified":1564065600136},{"_id":"source/_posts/linux常用指令记录.md","hash":"07c1713eb8f7159117bb55572a5c284a87e63c52","modified":1564114239060},{"_id":"source/_posts/python爬虫框架scrapy.md","hash":"bf3035f160e50f686ef67750343c0eb7f198225a","modified":1568879088387},{"_id":"source/_posts/react-hooks入门.md","hash":"c932408952f50c9d7f8f092a71aade926b5f729b","modified":1578479959326},{"_id":"source/_posts/react-vue中dom-diff简易版实现.md","hash":"e2596d658de1c39b12896e5b0fb36ec21431ceda","modified":1563847051729},{"_id":"source/_posts/vue项目接入sentry.md","hash":"72222665ee9e929cd9c810b695d00fa9c213b33d","modified":1572167331082},{"_id":"source/_posts/rollup-js使用.md","hash":"5f2a53ede7f2a94ab99370751a4f2fff2c6a2553","modified":1569382187962},{"_id":"source/_posts/一些新的api.md","hash":"dc6e64d0a85918960daa5210c010eda609a97018","modified":1576678385524},{"_id":"source/_posts/前端基础面试题整理.md","hash":"af2c1dc682da2435b7aaf2d0941ae11fdf790dcb","modified":1577952170237},{"_id":"source/_posts/前端算法题整理.md","hash":"df744b9caddd326d32cc7f212e8cdc240951642c","modified":1576510653413},{"_id":"source/_posts/分享个人vscode常用插件.md","hash":"344f32ffb1d7c0c327b94876f5f4e0cda2e8fa5a","modified":1563847051731},{"_id":"source/_posts/基于sentry的异常捕获平台.md","hash":"6cf8521f90a736f261926449b37fb89870a490f4","modified":1577151383784},{"_id":"source/_posts/前端多项目公共模块管理实践.md","hash":"bbf1786241f78f6d1969c55c86db2fe35ba69f4c","modified":1563847051732},{"_id":"source/_posts/利用verdaccio搭建私有npm仓库.md","hash":"82acd8cc995ca3bd275598dd5bd997a9ca889b02","modified":1563847051731},{"_id":"source/_posts/常用npm包整理.md","hash":"d4419018bf7b2597921f7777be43a551a074ef6a","modified":1576678600373},{"_id":"source/_posts/掉坑记录.md","hash":"cab08f0a4cbd25cbe45cb9d678727d3c95687d7e","modified":1578034855585},{"_id":"source/_posts/正则实战.md","hash":"c815534eb271dcd238e0a690940e6d38af932345","modified":1567147104335},{"_id":"source/_posts/序.md","hash":"f6b814efcc0228443127066d69e86f8340f49dcf","modified":1563847051734},{"_id":"source/_posts/记录typescript使用的几个注意点.md","hash":"1732f8dc608efc5fc3d6f61e22223e77170780b1","modified":1569298943964},{"_id":"source/_posts/记录一次node爬虫开发.md","hash":"2796d42ac0fc09ac363e48d3dbc7b51cb56b7bca","modified":1564066188521},{"_id":"source/_posts/记录工单系统的前端性能优化.md","hash":"04234e9755bd3fbc37dce738d3283d831f2236dc","modified":1563847051736},{"_id":"source/_posts/记录平时jenkins使用遇到的问题.md","hash":"304a275a8640f122405e08d7f0487fbdaeccda6f","modified":1564066500853},{"_id":"source/archive/index.md","hash":"e4c40d8a769b9076bebf7b8a07f20a4e339a4804","modified":1563847051738},{"_id":"source/tags/index.md","hash":"4e62b153da9d097c43aa29bb1a37586bc47d5a62","modified":1563847051865},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1563847051856},{"_id":"themes/hu/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1563847051868},{"_id":"themes/hu/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1563847051868},{"_id":"themes/hu/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1563847051869},{"_id":"themes/hu/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1563847051869},{"_id":"themes/hu/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1563847051870},{"_id":"themes/hu/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1563847051870},{"_id":"themes/hu/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1563847051871},{"_id":"themes/hu/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1563847051871},{"_id":"themes/hu/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1563847051872},{"_id":"themes/hu/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1563847051872},{"_id":"themes/hu/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1563847051882},{"_id":"themes/hu/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1563847051881},{"_id":"themes/hu/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1563847051883},{"_id":"themes/hu/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1563847051881},{"_id":"themes/hu/layout/layout.ejs","hash":"a6f0f1369afaddf5b63cc04589f17dfee409fcd0","modified":1563847051883},{"_id":"themes/hu/layout/page.ejs","hash":"5e588f200a7b7cd3ae40402b0dd3b779aac6787f","modified":1563847051884},{"_id":"themes/hu/layout/post.ejs","hash":"a36524a762090581a858ae55b62ca18e6251876a","modified":1563847051885},{"_id":"themes/hu/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1563847051886},{"_id":"source/_posts/centos下开机自动重启服务和脚本/WX20190708-113220.png","hash":"2ddd3501c319f9cd7848239f1ec6ccfc138ca9cd","modified":1563847051725},{"_id":"source/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1563847051744},{"_id":"themes/hu/layout/_partial/footer.ejs","hash":"e69b7c4a446db77588b981521471194dff5fc5f7","modified":1563847051873},{"_id":"themes/hu/layout/_partial/header.ejs","hash":"3bd09df76e0622d76d186b020393fcab361e6c97","modified":1563847051874},{"_id":"themes/hu/layout/_partial/head.ejs","hash":"7858f29b52340f2ba2fc52733167c802028820e5","modified":1563847051874},{"_id":"themes/hu/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1563847051875},{"_id":"themes/hu/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1563847051875},{"_id":"themes/hu/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1563847051876},{"_id":"themes/hu/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1563847051876},{"_id":"themes/hu/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1563847051877},{"_id":"themes/hu/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1563847051878},{"_id":"themes/hu/layout/_widget/featured-tags.ejs","hash":"229b58f185955a9bfbc658fd00b3e7f3c69cbb2c","modified":1563847051878},{"_id":"themes/hu/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1563847051879},{"_id":"themes/hu/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1563847051879},{"_id":"themes/hu/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1563847051880},{"_id":"themes/hu/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1563847051887},{"_id":"themes/hu/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1563847051888},{"_id":"themes/hu/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1563847051888},{"_id":"themes/hu/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1563847051892},{"_id":"themes/hu/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1563847051893},{"_id":"themes/hu/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1563847051893},{"_id":"themes/hu/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1563847051895},{"_id":"themes/hu/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1563847051896},{"_id":"themes/hu/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1563847051896},{"_id":"themes/hu/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1563847051897},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1563847051898},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1563847051900},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1563847051901},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1563847051901},{"_id":"themes/hu/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1563847051905},{"_id":"themes/hu/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1563847051904},{"_id":"themes/hu/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1563847051905},{"_id":"themes/hu/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1563847051909},{"_id":"themes/hu/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1563847051909},{"_id":"themes/hu/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1563847051909},{"_id":"themes/hu/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1563847051909},{"_id":"source/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1563847051797},{"_id":"themes/hu/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1563847051891},{"_id":"themes/hu/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1563847051899},{"_id":"themes/hu/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1563847051904},{"_id":"themes/hu/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1563847051908},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1563847051799},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1563847051802},{"_id":"themes/hu/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1563847051889},{"_id":"themes/hu/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1563847051894},{"_id":"themes/hu/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1563847051894},{"_id":"source/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1563847051768},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1563847051863},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1563847051859},{"_id":"themes/hu/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1563847051907},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1563847051747},{"_id":"source/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1563847051744},{"_id":"source/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1563847051777},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1563847051826},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1563847051855},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1563847051762},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1563847051817},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1563847051794},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1563847051845},{"_id":"public/post-sitemap.xml","hash":"3465a162aa8717ad7afa9936d930f5ab8bfd01c8","modified":1578480033485},{"_id":"public/page-sitemap.xml","hash":"9e74fe36f8e54d64c87dad7ab23f2786c9d0e4dc","modified":1578480033485},{"_id":"public/tag-sitemap.xml","hash":"3684bbc44793ffb56289d08db5e962a1e6f632af","modified":1578480033605},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1578480033605},{"_id":"public/sitemap.xml","hash":"3a848ca9cb94a44922e14371d6b9841d55679268","modified":1578480033618},{"_id":"public/404.html","hash":"febc771bb852c6ee252139db93f0f1c0c07cf522","modified":1578480033849},{"_id":"public/2019/07/24/centos下利用nvm安装node/index.html","hash":"75b9b8a9055db563fa320cbc54451f26797a52dd","modified":1578480033850},{"_id":"public/2019/07/22/一些新的api/index.html","hash":"56dbf2219cb66027231cd088fe82408c42ac5d51","modified":1578480034253},{"_id":"public/2019/07/22/记录工单系统的前端性能优化/index.html","hash":"14313c19678084714590ae397502e10468cfcc87","modified":1578480034253},{"_id":"public/tags/index.html","hash":"3c3d989e7a56114c04ebb40e262f9859ba005c0b","modified":1578480034434},{"_id":"public/2019/08/30/正则实战/index.html","hash":"718ebc1864ab50bce7434ea970225dafccbc28ed","modified":1578480034439},{"_id":"public/2019/08/28/掉坑记录/index.html","hash":"58f15f667c9550e91291d560e2b3b50049b36d23","modified":1578480034439},{"_id":"public/2019/07/25/pm2常用命令整理/index.html","hash":"7c42ee26adfda0c2273fadbdee4051e8e4745f93","modified":1578480034448},{"_id":"public/2019/10/11/vue项目接入sentry/index.html","hash":"05c617c97f1f02cb3cb42059b74b7d72909f07fc","modified":1578480034449},{"_id":"public/about/index.html","hash":"aa7a6032a87b290d2782c3ba015f4ff2e52f32c5","modified":1578480034449},{"_id":"public/archive/index.html","hash":"951dc77c8e7b7d279c9b3bf45b0c8cf304438461","modified":1578480034449},{"_id":"public/2019/09/25/rollup-js使用/index.html","hash":"283df824ad68f80a852915eafffe0663df5a50c5","modified":1578480034470},{"_id":"public/2019/12/23/node性能优化/index.html","hash":"d0ca7e62ddda0dadc6e52b8d40a30f0441d4af4b","modified":1578480034470},{"_id":"public/2020/01/08/react-hooks入门/index.html","hash":"28a27bbabf2b935986da34ddcee6fe53549647b8","modified":1578480034533},{"_id":"public/2019/12/16/前端算法题整理/index.html","hash":"3deea1025021e1c7d08395d7b981514f8bcf7901","modified":1578480034533},{"_id":"public/2019/11/05/基于sentry的异常捕获平台/index.html","hash":"40b199f9e4fb3d0c48c27d6867071b666d2f99ca","modified":1578480034563},{"_id":"public/2019/11/12/前端基础面试题整理/index.html","hash":"08dd82ef3ae8a95212b86ae07424dd99e97c13a3","modified":1578480034563},{"_id":"public/2019/09/24/js继承问题总结/index.html","hash":"e2f2c3948ba66c1935f0dde1a56da2ff8751b6f4","modified":1578480034564},{"_id":"public/2019/07/22/记录typescript使用的几个注意点/index.html","hash":"026f94d4c4000d569a61d632dcfbd2a0d9848291","modified":1578480034564},{"_id":"public/2019/07/10/git-submodule/index.html","hash":"36f1349800c5c1abcb0c674ee1c2d1b54647444e","modified":1578480034565},{"_id":"public/2019/07/14/js中几种设计模式/index.html","hash":"5ae9b360a4d2c165ce510a512e90187a73d00f0f","modified":1578480034565},{"_id":"public/2019/07/08/centos下开机自动重启服务和脚本/index.html","hash":"ef97a62fcded3c836c6aae1eb0d10a0037aa6b03","modified":1578480034565},{"_id":"public/2019/06/20/react-vue中dom-diff简易版实现/index.html","hash":"b52258e1357483415e9d041300228b9d784aac00","modified":1578480034565},{"_id":"public/2019/07/03/常用npm包整理/index.html","hash":"81f49ac6e20a2a56110528fd37e38b8831687282","modified":1578480034565},{"_id":"public/2019/06/21/前端多项目公共模块管理实践/index.html","hash":"3ef251efc604ddb600916dac3e395db749cf612d","modified":1578480034565},{"_id":"public/2019/06/19/docker基本使用/index.html","hash":"03036721fe8a0afc2630b81c3ba5cdb838948f59","modified":1578480034565},{"_id":"public/2019/06/19/分享个人vscode常用插件/index.html","hash":"473a3a3a41360e293e4828b602df043409ec6545","modified":1578480034565},{"_id":"public/2019/06/15/序/index.html","hash":"e72cfa89a11092f5471e27bab5ae1e9501b1db38","modified":1578480034565},{"_id":"public/2019/05/21/记录平时jenkins使用遇到的问题/index.html","hash":"ddbed0f7034984eecbab96f3bf61187a7f2eec1d","modified":1578480034565},{"_id":"public/2019/06/19/python爬虫框架scrapy/index.html","hash":"971eb46c20867a994ab0a363884b510251505c37","modified":1578480034565},{"_id":"public/2019/06/16/利用verdaccio搭建私有npm仓库/index.html","hash":"b45d5110724bc8d127f2edfa5e1dd199589761a4","modified":1578480034565},{"_id":"public/2019/04/25/git常用命令/index.html","hash":"b682ab0c4450432742063d4de32853b47e724e85","modified":1578480034565},{"_id":"public/2019/03/25/linux常用指令记录/index.html","hash":"afa8204b69788b12cfde60e5c6b53a37b15b94d7","modified":1578480034565},{"_id":"public/2018/07/21/js知识点总结/index.html","hash":"812c2fab25e11853bc716298f7e1c929adb98d41","modified":1578480034565},{"_id":"public/2019/05/07/记录一次node爬虫开发/index.html","hash":"5eb2ed252889729190175a530aa1bb4134aea09c","modified":1578480034565},{"_id":"public/2019/06/19/nginx入门/index.html","hash":"985e1ca5d2307152d4cfb61056215c700c1ca78a","modified":1578480034565},{"_id":"public/tags/web/index.html","hash":"456e3c2c469a8ba317602dcc21c36886ad99ed5a","modified":1578480034565},{"_id":"public/tags/docker/index.html","hash":"e1ed604d1d11b0688008bd440195a0907cda6785","modified":1578480034565},{"_id":"public/tags/git/index.html","hash":"33e9e0fd3b686cb601881c37ef1636348a381d0f","modified":1578480034566},{"_id":"public/tags/node/index.html","hash":"9618f88b5013b1ee41c3bb2f51811f33d85a28a2","modified":1578480034566},{"_id":"public/tags/python/index.html","hash":"c07ca048934a6ba0ffbf28785dd1d0ca31b24b64","modified":1578480034566},{"_id":"public/tags/vue-react/index.html","hash":"590eccd1b72f68f02170862307e5082a1a1967fb","modified":1578480034566},{"_id":"public/tags/监控/index.html","hash":"e53b489fd6eb7bb93b6b8d2d2062530aec911925","modified":1578480034566},{"_id":"public/tags/IDE/index.html","hash":"6b6e2a457023af7e3328e4d0e6df4eb091eeef8b","modified":1578480034566},{"_id":"public/tags/npm/index.html","hash":"135c1bc180e8589ca4682f6186be4bad5f512da5","modified":1578480034566},{"_id":"public/tags/随笔/index.html","hash":"562ffd49420424450a5dba43cfeb5b61efecfaf4","modified":1578480034566},{"_id":"public/tags/前端/index.html","hash":"85b6554370046646afc9b8da92c697205aad134e","modified":1578480034566},{"_id":"public/tags/jenkins/index.html","hash":"85589f42d5b5422fadf21a4eb7bebcc4c3621e1e","modified":1578480034566},{"_id":"public/tags/nginx/index.html","hash":"bf5ed21f2f9588e6ed3cc2b21fed72c72e0713fd","modified":1578480034566},{"_id":"public/tags/javascript/index.html","hash":"90432f97848928faa2196592e83220fed40af66e","modified":1578480034566},{"_id":"public/archives/archives/3/index.html","hash":"17d437e3d76e442be83de3a9d36b1c7b37b92231","modified":1578480034566},{"_id":"public/archives/archives/2/index.html","hash":"48efd03ff09cf6a124952dd3bb30b5e005c2deb0","modified":1578480034567},{"_id":"public/archives/2018/07/index.html","hash":"4b1d9774e03aa2c388ab769eaa730cdc1e87ad1b","modified":1578480034567},{"_id":"public/archives/2019/index.html","hash":"747f83b64ef2c3c6c2e619d37e65c5b5c9a8c7e4","modified":1578480034567},{"_id":"public/archives/2019/archives/2/index.html","hash":"5c8dcb3c9c0e3c8cb1ca9d8bdcdf06f6051b0779","modified":1578480034567},{"_id":"public/archives/2019/archives/3/index.html","hash":"05ce62c73037f0e52ebe975c4004614fa5ca3e28","modified":1578480034567},{"_id":"public/archives/2019/03/index.html","hash":"0d7e94dc027b223a32f0b895416318de54d5ce30","modified":1578480034567},{"_id":"public/archives/2019/04/index.html","hash":"09a1c684069c27fa711959151b856e3681088138","modified":1578480034567},{"_id":"public/archives/2019/05/index.html","hash":"08e855db5878261ebb6c86d5ad24ae8f33e7ef68","modified":1578480034567},{"_id":"public/archives/2019/06/index.html","hash":"99219b576f2891c9469965cc017d3199f1e56d56","modified":1578480034567},{"_id":"public/archives/2019/07/index.html","hash":"a06f533587d9108b79e4d2737f93cac2386de0b0","modified":1578480034567},{"_id":"public/archives/2019/08/index.html","hash":"4d66a1ce7c0ce1750d843243621ca5f85e9f2193","modified":1578480034567},{"_id":"public/archives/2019/09/index.html","hash":"66387e68219f81df0ed1753382646d5602298d46","modified":1578480034567},{"_id":"public/archives/index.html","hash":"16280510f82f8d83a2b9f7f95bfbb96053afa0dd","modified":1578480034567},{"_id":"public/archives/2018/index.html","hash":"2b987f95be7f59619c1c8cd8ce306c4da483be79","modified":1578480034567},{"_id":"public/archives/2019/10/index.html","hash":"5fd84ec5bb808b18eaee4b3827deed3827661981","modified":1578480034568},{"_id":"public/index.html","hash":"ae7a954ceeed5e57c7d270fac9dd2490ada4c0c1","modified":1578480034568},{"_id":"public/archives/3/index.html","hash":"c6d132e8f670af65c10023a9c97d8154a1d6b409","modified":1578480034568},{"_id":"public/tags/linux/index.html","hash":"f6ceeda693ca0c4a3cd368a8ba16ac574872397c","modified":1578480034568},{"_id":"public/archives/2/index.html","hash":"d6688b4acf21d5ec88362445706de78b414b5fc1","modified":1578480034568},{"_id":"public/CNAME","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578480034568},{"_id":"public/tags/react/index.html","hash":"d3fbf1ddfbbf12d6b8e4e944125c02abc6df934a","modified":1578480034573},{"_id":"public/archives/archives/4/index.html","hash":"9400675e752cebd48745b479b0e2bd3dd8b8ee1d","modified":1578480034573},{"_id":"public/archives/2019/11/index.html","hash":"60a0c44d216ad729b69ba4c6fd464277fd8e1a6f","modified":1578480034573},{"_id":"public/archives/2019/12/index.html","hash":"162c0b1bd2c1b304ee0d9882831430461044b4a9","modified":1578480034573},{"_id":"public/archives/2020/index.html","hash":"d06ba471d44a2fc4a43b63b5f6052afb982e89fa","modified":1578480034573},{"_id":"public/archives/2020/01/index.html","hash":"6c648d66301a5c340f52499ce51bf56eae0bade6","modified":1578480034573},{"_id":"public/archives/4/index.html","hash":"42c4b9f761affdfaf7b4382717254aa39bb2aea0","modified":1578480034573},{"_id":"public/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1578480034573},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1578480034573},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1578480034573},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1578480034573},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1578480034573},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1578480034573},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1578480034573},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1578480034573},{"_id":"public/2019/07/08/centos下开机自动重启服务和脚本/WX20190708-113220.png","hash":"2ddd3501c319f9cd7848239f1ec6ccfc138ca9cd","modified":1578480034573},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1578480034839},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1578480034844},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1578480034845},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1578480034845},{"_id":"public/css/toc.css","hash":"f756b9e1b2208d2e5b0f3d2ac5e4fea3b7da0e10","modified":1578480034845},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1578480034845},{"_id":"public/css/highlight.css","hash":"c58b4569c086e477a00dcbf5a95a166fe5fecfb0","modified":1578480034845},{"_id":"public/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1578480034845},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1578480034845},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1578480034845},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1578480034845},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1578480034845},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1578480034845},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1578480034845},{"_id":"public/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1578480034845},{"_id":"public/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1578480034845},{"_id":"public/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1578480034845},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1578480034869},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1578480034869},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1578480034875},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1578480034875},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1578480034875},{"_id":"public/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1578480034875},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1578480034884},{"_id":"public/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1578480034884},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1578480034900},{"_id":"public/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1578480034900},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1578480034918},{"_id":"public/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1578480034921},{"_id":"public/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1578480034925},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1578480034929},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1578480034931},{"_id":"public/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1578480034935},{"_id":"public/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1578480034940},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1578480034944},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1578480034945},{"_id":"public/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1578480034950},{"_id":"public/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1578480034959}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2019-07-23T01:57:31.723Z","updated":"2019-07-23T01:57:31.723Z","path":"404.html","title":"","comments":1,"_id":"ck55698110000gu1pq6k0fdsj","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2017-10-03T02:48:33.000Z","description":"走在成为极客的路上","header-img":"/blog/img/header_img/about.jpg","aplayer":true,"fixed":false,"_content":"\n### 一句话\n\n>Just do it !    (翻译：nike名言)\n\n### 关于我\n\n>\n>\n>\n\n### 兴趣方向\n\n>\n\n### 参与社区\n\n > 掘金: \n >\n\n### 联系我\n\n>Email: hc1132107224@163.com\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2017-10-03 10:48:33\ndescription: \"走在成为极客的路上\"\nheader-img: \"/blog/img/header_img/about.jpg\"\naplayer: true\nfixed: false\n---\n\n### 一句话\n\n>Just do it !    (翻译：nike名言)\n\n### 关于我\n\n>\n>\n>\n\n### 兴趣方向\n\n>\n\n### 参与社区\n\n > 掘金: \n >\n\n### 联系我\n\n>Email: hc1132107224@163.com\n","updated":"2019-07-23T01:57:31.737Z","path":"about/index.html","comments":1,"_id":"ck556981x0001gu1pplts6an1","content":"<h3><span id=\"一句话\">一句话</span></h3>\n<blockquote>\n<p>Just do it !    (翻译：nike名言)</p>\n</blockquote>\n<h3><span id=\"关于我\">关于我</span></h3>\n<blockquote></blockquote>\n<h3><span id=\"兴趣方向\">兴趣方向</span></h3>\n<blockquote></blockquote>\n<h3><span id=\"参与社区\">参与社区</span></h3>\n<blockquote>\n<p>掘金:</p>\n</blockquote>\n<h3><span id=\"联系我\">联系我</span></h3>\n<blockquote>\n<p>Email: <a href=\"mailto:hc1132107224@163.com\" target=\"_blank\" rel=\"noopener\">hc1132107224@163.com</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>一句话</h3>\n<blockquote>\n<p>Just do it !    (翻译：nike名言)</p>\n</blockquote>\n<h3>关于我</h3>\n<blockquote></blockquote>\n<h3>兴趣方向</h3>\n<blockquote></blockquote>\n<h3>参与社区</h3>\n<blockquote>\n<p>掘金:</p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:hc1132107224@163.com\" target=\"_blank\" rel=\"noopener\">hc1132107224@163.com</a></p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"/blog/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/blog/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-07-23T01:57:31.738Z","path":"archive/index.html","_id":"ck55698210003gu1pj4vkwjld","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/blog/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/blog/img/header_img/tag.png\"\n---\n","date":"2019-07-23T01:57:31.865Z","updated":"2019-07-23T01:57:31.865Z","path":"tags/index.html","comments":1,"_id":"ck55698250006gu1p7m95m3x4","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"centos下利用nvm安装node","catalog":true,"date":"2019-07-24T06:43:38.000Z","subtitle":null,"header-img":null,"_content":"\n- 安装 github\n\nyum install git -y\n\n- 下载 nvm\n\ngit clone git://github.com/creationix/nvm.git ~/nvm\n\n- 设置 nvm 自动运行;\n\necho \"source ~/nvm/nvm.sh\" >> ~/.bashrc\nsource ~/.bashrc\n\n- 查询 node 版本\n\nnvm list-remote\n\n- 安装 node.js\n\nnvm install v10.15.1\n\n- 使用 nodejs\n  nvm use v10.15.1\n","source":"_posts/centos下利用nvm安装node.md","raw":"---\ntitle: centos下利用nvm安装node\ncatalog: true\ndate: 2019-07-24 14:43:38\nsubtitle:\nheader-img:\ntags: linux\n---\n\n- 安装 github\n\nyum install git -y\n\n- 下载 nvm\n\ngit clone git://github.com/creationix/nvm.git ~/nvm\n\n- 设置 nvm 自动运行;\n\necho \"source ~/nvm/nvm.sh\" >> ~/.bashrc\nsource ~/.bashrc\n\n- 查询 node 版本\n\nnvm list-remote\n\n- 安装 node.js\n\nnvm install v10.15.1\n\n- 使用 nodejs\n  nvm use v10.15.1\n","slug":"centos下利用nvm安装node","published":1,"updated":"2019-07-24T06:44:56.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556981y0002gu1paq5qa6l2","content":"<ul>\n<li>安装 github</li>\n</ul>\n<p>yum install git -y</p>\n<ul>\n<li>下载 nvm</li>\n</ul>\n<p>git clone git://github.com/creationix/nvm.git ~/nvm</p>\n<ul>\n<li>设置 nvm 自动运行;</li>\n</ul>\n<p>echo “source ~/nvm/nvm.sh” &gt;&gt; ~/.bashrc<br>\nsource ~/.bashrc</p>\n<ul>\n<li>查询 node 版本</li>\n</ul>\n<p>nvm list-remote</p>\n<ul>\n<li>安装 node.js</li>\n</ul>\n<p>nvm install v10.15.1</p>\n<ul>\n<li>使用 nodejs<br>\nnvm use v10.15.1</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>安装 github</li>\n</ul>\n<p>yum install git -y</p>\n<ul>\n<li>下载 nvm</li>\n</ul>\n<p>git clone git://github.com/creationix/nvm.git ~/nvm</p>\n<ul>\n<li>设置 nvm 自动运行;</li>\n</ul>\n<p>echo “source ~/nvm/nvm.sh” &gt;&gt; ~/.bashrc<br>\nsource ~/.bashrc</p>\n<ul>\n<li>查询 node 版本</li>\n</ul>\n<p>nvm list-remote</p>\n<ul>\n<li>安装 node.js</li>\n</ul>\n<p>nvm install v10.15.1</p>\n<ul>\n<li>使用 nodejs<br>\nnvm use v10.15.1</li>\n</ul>\n"},{"title":"centos下开机自动重启服务和脚本","catalog":true,"date":"2019-07-08T02:45:59.000Z","subtitle":null,"header-img":null,"_content":"\n1. ### 利用`chkconfig`添加开机自启服务\n\n```shell\nchkconfig\n\n--list 各项服务状态栏显示出来\n--level 设置某个服务在该状态栏显示出来\n\n单独开启某一服务的命令：chkconfig 服务名 on\n\n单独关闭某一服务的命令：chkconfig 服务名 off\n\n查看某一服务的状态：/etc/intd.d/服务名 status\n\n```\n\n我这里以docker 服务为例，设置如下两条命令即可：\n\n```shell\n1  # systemctl enable docker.service #设置docker服务为自启动服务 相当于我们的 chkconfig docker on\n2 # systemctl start docker.service #启动docker服务\n\n```\n\n2. ### 添加开机自启脚本\n\n - 方法一\n\n    1. 赋予脚本可执行权限（/opt/script/duDefaultService.sh是你的脚本路径）\n\n    2. 打开/etc/rc.d/rc.local文件，在末尾增加如下内容\n\n    ```shell\n    echo \"/opt/script/duDefaultService.sh\" >> /etc/rc.d/rc.local\n    ```\n\n    3. 在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\n\n    ```shell\n    chmod +x /etc/rc.d/rc.local\n    ```\n\n- 方法二\n\n    0. 设置sh启动脚本必要参数\n\n    ```shell\n    #!/bin/sh\n    #chkconfig: 2345 80 80\n    #description: auto start web server\n\n    ```\n\n    第一句：必须的\n    声明sh\n    第二句：必须的\n    2345 表示linux 有 0-6种状态 在2345下启动\n    80：表示启动顺序\n    80：表示关闭顺序\n    后面两个参数小于 100\n    第三句：必须的\n    描述\n\n    结果截图如下：\n    {% asset_img WX20190708-113220.png 自动重启服务列表截图 %}\n\n    1. 将脚本移动到/etc/rc.d/init.d目录下\n\n    ```shell\n    mv  /opt/script/duDefaultService.sh /etc/rc.d/init.d\n    ```\n\n    2. 增加脚本的可执行权限\n\n    ```shell\n    chmod +x  /etc/rc.d/init.d/duDefaultService.sh\n    ```\n\n    3. 添加脚本到开机自动启动项目中\n\n    ```shell\n    cd /etc/rc.d/init.d\n    chkconfig --add duDefaultService.sh\n    chkconfig duDefaultService.sh on\n    ```\n\n- 方法三\n\n    1.建立服务文件\n\n    vim /lib/systemd/system/nginx.service\n\n    [Unit]\n\n    Description=nginx\n\n    After=network.target\n\n    [Service]\n\n    Type=forking\n\n    ExecStart=/www/lanmps/init.d/nginx start\n\n    ExecReload=/www/lanmps/init.d/nginx restart\n\n    ExecStop=/www/lanmps/init.d/nginx  stop\n\n    PrivateTmp=true\n\n    [Install]\n\n    WantedBy=multi-user.target\n\n    [Unit]:服务的说明\n\n    Description:描述服务\n\n    After:描述服务类别\n\n    [Service]服务运行参数的设置\n\n    Type=forking是后台运行的形式\n\n    ExecStart为服务的具体运行命令\n\n    ExecReload为重启命令\n\n    ExecStop为停止命令\n\n    PrivateTmp=True表示给服务分配独立的临时空间\n\n    注意：[Service]的启动、重启、停止命令全部要求使用绝对路径\n\n    [Install]服务安装的相关设置，可设置为多用户\n\n    2.保存目录\n\n    以754的权限保存在目录：\n\n    /lib/systemd/system  \n\n    3.设置开机自启动\n\n    systemctl enable nginx.service  \n\n    ```shell\n    systemctl enable XXXX.service\n    ```\n","source":"_posts/centos下开机自动重启服务和脚本.md","raw":"---\ntitle: centos下开机自动重启服务和脚本\ncatalog: true\ndate: 2019-07-08 10:45:59\nsubtitle:\nheader-img:\ntags: linux\n---\n\n1. ### 利用`chkconfig`添加开机自启服务\n\n```shell\nchkconfig\n\n--list 各项服务状态栏显示出来\n--level 设置某个服务在该状态栏显示出来\n\n单独开启某一服务的命令：chkconfig 服务名 on\n\n单独关闭某一服务的命令：chkconfig 服务名 off\n\n查看某一服务的状态：/etc/intd.d/服务名 status\n\n```\n\n我这里以docker 服务为例，设置如下两条命令即可：\n\n```shell\n1  # systemctl enable docker.service #设置docker服务为自启动服务 相当于我们的 chkconfig docker on\n2 # systemctl start docker.service #启动docker服务\n\n```\n\n2. ### 添加开机自启脚本\n\n - 方法一\n\n    1. 赋予脚本可执行权限（/opt/script/duDefaultService.sh是你的脚本路径）\n\n    2. 打开/etc/rc.d/rc.local文件，在末尾增加如下内容\n\n    ```shell\n    echo \"/opt/script/duDefaultService.sh\" >> /etc/rc.d/rc.local\n    ```\n\n    3. 在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\n\n    ```shell\n    chmod +x /etc/rc.d/rc.local\n    ```\n\n- 方法二\n\n    0. 设置sh启动脚本必要参数\n\n    ```shell\n    #!/bin/sh\n    #chkconfig: 2345 80 80\n    #description: auto start web server\n\n    ```\n\n    第一句：必须的\n    声明sh\n    第二句：必须的\n    2345 表示linux 有 0-6种状态 在2345下启动\n    80：表示启动顺序\n    80：表示关闭顺序\n    后面两个参数小于 100\n    第三句：必须的\n    描述\n\n    结果截图如下：\n    {% asset_img WX20190708-113220.png 自动重启服务列表截图 %}\n\n    1. 将脚本移动到/etc/rc.d/init.d目录下\n\n    ```shell\n    mv  /opt/script/duDefaultService.sh /etc/rc.d/init.d\n    ```\n\n    2. 增加脚本的可执行权限\n\n    ```shell\n    chmod +x  /etc/rc.d/init.d/duDefaultService.sh\n    ```\n\n    3. 添加脚本到开机自动启动项目中\n\n    ```shell\n    cd /etc/rc.d/init.d\n    chkconfig --add duDefaultService.sh\n    chkconfig duDefaultService.sh on\n    ```\n\n- 方法三\n\n    1.建立服务文件\n\n    vim /lib/systemd/system/nginx.service\n\n    [Unit]\n\n    Description=nginx\n\n    After=network.target\n\n    [Service]\n\n    Type=forking\n\n    ExecStart=/www/lanmps/init.d/nginx start\n\n    ExecReload=/www/lanmps/init.d/nginx restart\n\n    ExecStop=/www/lanmps/init.d/nginx  stop\n\n    PrivateTmp=true\n\n    [Install]\n\n    WantedBy=multi-user.target\n\n    [Unit]:服务的说明\n\n    Description:描述服务\n\n    After:描述服务类别\n\n    [Service]服务运行参数的设置\n\n    Type=forking是后台运行的形式\n\n    ExecStart为服务的具体运行命令\n\n    ExecReload为重启命令\n\n    ExecStop为停止命令\n\n    PrivateTmp=True表示给服务分配独立的临时空间\n\n    注意：[Service]的启动、重启、停止命令全部要求使用绝对路径\n\n    [Install]服务安装的相关设置，可设置为多用户\n\n    2.保存目录\n\n    以754的权限保存在目录：\n\n    /lib/systemd/system  \n\n    3.设置开机自启动\n\n    systemctl enable nginx.service  \n\n    ```shell\n    systemctl enable XXXX.service\n    ```\n","slug":"centos下开机自动重启服务和脚本","published":1,"updated":"2019-07-23T01:57:31.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55698220004gu1pgd8w178j","content":"<ol>\n<li>\n<h3><span id=\"利用chkconfig添加开机自启服务\">利用<code>chkconfig</code>添加开机自启服务</span></h3>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkconfig</span><br><span class=\"line\"></span><br><span class=\"line\">--list 各项服务状态栏显示出来</span><br><span class=\"line\">--level 设置某个服务在该状态栏显示出来</span><br><span class=\"line\"></span><br><span class=\"line\">单独开启某一服务的命令：chkconfig 服务名 on</span><br><span class=\"line\"></span><br><span class=\"line\">单独关闭某一服务的命令：chkconfig 服务名 off</span><br><span class=\"line\"></span><br><span class=\"line\">查看某一服务的状态：/etc/intd.d/服务名 status</span><br></pre></td></tr></table></figure>\n<p>我这里以docker 服务为例，设置如下两条命令即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  # systemctl enable docker.service #设置docker服务为自启动服务 相当于我们的 chkconfig docker on</span><br><span class=\"line\">2 # systemctl start docker.service #启动docker服务</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<h3><span id=\"添加开机自启脚本\">添加开机自启脚本</span></h3>\n</li>\n</ol>\n<ul>\n<li>\n<p>方法一</p>\n<ol>\n<li>\n<p>赋予脚本可执行权限（/opt/script/duDefaultService.sh是你的脚本路径）</p>\n</li>\n<li>\n<p>打开/etc/rc.d/rc.local文件，在末尾增加如下内容</p>\n</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"/opt/script/duDefaultService.sh\" &gt;&gt; /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方法二</p>\n<ol start=\"0\">\n<li>设置sh启动脚本必要参数</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\"><span class=\"meta\">#</span>chkconfig: 2345 80 80</span><br><span class=\"line\"><span class=\"meta\">#</span>description: auto start web server</span><br></pre></td></tr></table></figure>\n<p>第一句：必须的<br>\n声明sh<br>\n第二句：必须的<br>\n2345 表示linux 有 0-6种状态 在2345下启动<br>\n80：表示启动顺序<br>\n80：表示关闭顺序<br>\n后面两个参数小于 100<br>\n第三句：必须的<br>\n描述</p>\n<p>结果截图如下：</p>\n  <img src=\"/blog/2019/07/08/centos下开机自动重启服务和脚本/WX20190708-113220.png\" title=\"自动重启服务列表截图\">\n<ol>\n<li>将脚本移动到/etc/rc.d/init.d目录下</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv  /opt/script/duDefaultService.sh /etc/rc.d/init.d</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>增加脚本的可执行权限</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x  /etc/rc.d/init.d/duDefaultService.sh</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>添加脚本到开机自动启动项目中</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc/rc.d/init.d</span><br><span class=\"line\">chkconfig --add duDefaultService.sh</span><br><span class=\"line\">chkconfig duDefaultService.sh on</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方法三</p>\n<p>1.建立服务文件</p>\n<p>vim /lib/systemd/system/nginx.service</p>\n<p><a href=\"%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AF%B4%E6%98%8E\">Unit</a></p>\n<p>Description=nginx</p>\n<p>After=network.target</p>\n<p>[Service]</p>\n<p>Type=forking</p>\n<p>ExecStart=/www/lanmps/init.d/nginx start</p>\n<p>ExecReload=/www/lanmps/init.d/nginx restart</p>\n<p>ExecStop=/www/lanmps/init.d/nginx  stop</p>\n<p>PrivateTmp=true</p>\n<p>[Install]</p>\n<p>WantedBy=multi-user.target</p>\n<p>Description:描述服务</p>\n<p>After:描述服务类别</p>\n<p>[Service]服务运行参数的设置</p>\n<p>Type=forking是后台运行的形式</p>\n<p>ExecStart为服务的具体运行命令</p>\n<p>ExecReload为重启命令</p>\n<p>ExecStop为停止命令</p>\n<p>PrivateTmp=True表示给服务分配独立的临时空间</p>\n<p>注意：[Service]的启动、重启、停止命令全部要求使用绝对路径</p>\n<p>[Install]服务安装的相关设置，可设置为多用户</p>\n<p>2.保存目录</p>\n<p>以754的权限保存在目录：</p>\n<p>/lib/systemd/system</p>\n<p>3.设置开机自启动</p>\n<p>systemctl enable nginx.service</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable XXXX.service</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>\n<h3>利用<code>chkconfig</code>添加开机自启服务</h3>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chkconfig</span><br><span class=\"line\"></span><br><span class=\"line\">--list 各项服务状态栏显示出来</span><br><span class=\"line\">--level 设置某个服务在该状态栏显示出来</span><br><span class=\"line\"></span><br><span class=\"line\">单独开启某一服务的命令：chkconfig 服务名 on</span><br><span class=\"line\"></span><br><span class=\"line\">单独关闭某一服务的命令：chkconfig 服务名 off</span><br><span class=\"line\"></span><br><span class=\"line\">查看某一服务的状态：/etc/intd.d/服务名 status</span><br></pre></td></tr></table></figure>\n<p>我这里以docker 服务为例，设置如下两条命令即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1  # systemctl enable docker.service #设置docker服务为自启动服务 相当于我们的 chkconfig docker on</span><br><span class=\"line\">2 # systemctl start docker.service #启动docker服务</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<h3>添加开机自启脚本</h3>\n</li>\n</ol>\n<ul>\n<li>\n<p>方法一</p>\n<ol>\n<li>\n<p>赋予脚本可执行权限（/opt/script/duDefaultService.sh是你的脚本路径）</p>\n</li>\n<li>\n<p>打开/etc/rc.d/rc.local文件，在末尾增加如下内容</p>\n</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"/opt/script/duDefaultService.sh\" &gt;&gt; /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限</li>\n</ol>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方法二</p>\n<ol start=\"0\">\n<li>设置sh启动脚本必要参数</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\"><span class=\"meta\">#</span>chkconfig: 2345 80 80</span><br><span class=\"line\"><span class=\"meta\">#</span>description: auto start web server</span><br></pre></td></tr></table></figure>\n<p>第一句：必须的<br>\n声明sh<br>\n第二句：必须的<br>\n2345 表示linux 有 0-6种状态 在2345下启动<br>\n80：表示启动顺序<br>\n80：表示关闭顺序<br>\n后面两个参数小于 100<br>\n第三句：必须的<br>\n描述</p>\n<p>结果截图如下：</p>\n  <img src=\"/blog/2019/07/08/centos下开机自动重启服务和脚本/WX20190708-113220.png\" title=\"自动重启服务列表截图\">\n<ol>\n<li>将脚本移动到/etc/rc.d/init.d目录下</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv  /opt/script/duDefaultService.sh /etc/rc.d/init.d</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>增加脚本的可执行权限</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x  /etc/rc.d/init.d/duDefaultService.sh</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>添加脚本到开机自动启动项目中</li>\n</ol>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc/rc.d/init.d</span><br><span class=\"line\">chkconfig --add duDefaultService.sh</span><br><span class=\"line\">chkconfig duDefaultService.sh on</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>方法三</p>\n<p>1.建立服务文件</p>\n<p>vim /lib/systemd/system/nginx.service</p>\n<p><a href=\"%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AF%B4%E6%98%8E\">Unit</a></p>\n<p>Description=nginx</p>\n<p>After=network.target</p>\n<p>[Service]</p>\n<p>Type=forking</p>\n<p>ExecStart=/www/lanmps/init.d/nginx start</p>\n<p>ExecReload=/www/lanmps/init.d/nginx restart</p>\n<p>ExecStop=/www/lanmps/init.d/nginx  stop</p>\n<p>PrivateTmp=true</p>\n<p>[Install]</p>\n<p>WantedBy=multi-user.target</p>\n<p>Description:描述服务</p>\n<p>After:描述服务类别</p>\n<p>[Service]服务运行参数的设置</p>\n<p>Type=forking是后台运行的形式</p>\n<p>ExecStart为服务的具体运行命令</p>\n<p>ExecReload为重启命令</p>\n<p>ExecStop为停止命令</p>\n<p>PrivateTmp=True表示给服务分配独立的临时空间</p>\n<p>注意：[Service]的启动、重启、停止命令全部要求使用绝对路径</p>\n<p>[Install]服务安装的相关设置，可设置为多用户</p>\n<p>2.保存目录</p>\n<p>以754的权限保存在目录：</p>\n<p>/lib/systemd/system</p>\n<p>3.设置开机自启动</p>\n<p>systemctl enable nginx.service</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable XXXX.service</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"docker基本使用","catalog":true,"date":"2019-06-19T06:15:03.000Z","subtitle":null,"header-img":null,"_content":"\n本文都是基于`centos7`环境使用\n\n1. 启动 docker\n\n启动配置文件默认`/etc/docker/daemon.json`\n可以修改配置文件指定 docker 服务启动的一些默认参数\n\n- --regisrty-mirror=PROXY_URL 指定拉取镜像的地址加速 Docker 镜像拉取\n\n  2.docker pull NAME[:TAG]\n  默认都是从 `docker`官方仓库去拉取镜像（registry.hub.docker.com）\n  一般直接 pull  \n  比如：\n  `docker`下载`node`的`alpine`版本\n\n```shell\ndocker pull node:10.15-alpine\n```\n\n相当于\n\n```shell\ndocker pull registry.hub.docker.com/ubuntu:node:10.15-alpine\n```\n\n`alpine`是`node`在`docker`运行的最小环境的版本，相比于完整的`node`包体积更小\n\n如果不指定版本默认拉取 `latest`版本，生产环境的时候最好指定版本号，因为`lastest`版本会跟踪最新版本的变更而变化\n\n3.如何进入`未启动`的`node`镜像内部去修改默认一些配置\n\n```shell\ndocker run -it node:10.15-alpine sh\n```\n\n以`shell`脚本的方式去执行`node`命令\n\n4.docker exec ／ docker attach\n\n两者都是进入容器内部\n\n`attach`的不足：\n\n- 多个窗口同时 `attach`同一个容器时候，所有窗口会同步显示；\n- 当某个窗口因命令阻塞，所有窗口都无法执行操作；\n\n进入`已成功运行`的容器内部\n\n```shell\ndocker exec -it 容器名称/容器ID /bin/sh\n```\n\n- -i 支持标准输入\n- -t 开启一个伪终端\n\n  5.docker ps\n\n- docker ps\n  查看已经成功运行的容器（如果运行容器之后 ps 未看到说明容器启动失败）\n- docker ps -a\n  查看所有容器（包含未成功运行的容器）\n- docker ps -f 容器 id  \n   根据容器 id 筛选指定容器\n\n  6.docker run\n\n参数部分\n\n- -d 守护进程方式运行\n- -p 端口映射 （外部访问的端口：docker 内部端口）\n- -u 指定容器的用户\n- -v 挂载存储卷映射 （外部存储卷位置：docker 内部存储卷位置）\n- -h 指定容器的主机名\n- -root\n- --name 容器重命名\n- --rm 容器停止后自动删除\n- --link 关联其它容器\n\n7. 删除\n\ndocker rmi XXX\n\n批量删除失效的容器\n\n```\ndocker rm `docker ps -a -q`\n```\n","source":"_posts/docker基本使用.md","raw":"---\ntitle: docker基本使用\ncatalog: true\ndate: 2019-06-19 14:15:03\nsubtitle:\nheader-img:\ntags: docker\n---\n\n本文都是基于`centos7`环境使用\n\n1. 启动 docker\n\n启动配置文件默认`/etc/docker/daemon.json`\n可以修改配置文件指定 docker 服务启动的一些默认参数\n\n- --regisrty-mirror=PROXY_URL 指定拉取镜像的地址加速 Docker 镜像拉取\n\n  2.docker pull NAME[:TAG]\n  默认都是从 `docker`官方仓库去拉取镜像（registry.hub.docker.com）\n  一般直接 pull  \n  比如：\n  `docker`下载`node`的`alpine`版本\n\n```shell\ndocker pull node:10.15-alpine\n```\n\n相当于\n\n```shell\ndocker pull registry.hub.docker.com/ubuntu:node:10.15-alpine\n```\n\n`alpine`是`node`在`docker`运行的最小环境的版本，相比于完整的`node`包体积更小\n\n如果不指定版本默认拉取 `latest`版本，生产环境的时候最好指定版本号，因为`lastest`版本会跟踪最新版本的变更而变化\n\n3.如何进入`未启动`的`node`镜像内部去修改默认一些配置\n\n```shell\ndocker run -it node:10.15-alpine sh\n```\n\n以`shell`脚本的方式去执行`node`命令\n\n4.docker exec ／ docker attach\n\n两者都是进入容器内部\n\n`attach`的不足：\n\n- 多个窗口同时 `attach`同一个容器时候，所有窗口会同步显示；\n- 当某个窗口因命令阻塞，所有窗口都无法执行操作；\n\n进入`已成功运行`的容器内部\n\n```shell\ndocker exec -it 容器名称/容器ID /bin/sh\n```\n\n- -i 支持标准输入\n- -t 开启一个伪终端\n\n  5.docker ps\n\n- docker ps\n  查看已经成功运行的容器（如果运行容器之后 ps 未看到说明容器启动失败）\n- docker ps -a\n  查看所有容器（包含未成功运行的容器）\n- docker ps -f 容器 id  \n   根据容器 id 筛选指定容器\n\n  6.docker run\n\n参数部分\n\n- -d 守护进程方式运行\n- -p 端口映射 （外部访问的端口：docker 内部端口）\n- -u 指定容器的用户\n- -v 挂载存储卷映射 （外部存储卷位置：docker 内部存储卷位置）\n- -h 指定容器的主机名\n- -root\n- --name 容器重命名\n- --rm 容器停止后自动删除\n- --link 关联其它容器\n\n7. 删除\n\ndocker rmi XXX\n\n批量删除失效的容器\n\n```\ndocker rm `docker ps -a -q`\n```\n","slug":"docker基本使用","published":1,"updated":"2019-09-04T03:40:35.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55698260007gu1p8zqdkbl2","content":"<p>本文都是基于<code>centos7</code>环境使用</p>\n<ol>\n<li>启动 docker</li>\n</ol>\n<p>启动配置文件默认<code>/etc/docker/daemon.json</code><br>\n可以修改配置文件指定 docker 服务启动的一些默认参数</p>\n<ul>\n<li>\n<p>–regisrty-mirror=PROXY_URL 指定拉取镜像的地址加速 Docker 镜像拉取</p>\n<p>2.docker pull NAME[:TAG]<br>\n默认都是从 <code>docker</code>官方仓库去拉取镜像（<a href=\"http://registry.hub.docker.com\" target=\"_blank\" rel=\"noopener\">registry.hub.docker.com</a>）<br>\n一般直接 pull<br>\n比如：<br>\n<code>docker</code>下载<code>node</code>的<code>alpine</code>版本</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull node:10.15-alpine</span><br></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull registry.hub.docker.com/ubuntu:node:10.15-alpine</span><br></pre></td></tr></table></figure>\n<p><code>alpine</code>是<code>node</code>在<code>docker</code>运行的最小环境的版本，相比于完整的<code>node</code>包体积更小</p>\n<p>如果不指定版本默认拉取 <code>latest</code>版本，生产环境的时候最好指定版本号，因为<code>lastest</code>版本会跟踪最新版本的变更而变化</p>\n<p>3.如何进入<code>未启动</code>的<code>node</code>镜像内部去修改默认一些配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it node:10.15-alpine sh</span><br></pre></td></tr></table></figure>\n<p>以<code>shell</code>脚本的方式去执行<code>node</code>命令</p>\n<p>4.docker exec ／ docker attach</p>\n<p>两者都是进入容器内部</p>\n<p><code>attach</code>的不足：</p>\n<ul>\n<li>多个窗口同时 <code>attach</code>同一个容器时候，所有窗口会同步显示；</li>\n<li>当某个窗口因命令阻塞，所有窗口都无法执行操作；</li>\n</ul>\n<p>进入<code>已成功运行</code>的容器内部</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it 容器名称/容器ID /bin/sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>-i 支持标准输入</p>\n</li>\n<li>\n<p>-t 开启一个伪终端</p>\n<p>5.docker ps</p>\n</li>\n<li>\n<p>docker ps<br>\n查看已经成功运行的容器（如果运行容器之后 ps 未看到说明容器启动失败）</p>\n</li>\n<li>\n<p>docker ps -a<br>\n查看所有容器（包含未成功运行的容器）</p>\n</li>\n<li>\n<p>docker ps -f 容器 id<br>\n根据容器 id 筛选指定容器</p>\n<p>6.docker run</p>\n</li>\n</ul>\n<p>参数部分</p>\n<ul>\n<li>-d 守护进程方式运行</li>\n<li>-p 端口映射 （外部访问的端口：docker 内部端口）</li>\n<li>-u 指定容器的用户</li>\n<li>-v 挂载存储卷映射 （外部存储卷位置：docker 内部存储卷位置）</li>\n<li>-h 指定容器的主机名</li>\n<li>-root</li>\n<li>–name 容器重命名</li>\n<li>–rm 容器停止后自动删除</li>\n<li>–link 关联其它容器</li>\n</ul>\n<ol start=\"7\">\n<li>删除</li>\n</ol>\n<p>docker rmi XXX</p>\n<p>批量删除失效的容器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>本文都是基于<code>centos7</code>环境使用</p>\n<ol>\n<li>启动 docker</li>\n</ol>\n<p>启动配置文件默认<code>/etc/docker/daemon.json</code><br>\n可以修改配置文件指定 docker 服务启动的一些默认参数</p>\n<ul>\n<li>\n<p>–regisrty-mirror=PROXY_URL 指定拉取镜像的地址加速 Docker 镜像拉取</p>\n<p>2.docker pull NAME[:TAG]<br>\n默认都是从 <code>docker</code>官方仓库去拉取镜像（<a href=\"http://registry.hub.docker.com\" target=\"_blank\" rel=\"noopener\">registry.hub.docker.com</a>）<br>\n一般直接 pull<br>\n比如：<br>\n<code>docker</code>下载<code>node</code>的<code>alpine</code>版本</p>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull node:10.15-alpine</span><br></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull registry.hub.docker.com/ubuntu:node:10.15-alpine</span><br></pre></td></tr></table></figure>\n<p><code>alpine</code>是<code>node</code>在<code>docker</code>运行的最小环境的版本，相比于完整的<code>node</code>包体积更小</p>\n<p>如果不指定版本默认拉取 <code>latest</code>版本，生产环境的时候最好指定版本号，因为<code>lastest</code>版本会跟踪最新版本的变更而变化</p>\n<p>3.如何进入<code>未启动</code>的<code>node</code>镜像内部去修改默认一些配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it node:10.15-alpine sh</span><br></pre></td></tr></table></figure>\n<p>以<code>shell</code>脚本的方式去执行<code>node</code>命令</p>\n<p>4.docker exec ／ docker attach</p>\n<p>两者都是进入容器内部</p>\n<p><code>attach</code>的不足：</p>\n<ul>\n<li>多个窗口同时 <code>attach</code>同一个容器时候，所有窗口会同步显示；</li>\n<li>当某个窗口因命令阻塞，所有窗口都无法执行操作；</li>\n</ul>\n<p>进入<code>已成功运行</code>的容器内部</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it 容器名称/容器ID /bin/sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>-i 支持标准输入</p>\n</li>\n<li>\n<p>-t 开启一个伪终端</p>\n<p>5.docker ps</p>\n</li>\n<li>\n<p>docker ps<br>\n查看已经成功运行的容器（如果运行容器之后 ps 未看到说明容器启动失败）</p>\n</li>\n<li>\n<p>docker ps -a<br>\n查看所有容器（包含未成功运行的容器）</p>\n</li>\n<li>\n<p>docker ps -f 容器 id<br>\n根据容器 id 筛选指定容器</p>\n<p>6.docker run</p>\n</li>\n</ul>\n<p>参数部分</p>\n<ul>\n<li>-d 守护进程方式运行</li>\n<li>-p 端口映射 （外部访问的端口：docker 内部端口）</li>\n<li>-u 指定容器的用户</li>\n<li>-v 挂载存储卷映射 （外部存储卷位置：docker 内部存储卷位置）</li>\n<li>-h 指定容器的主机名</li>\n<li>-root</li>\n<li>–name 容器重命名</li>\n<li>–rm 容器停止后自动删除</li>\n<li>–link 关联其它容器</li>\n</ul>\n<ol start=\"7\">\n<li>删除</li>\n</ol>\n<p>docker rmi XXX</p>\n<p>批量删除失效的容器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure>\n"},{"title":"git submodule","catalog":true,"date":"2019-07-10T08:31:04.000Z","subtitle":null,"header-img":null,"_content":"\n子模块一些操作方法：\n\n- 克隆带有子模块的项目\n\n```shell\ngit clone --recursive 远程地址\n```\n\n- 拉取子模块更新\n\n```shell\ngit submodule update --remote\n```\n\n- 提交子模块修改（需要切换到`master`分支）\n\n```shell\ngit add .\ngit commit -m 'xxxx'\ngit push origin master\n```\n\n- 删除子模块\n\n```shell\ngit submodule deinit themes/hugo-nuo\nvim .gitmodules # 移除要删除的子模块\ngit add .gitmodules\ngit rm --cached themes/hugo-nuo\nrm -rf .git/modules/themes/hugo-nuo\nrm -rf themes/hugo-nuo\ngit commit -m \"Remove submodule themes/hugo-nuo\"\n```\n\n参考链接： 1. [Git Submodule 的使用](https://www.jianshu.com/p/0107698498af) 2. [Git Submodule](https://laozhu.me/post/git-submodule-tutorial/)\n\n使用过程中遇到的问题：\n\n1. `jenkins`构建过程中，使用 http 方式拉取子模块一直提示需要输入账号密码，将账号密码放在 url 前面\n\n```shell\n\ngit config submodule.H5-Base.url http://账号:密码@远程地址/app/H5-Base.git\n\n\ngit submodule init\ngit submodule update --remote\n\nyarn install\ngit submodule foreach 'yarn install'\nyarn build\n```\n","source":"_posts/git-submodule.md","raw":"---\ntitle: git submodule\ncatalog: true\ndate: 2019-07-10 16:31:04\nsubtitle:\nheader-img:\ntags: web\n---\n\n子模块一些操作方法：\n\n- 克隆带有子模块的项目\n\n```shell\ngit clone --recursive 远程地址\n```\n\n- 拉取子模块更新\n\n```shell\ngit submodule update --remote\n```\n\n- 提交子模块修改（需要切换到`master`分支）\n\n```shell\ngit add .\ngit commit -m 'xxxx'\ngit push origin master\n```\n\n- 删除子模块\n\n```shell\ngit submodule deinit themes/hugo-nuo\nvim .gitmodules # 移除要删除的子模块\ngit add .gitmodules\ngit rm --cached themes/hugo-nuo\nrm -rf .git/modules/themes/hugo-nuo\nrm -rf themes/hugo-nuo\ngit commit -m \"Remove submodule themes/hugo-nuo\"\n```\n\n参考链接： 1. [Git Submodule 的使用](https://www.jianshu.com/p/0107698498af) 2. [Git Submodule](https://laozhu.me/post/git-submodule-tutorial/)\n\n使用过程中遇到的问题：\n\n1. `jenkins`构建过程中，使用 http 方式拉取子模块一直提示需要输入账号密码，将账号密码放在 url 前面\n\n```shell\n\ngit config submodule.H5-Base.url http://账号:密码@远程地址/app/H5-Base.git\n\n\ngit submodule init\ngit submodule update --remote\n\nyarn install\ngit submodule foreach 'yarn install'\nyarn build\n```\n","slug":"git-submodule","published":1,"updated":"2019-07-23T01:57:31.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55698270008gu1ppxvz6b43","content":"<p>子模块一些操作方法：</p>\n<ul>\n<li>克隆带有子模块的项目</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --recursive 远程地址</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拉取子模块更新</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --remote</span><br></pre></td></tr></table></figure>\n<ul>\n<li>提交子模块修改（需要切换到<code>master</code>分支）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m 'xxxx'</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除子模块</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule deinit themes/hugo-nuo</span><br><span class=\"line\">vim .gitmodules # 移除要删除的子模块</span><br><span class=\"line\">git add .gitmodules</span><br><span class=\"line\">git rm --cached themes/hugo-nuo</span><br><span class=\"line\">rm -rf .git/modules/themes/hugo-nuo</span><br><span class=\"line\">rm -rf themes/hugo-nuo</span><br><span class=\"line\">git commit -m \"Remove submodule themes/hugo-nuo\"</span><br></pre></td></tr></table></figure>\n<p>参考链接： 1. <a href=\"https://www.jianshu.com/p/0107698498af\" target=\"_blank\" rel=\"noopener\">Git Submodule 的使用</a> 2. <a href=\"https://laozhu.me/post/git-submodule-tutorial/\" target=\"_blank\" rel=\"noopener\">Git Submodule</a></p>\n<p>使用过程中遇到的问题：</p>\n<ol>\n<li><code>jenkins</code>构建过程中，使用 http 方式拉取子模块一直提示需要输入账号密码，将账号密码放在 url 前面</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">git config submodule.H5-Base.url http://账号:密码@远程地址/app/H5-Base.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">git submodule init</span><br><span class=\"line\">git submodule update --remote</span><br><span class=\"line\"></span><br><span class=\"line\">yarn install</span><br><span class=\"line\">git submodule foreach 'yarn install'</span><br><span class=\"line\">yarn build</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>子模块一些操作方法：</p>\n<ul>\n<li>克隆带有子模块的项目</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --recursive 远程地址</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拉取子模块更新</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule update --remote</span><br></pre></td></tr></table></figure>\n<ul>\n<li>提交子模块修改（需要切换到<code>master</code>分支）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m 'xxxx'</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除子模块</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git submodule deinit themes/hugo-nuo</span><br><span class=\"line\">vim .gitmodules # 移除要删除的子模块</span><br><span class=\"line\">git add .gitmodules</span><br><span class=\"line\">git rm --cached themes/hugo-nuo</span><br><span class=\"line\">rm -rf .git/modules/themes/hugo-nuo</span><br><span class=\"line\">rm -rf themes/hugo-nuo</span><br><span class=\"line\">git commit -m \"Remove submodule themes/hugo-nuo\"</span><br></pre></td></tr></table></figure>\n<p>参考链接： 1. <a href=\"https://www.jianshu.com/p/0107698498af\" target=\"_blank\" rel=\"noopener\">Git Submodule 的使用</a> 2. <a href=\"https://laozhu.me/post/git-submodule-tutorial/\" target=\"_blank\" rel=\"noopener\">Git Submodule</a></p>\n<p>使用过程中遇到的问题：</p>\n<ol>\n<li><code>jenkins</code>构建过程中，使用 http 方式拉取子模块一直提示需要输入账号密码，将账号密码放在 url 前面</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">git config submodule.H5-Base.url http://账号:密码@远程地址/app/H5-Base.git</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">git submodule init</span><br><span class=\"line\">git submodule update --remote</span><br><span class=\"line\"></span><br><span class=\"line\">yarn install</span><br><span class=\"line\">git submodule foreach 'yarn install'</span><br><span class=\"line\">yarn build</span><br></pre></td></tr></table></figure>\n"},{"title":"git常用命令","catalog":true,"date":"2019-04-25T07:55:22.000Z","subtitle":null,"header-img":null,"_content":"\n1. 记录账户密码，不用每次 pull/push 都输入账号密码\n\n   在指定项目下，或者全局的根目录下输入如下命令，再执行 pull 之后输入账号密码，以后就不用再输入了\n\n   ```shell\n     git config --global credential.helper store\n   ```\n\n2. git 回退版本\n\n   - 本地回退到指定版本\n\n   ```shell\n     git reset --hard commit_id\n   ```\n\n- 远程强制回退到指定版本\n\n  ```shell\n    git push origin HEAD --force\n  ```\n\n3. git rebase\n   指定要合并 commit 的 id（不包含这个 commit）\n\n   ```shell\n     git rebase -i commit_id\n   ```\n\n   交互操作： s 合并 commit 记录 p 选中当前 commit 记录\n\n4. git tag\n   打标签\n\n```shell\n  git tag v1.0.0\n```\n\n删除标签\n\n```shell\n给标签加注释-m 指定标签版本 -a\n```\n\ngit tag -a v0.1.0 -m “0.1.2 版本”\n\n```shell\ngit tag -d v1.0.0\n```\n\n推送某次标签 和 本地全部标签\n\n```\ngit push origin v1.0.0\ngit push origin –tags\n```\n\n5. 项目迁移到新仓库\n\n```\ngit remote rename origin old-origin\ngit remote add origin 远程地址\ngit remote rm old-origin\ngit push -u origin --all\ngit push -u origin --tags\n```\n\n6. 导出私钥\n\n没有设置 ssh 的话，拉取代码会报`Permission denied, please try again`\n\n导出公私钥的方式`ssh-keygen -t rsa -C \"xxxx@xxxx.com\"`会生成 id_rsa 和 id_rsa.pub 两个文件，将 id_rsa.pub 拷贝到 gitlab 对应的远程仓库的 ssh keys 列表里面\n","source":"_posts/git常用命令.md","raw":"---\ntitle: git常用命令\ncatalog: true\ndate: 2019-04-25 15:55:22\nsubtitle:\nheader-img:\ntags: git\n---\n\n1. 记录账户密码，不用每次 pull/push 都输入账号密码\n\n   在指定项目下，或者全局的根目录下输入如下命令，再执行 pull 之后输入账号密码，以后就不用再输入了\n\n   ```shell\n     git config --global credential.helper store\n   ```\n\n2. git 回退版本\n\n   - 本地回退到指定版本\n\n   ```shell\n     git reset --hard commit_id\n   ```\n\n- 远程强制回退到指定版本\n\n  ```shell\n    git push origin HEAD --force\n  ```\n\n3. git rebase\n   指定要合并 commit 的 id（不包含这个 commit）\n\n   ```shell\n     git rebase -i commit_id\n   ```\n\n   交互操作： s 合并 commit 记录 p 选中当前 commit 记录\n\n4. git tag\n   打标签\n\n```shell\n  git tag v1.0.0\n```\n\n删除标签\n\n```shell\n给标签加注释-m 指定标签版本 -a\n```\n\ngit tag -a v0.1.0 -m “0.1.2 版本”\n\n```shell\ngit tag -d v1.0.0\n```\n\n推送某次标签 和 本地全部标签\n\n```\ngit push origin v1.0.0\ngit push origin –tags\n```\n\n5. 项目迁移到新仓库\n\n```\ngit remote rename origin old-origin\ngit remote add origin 远程地址\ngit remote rm old-origin\ngit push -u origin --all\ngit push -u origin --tags\n```\n\n6. 导出私钥\n\n没有设置 ssh 的话，拉取代码会报`Permission denied, please try again`\n\n导出公私钥的方式`ssh-keygen -t rsa -C \"xxxx@xxxx.com\"`会生成 id_rsa 和 id_rsa.pub 两个文件，将 id_rsa.pub 拷贝到 gitlab 对应的远程仓库的 ssh keys 列表里面\n","slug":"git常用命令","published":1,"updated":"2019-09-20T08:11:44.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck55698290009gu1p5uauto9w","content":"<ol>\n<li>\n<p>记录账户密码，不用每次 pull/push 都输入账号密码</p>\n<p>在指定项目下，或者全局的根目录下输入如下命令，再执行 pull 之后输入账号密码，以后就不用再输入了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global credential.helper store</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>git 回退版本</p>\n<ul>\n<li>本地回退到指定版本</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard commit_id</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>\n<p>远程强制回退到指定版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin HEAD --force</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>git rebase<br>\n指定要合并 commit 的 id（不包含这个 commit）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i commit_id</span><br></pre></td></tr></table></figure>\n<p>交互操作： s 合并 commit 记录 p 选中当前 commit 记录</p>\n</li>\n<li>\n<p>git tag<br>\n打标签</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0.0</span><br></pre></td></tr></table></figure>\n<p>删除标签</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给标签加注释-m 指定标签版本 -a</span><br></pre></td></tr></table></figure>\n<p>git tag -a v0.1.0 -m “0.1.2 版本”</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d v1.0.0</span><br></pre></td></tr></table></figure>\n<p>推送某次标签 和 本地全部标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin v1.0.0</span><br><span class=\"line\">git push origin –tags</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>项目迁移到新仓库</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rename origin old-origin</span><br><span class=\"line\">git remote add origin 远程地址</span><br><span class=\"line\">git remote rm old-origin</span><br><span class=\"line\">git push -u origin --all</span><br><span class=\"line\">git push -u origin --tags</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>导出私钥</li>\n</ol>\n<p>没有设置 ssh 的话，拉取代码会报<code>Permission denied, please try again</code></p>\n<p>导出公私钥的方式<code>ssh-keygen -t rsa -C &quot;xxxx@xxxx.com&quot;</code>会生成 id_rsa 和 id_rsa.pub 两个文件，将 id_rsa.pub 拷贝到 gitlab 对应的远程仓库的 ssh keys 列表里面</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>\n<p>记录账户密码，不用每次 pull/push 都输入账号密码</p>\n<p>在指定项目下，或者全局的根目录下输入如下命令，再执行 pull 之后输入账号密码，以后就不用再输入了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global credential.helper store</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>git 回退版本</p>\n<ul>\n<li>本地回退到指定版本</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard commit_id</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>\n<p>远程强制回退到指定版本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin HEAD --force</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>git rebase<br>\n指定要合并 commit 的 id（不包含这个 commit）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i commit_id</span><br></pre></td></tr></table></figure>\n<p>交互操作： s 合并 commit 记录 p 选中当前 commit 记录</p>\n</li>\n<li>\n<p>git tag<br>\n打标签</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v1.0.0</span><br></pre></td></tr></table></figure>\n<p>删除标签</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给标签加注释-m 指定标签版本 -a</span><br></pre></td></tr></table></figure>\n<p>git tag -a v0.1.0 -m “0.1.2 版本”</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag -d v1.0.0</span><br></pre></td></tr></table></figure>\n<p>推送某次标签 和 本地全部标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin v1.0.0</span><br><span class=\"line\">git push origin –tags</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>项目迁移到新仓库</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rename origin old-origin</span><br><span class=\"line\">git remote add origin 远程地址</span><br><span class=\"line\">git remote rm old-origin</span><br><span class=\"line\">git push -u origin --all</span><br><span class=\"line\">git push -u origin --tags</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>导出私钥</li>\n</ol>\n<p>没有设置 ssh 的话，拉取代码会报<code>Permission denied, please try again</code></p>\n<p>导出公私钥的方式<code>ssh-keygen -t rsa -C &quot;xxxx@xxxx.com&quot;</code>会生成 id_rsa 和 id_rsa.pub 两个文件，将 id_rsa.pub 拷贝到 gitlab 对应的远程仓库的 ssh keys 列表里面</p>\n"},{"title":"js中几种设计模式","catalog":true,"date":"2019-07-14T13:50:10.000Z","subtitle":null,"header-img":null,"_content":"\n1. 工厂模式\n\n> TODO\n\n```javascript\nclass Product  {\n    constructor (name) {\n        this.name = name\n    }\n}\n\nclass Creator {\n    create (name) {\n        return new Product(name)\n    }\n}\n\nconst creatorInstance = new Creator()\n\ncreatorInstance.create('张三')\n```\n\n应用场景：TODO\n\n2. 单例模式\n\n> 一个类只有一个实例，并提供全局访问的方法，一般用于登录、购物车等场景\n\n```javascript\nclass Single {\n    login () {}\n    shopping () {}\n}\n\nSingle.getInstance = (function () {\n    let Instance\n    return () => {\n        if (!Instance) {\n                Instance = new Single()\n        }\n        return Instance\n    }\n})()\n\nconst signleInstanceA = Single.getInstance()\nconst signleInstanceB = Single.getInstance()\nconsole.log(signleInstanceA === signleInstanceB) // true\n```\n\n应用场景：TODO\n\n3. 适配器模式\n\n> 用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问\n\n```javascript\nclass Adapter {\n    money () {\n        return '人民币'\n    }\n}\n\nclass AdapterWrapper {\n    constructor () {\n        this.Adapter = new Adapter()\n    }\n\n    m2$ () {\n        const m = this.Adapter.money()\n        return `人民币兑换成美元`\n    }\n}\n\nconst adapterWrapper = new AdapterWrapper()\nadapterWrapper.m2$()\n```\n\n应用场景：多个对象合并成一个对象\n\n4. 装饰器模式（AOP编程）\n\n> 在不改变源对象的自身方法的基础上，给源对象自身方法提供新的功能\n\n```javascript\nclass Source {\n    add (a, b) {\n        return a + b\n    }\n}\n\nclass DecorateSource {\n    constructor () {\n        this.source = new Source()\n    }\n    add (a, b) {\n        console.log('传入的参数为', a, b)\n        return this.source.add(a, b)\n    }\n}\n\nconst decorateSource = new DecorateSource()\ndecorateSource.add(1, 2) // 传入的参数为 1 2     3\n```\n\n应用场景：\n\n- 处理ajax异常上报，数据分析\n- Vue中处理数组变异方法\n\n5. 观察者模式\n\n> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知\n\n```javascript\nclass Sub {\n    constructor () {\n        this.observers = []\n    }\n    attach (observer) {\n        this.observers.push(observer)\n    }\n    notify () {\n        this.observers.forEach(observer => {\n            observer.update()\n        } )\n    }\n}\n\nclass Observer {\n    constructor (name) {\n        this.name = name\n    }\n    update () {\n        console.log(`${this.name}触发更新`)\n    }\n}\n\nconst observerA = new Observer('A')\nconst observerB = new Observer('B')\nconst sub = new Sub()\nsub.attach(observerA)\nsub.attach(observerB)\nsub.notify()\n\n```\n\n应用场景：JS事件、promise、Vue的watch方法\n\n与订阅/发布模式区别 主要在于调度不同。观察者模式由具体目标方法调度，而订阅发布模式由统一调度中心去调度，所以观察者模式的观察者和目标会有依赖，而后者没有。\n","source":"_posts/js中几种设计模式.md","raw":"---\ntitle: js中几种设计模式\ncatalog: true\ndate: 2019-07-14 21:50:10\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n1. 工厂模式\n\n> TODO\n\n```javascript\nclass Product  {\n    constructor (name) {\n        this.name = name\n    }\n}\n\nclass Creator {\n    create (name) {\n        return new Product(name)\n    }\n}\n\nconst creatorInstance = new Creator()\n\ncreatorInstance.create('张三')\n```\n\n应用场景：TODO\n\n2. 单例模式\n\n> 一个类只有一个实例，并提供全局访问的方法，一般用于登录、购物车等场景\n\n```javascript\nclass Single {\n    login () {}\n    shopping () {}\n}\n\nSingle.getInstance = (function () {\n    let Instance\n    return () => {\n        if (!Instance) {\n                Instance = new Single()\n        }\n        return Instance\n    }\n})()\n\nconst signleInstanceA = Single.getInstance()\nconst signleInstanceB = Single.getInstance()\nconsole.log(signleInstanceA === signleInstanceB) // true\n```\n\n应用场景：TODO\n\n3. 适配器模式\n\n> 用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问\n\n```javascript\nclass Adapter {\n    money () {\n        return '人民币'\n    }\n}\n\nclass AdapterWrapper {\n    constructor () {\n        this.Adapter = new Adapter()\n    }\n\n    m2$ () {\n        const m = this.Adapter.money()\n        return `人民币兑换成美元`\n    }\n}\n\nconst adapterWrapper = new AdapterWrapper()\nadapterWrapper.m2$()\n```\n\n应用场景：多个对象合并成一个对象\n\n4. 装饰器模式（AOP编程）\n\n> 在不改变源对象的自身方法的基础上，给源对象自身方法提供新的功能\n\n```javascript\nclass Source {\n    add (a, b) {\n        return a + b\n    }\n}\n\nclass DecorateSource {\n    constructor () {\n        this.source = new Source()\n    }\n    add (a, b) {\n        console.log('传入的参数为', a, b)\n        return this.source.add(a, b)\n    }\n}\n\nconst decorateSource = new DecorateSource()\ndecorateSource.add(1, 2) // 传入的参数为 1 2     3\n```\n\n应用场景：\n\n- 处理ajax异常上报，数据分析\n- Vue中处理数组变异方法\n\n5. 观察者模式\n\n> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知\n\n```javascript\nclass Sub {\n    constructor () {\n        this.observers = []\n    }\n    attach (observer) {\n        this.observers.push(observer)\n    }\n    notify () {\n        this.observers.forEach(observer => {\n            observer.update()\n        } )\n    }\n}\n\nclass Observer {\n    constructor (name) {\n        this.name = name\n    }\n    update () {\n        console.log(`${this.name}触发更新`)\n    }\n}\n\nconst observerA = new Observer('A')\nconst observerB = new Observer('B')\nconst sub = new Sub()\nsub.attach(observerA)\nsub.attach(observerB)\nsub.notify()\n\n```\n\n应用场景：JS事件、promise、Vue的watch方法\n\n与订阅/发布模式区别 主要在于调度不同。观察者模式由具体目标方法调度，而订阅发布模式由统一调度中心去调度，所以观察者模式的观察者和目标会有依赖，而后者没有。\n","slug":"js中几种设计模式","published":1,"updated":"2019-07-23T01:57:31.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982c000cgu1pci28w7z4","content":"<ol>\n<li>工厂模式</li>\n</ol>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Creator</span> </span>&#123;</span><br><span class=\"line\">    create (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Product(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> creatorInstance = <span class=\"keyword\">new</span> Creator()</span><br><span class=\"line\"></span><br><span class=\"line\">creatorInstance.create(<span class=\"string\">'张三'</span>)</span><br></pre></td></tr></table></figure>\n<p>应用场景：TODO</p>\n<ol start=\"2\">\n<li>单例模式</li>\n</ol>\n<blockquote>\n<p>一个类只有一个实例，并提供全局访问的方法，一般用于登录、购物车等场景</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</span><br><span class=\"line\">    login () &#123;&#125;</span><br><span class=\"line\">    shopping () &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Single.getInstance = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Instance</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Instance) &#123;</span><br><span class=\"line\">                Instance = <span class=\"keyword\">new</span> Single()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Instance</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> signleInstanceA = Single.getInstance()</span><br><span class=\"line\"><span class=\"keyword\">const</span> signleInstanceB = Single.getInstance()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(signleInstanceA === signleInstanceB) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>应用场景：TODO</p>\n<ol start=\"3\">\n<li>适配器模式</li>\n</ol>\n<blockquote>\n<p>用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> </span>&#123;</span><br><span class=\"line\">    money () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'人民币'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdapterWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.Adapter = <span class=\"keyword\">new</span> Adapter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m2$ () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> m = <span class=\"keyword\">this</span>.Adapter.money()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`人民币兑换成美元`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> adapterWrapper = <span class=\"keyword\">new</span> AdapterWrapper()</span><br><span class=\"line\">adapterWrapper.m2$()</span><br></pre></td></tr></table></figure>\n<p>应用场景：多个对象合并成一个对象</p>\n<ol start=\"4\">\n<li>装饰器模式（AOP编程）</li>\n</ol>\n<blockquote>\n<p>在不改变源对象的自身方法的基础上，给源对象自身方法提供新的功能</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Source</span> </span>&#123;</span><br><span class=\"line\">    add (a, b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecorateSource</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.source = <span class=\"keyword\">new</span> Source()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add (a, b) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'传入的参数为'</span>, a, b)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.source.add(a, b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decorateSource = <span class=\"keyword\">new</span> DecorateSource()</span><br><span class=\"line\">decorateSource.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 传入的参数为 1 2     3</span></span><br></pre></td></tr></table></figure>\n<p>应用场景：</p>\n<ul>\n<li>处理ajax异常上报，数据分析</li>\n<li>Vue中处理数组变异方法</li>\n</ul>\n<ol start=\"5\">\n<li>观察者模式</li>\n</ol>\n<blockquote>\n<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    attach (observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers.push(observer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    notify () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">observer</span> =&gt;</span> &#123;</span><br><span class=\"line\">            observer.update()</span><br><span class=\"line\">        &#125; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span>触发更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> observerA = <span class=\"keyword\">new</span> Observer(<span class=\"string\">'A'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> observerB = <span class=\"keyword\">new</span> Observer(<span class=\"string\">'B'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> sub = <span class=\"keyword\">new</span> Sub()</span><br><span class=\"line\">sub.attach(observerA)</span><br><span class=\"line\">sub.attach(observerB)</span><br><span class=\"line\">sub.notify()</span><br></pre></td></tr></table></figure>\n<p>应用场景：JS事件、promise、Vue的watch方法</p>\n<p>与订阅/发布模式区别 主要在于调度不同。观察者模式由具体目标方法调度，而订阅发布模式由统一调度中心去调度，所以观察者模式的观察者和目标会有依赖，而后者没有。</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>工厂模式</li>\n</ol>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Creator</span> </span>&#123;</span><br><span class=\"line\">    create (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Product(name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> creatorInstance = <span class=\"keyword\">new</span> Creator()</span><br><span class=\"line\"></span><br><span class=\"line\">creatorInstance.create(<span class=\"string\">'张三'</span>)</span><br></pre></td></tr></table></figure>\n<p>应用场景：TODO</p>\n<ol start=\"2\">\n<li>单例模式</li>\n</ol>\n<blockquote>\n<p>一个类只有一个实例，并提供全局访问的方法，一般用于登录、购物车等场景</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span> </span>&#123;</span><br><span class=\"line\">    login () &#123;&#125;</span><br><span class=\"line\">    shopping () &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Single.getInstance = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Instance</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Instance) &#123;</span><br><span class=\"line\">                Instance = <span class=\"keyword\">new</span> Single()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Instance</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> signleInstanceA = Single.getInstance()</span><br><span class=\"line\"><span class=\"keyword\">const</span> signleInstanceB = Single.getInstance()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(signleInstanceA === signleInstanceB) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>应用场景：TODO</p>\n<ol start=\"3\">\n<li>适配器模式</li>\n</ol>\n<blockquote>\n<p>用来解决两个接口不兼容问题，由一个对象来包装不兼容的对象，比如参数转换，允许直接访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> </span>&#123;</span><br><span class=\"line\">    money () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'人民币'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdapterWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.Adapter = <span class=\"keyword\">new</span> Adapter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m2$ () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> m = <span class=\"keyword\">this</span>.Adapter.money()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`人民币兑换成美元`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> adapterWrapper = <span class=\"keyword\">new</span> AdapterWrapper()</span><br><span class=\"line\">adapterWrapper.m2$()</span><br></pre></td></tr></table></figure>\n<p>应用场景：多个对象合并成一个对象</p>\n<ol start=\"4\">\n<li>装饰器模式（AOP编程）</li>\n</ol>\n<blockquote>\n<p>在不改变源对象的自身方法的基础上，给源对象自身方法提供新的功能</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Source</span> </span>&#123;</span><br><span class=\"line\">    add (a, b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecorateSource</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.source = <span class=\"keyword\">new</span> Source()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add (a, b) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'传入的参数为'</span>, a, b)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.source.add(a, b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> decorateSource = <span class=\"keyword\">new</span> DecorateSource()</span><br><span class=\"line\">decorateSource.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 传入的参数为 1 2     3</span></span><br></pre></td></tr></table></figure>\n<p>应用场景：</p>\n<ul>\n<li>处理ajax异常上报，数据分析</li>\n<li>Vue中处理数组变异方法</li>\n</ul>\n<ol start=\"5\">\n<li>观察者模式</li>\n</ol>\n<blockquote>\n<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    attach (observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers.push(observer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    notify () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.observers.forEach(<span class=\"function\"><span class=\"params\">observer</span> =&gt;</span> &#123;</span><br><span class=\"line\">            observer.update()</span><br><span class=\"line\">        &#125; )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.name&#125;</span>触发更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> observerA = <span class=\"keyword\">new</span> Observer(<span class=\"string\">'A'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> observerB = <span class=\"keyword\">new</span> Observer(<span class=\"string\">'B'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> sub = <span class=\"keyword\">new</span> Sub()</span><br><span class=\"line\">sub.attach(observerA)</span><br><span class=\"line\">sub.attach(observerB)</span><br><span class=\"line\">sub.notify()</span><br></pre></td></tr></table></figure>\n<p>应用场景：JS事件、promise、Vue的watch方法</p>\n<p>与订阅/发布模式区别 主要在于调度不同。观察者模式由具体目标方法调度，而订阅发布模式由统一调度中心去调度，所以观察者模式的观察者和目标会有依赖，而后者没有。</p>\n"},{"title":"js继承问题总结","catalog":true,"date":"2019-09-24T04:24:41.000Z","subtitle":null,"header-img":null,"_content":"\n如果要用 js 实现一个类的话，我们会用构造函数来模拟一个类，代码如下：\n\n```javascript\nfunction Animal(name) {\n\tthis.name = name\n\tthis.height = function() {\n\t\tconsole.log(this.name + '的高度未知')\n\t}\n}\n\nAnimal.prototype.eat = function(food) {\n\tconsole.log(this.name + '正在吃' + food)\n}\n```\n\n那现在我们需要继承这个`Animal`的类来实现一个具体的`Dog`类，我们一般会使用`组合继承`，方法如下：\n\n```javascript\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n\tthis.age = age\n}\n\nDog.prototype = new Animal()\nDog.prototype.constructor = Dog\n```\n\n目测是比较完美的继承方式了，但是仔细思考会发现有个问题：\n\n1. 在`Dog.prototype = new Animal()`执行了一次`Animal`实例；\n2. 在 Dog 类实例化时候，内部使用 call 方法的时候又执行了一次`Animal`实例化；\n\n所以这并不是最完美的继承方式。那么我们应该使用什么样的办法才能解决上述问题呢？这个时候就需要用到`寄生继承`方式，代码如下：\n\n```javascript\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n\tthis.age = age\n}\n\nDog.prototype = Object.create(Animal.prototype)\nDog.prototype.constructor = Dog\n```\n\n利用一个中间对象先继承父类，减少了第一次继承父类原型的时候会实例化父类的缺点，这应该是目前最完美的继承方法。\n\n参考资料：\n\n1. [JS 组合继承（寄生继承）](https://www.jianshu.com/p/8a83ed26ecbb)\n2. [Javascript 完美继承方式 - 寄生组合](https://www.jianshu.com/p/5d53d06ea918)\n","source":"_posts/js继承问题总结.md","raw":"---\ntitle: js继承问题总结\ncatalog: true\ndate: 2019-09-24 12:24:41\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n如果要用 js 实现一个类的话，我们会用构造函数来模拟一个类，代码如下：\n\n```javascript\nfunction Animal(name) {\n\tthis.name = name\n\tthis.height = function() {\n\t\tconsole.log(this.name + '的高度未知')\n\t}\n}\n\nAnimal.prototype.eat = function(food) {\n\tconsole.log(this.name + '正在吃' + food)\n}\n```\n\n那现在我们需要继承这个`Animal`的类来实现一个具体的`Dog`类，我们一般会使用`组合继承`，方法如下：\n\n```javascript\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n\tthis.age = age\n}\n\nDog.prototype = new Animal()\nDog.prototype.constructor = Dog\n```\n\n目测是比较完美的继承方式了，但是仔细思考会发现有个问题：\n\n1. 在`Dog.prototype = new Animal()`执行了一次`Animal`实例；\n2. 在 Dog 类实例化时候，内部使用 call 方法的时候又执行了一次`Animal`实例化；\n\n所以这并不是最完美的继承方式。那么我们应该使用什么样的办法才能解决上述问题呢？这个时候就需要用到`寄生继承`方式，代码如下：\n\n```javascript\nfunction Dog(name, age) {\n\tAnimal.call(this, name)\n\tthis.age = age\n}\n\nDog.prototype = Object.create(Animal.prototype)\nDog.prototype.constructor = Dog\n```\n\n利用一个中间对象先继承父类，减少了第一次继承父类原型的时候会实例化父类的缺点，这应该是目前最完美的继承方法。\n\n参考资料：\n\n1. [JS 组合继承（寄生继承）](https://www.jianshu.com/p/8a83ed26ecbb)\n2. [Javascript 完美继承方式 - 寄生组合](https://www.jianshu.com/p/5d53d06ea918)\n","slug":"js继承问题总结","published":1,"updated":"2019-09-25T02:49:53.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982f000dgu1pagjtj6zq","content":"<p>如果要用 js 实现一个类的话，我们会用构造函数来模拟一个类，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.height = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'的高度未知'</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃'</span> + food)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那现在我们需要继承这个<code>Animal</code>的类来实现一个具体的<code>Dog</code>类，我们一般会使用<code>组合继承</code>，方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> Animal()</span><br><span class=\"line\">Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure>\n<p>目测是比较完美的继承方式了，但是仔细思考会发现有个问题：</p>\n<ol>\n<li>在<code>Dog.prototype = new Animal()</code>执行了一次<code>Animal</code>实例；</li>\n<li>在 Dog 类实例化时候，内部使用 call 方法的时候又执行了一次<code>Animal</code>实例化；</li>\n</ol>\n<p>所以这并不是最完美的继承方式。那么我们应该使用什么样的办法才能解决上述问题呢？这个时候就需要用到<code>寄生继承</code>方式，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype = <span class=\"built_in\">Object</span>.create(Animal.prototype)</span><br><span class=\"line\">Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure>\n<p>利用一个中间对象先继承父类，减少了第一次继承父类原型的时候会实例化父类的缺点，这应该是目前最完美的继承方法。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/8a83ed26ecbb\" target=\"_blank\" rel=\"noopener\">JS 组合继承（寄生继承）</a></li>\n<li><a href=\"https://www.jianshu.com/p/5d53d06ea918\" target=\"_blank\" rel=\"noopener\">Javascript 完美继承方式 - 寄生组合</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>如果要用 js 实现一个类的话，我们会用构造函数来模拟一个类，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.height = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'的高度未知'</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">food</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'正在吃'</span> + food)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那现在我们需要继承这个<code>Animal</code>的类来实现一个具体的<code>Dog</code>类，我们一般会使用<code>组合继承</code>，方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> Animal()</span><br><span class=\"line\">Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure>\n<p>目测是比较完美的继承方式了，但是仔细思考会发现有个问题：</p>\n<ol>\n<li>在<code>Dog.prototype = new Animal()</code>执行了一次<code>Animal</code>实例；</li>\n<li>在 Dog 类实例化时候，内部使用 call 方法的时候又执行了一次<code>Animal</code>实例化；</li>\n</ol>\n<p>所以这并不是最完美的继承方式。那么我们应该使用什么样的办法才能解决上述问题呢？这个时候就需要用到<code>寄生继承</code>方式，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.prototype = <span class=\"built_in\">Object</span>.create(Animal.prototype)</span><br><span class=\"line\">Dog.prototype.constructor = Dog</span><br></pre></td></tr></table></figure>\n<p>利用一个中间对象先继承父类，减少了第一次继承父类原型的时候会实例化父类的缺点，这应该是目前最完美的继承方法。</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/8a83ed26ecbb\" target=\"_blank\" rel=\"noopener\">JS 组合继承（寄生继承）</a></li>\n<li><a href=\"https://www.jianshu.com/p/5d53d06ea918\" target=\"_blank\" rel=\"noopener\">Javascript 完美继承方式 - 寄生组合</a></li>\n</ol>\n"},{"title":"pm2常用命令整理","catalog":true,"date":"2019-07-25T14:34:15.000Z","subtitle":null,"header-img":null,"_content":"\n- pm2 start\n\n之前一直使用过程中，都是指定一个启动文件（`pm2 start app.js`），后来在用`pm2`部署`nuxt.js`项目时候，发现这样的方式不太能用，查阅文档发现可以使用以 npm 方式执行 script 脚本命令\n\n```shell\n# pm2 start npm --name '进程名称' -- run 脚本命令\n# package.json\n#  script: {\n#    \"start:nuxt\": \"nuxt build\"\n#}\npm2 start npm -- run start:nuxt --name 'nuxt'\n```\n","source":"_posts/pm2常用命令整理.md","raw":"---\ntitle: pm2常用命令整理\ncatalog: true\ndate: 2019-07-25 22:34:15\nsubtitle:\nheader-img:\ntags: node\n---\n\n- pm2 start\n\n之前一直使用过程中，都是指定一个启动文件（`pm2 start app.js`），后来在用`pm2`部署`nuxt.js`项目时候，发现这样的方式不太能用，查阅文档发现可以使用以 npm 方式执行 script 脚本命令\n\n```shell\n# pm2 start npm --name '进程名称' -- run 脚本命令\n# package.json\n#  script: {\n#    \"start:nuxt\": \"nuxt build\"\n#}\npm2 start npm -- run start:nuxt --name 'nuxt'\n```\n","slug":"pm2常用命令整理","published":1,"updated":"2019-07-25T14:40:00.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982g000ggu1psga119ya","content":"<ul>\n<li>pm2 start</li>\n</ul>\n<p>之前一直使用过程中，都是指定一个启动文件（<code>pm2 start app.js</code>），后来在用<code>pm2</code>部署<code>nuxt.js</code>项目时候，发现这样的方式不太能用，查阅文档发现可以使用以 npm 方式执行 script 脚本命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> pm2 start npm --name '进程名称' -- run 脚本命令</span><br><span class=\"line\"><span class=\"meta\">#</span> package.json</span><br><span class=\"line\"><span class=\"meta\">#</span>  script: &#123;</span><br><span class=\"line\"><span class=\"meta\">#</span>    \"start:nuxt\": \"nuxt build\"</span><br><span class=\"line\"><span class=\"meta\">#</span>&#125;</span><br><span class=\"line\">pm2 start npm -- run start:nuxt --name 'nuxt'</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>pm2 start</li>\n</ul>\n<p>之前一直使用过程中，都是指定一个启动文件（<code>pm2 start app.js</code>），后来在用<code>pm2</code>部署<code>nuxt.js</code>项目时候，发现这样的方式不太能用，查阅文档发现可以使用以 npm 方式执行 script 脚本命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> pm2 start npm --name '进程名称' -- run 脚本命令</span><br><span class=\"line\"><span class=\"meta\">#</span> package.json</span><br><span class=\"line\"><span class=\"meta\">#</span>  script: &#123;</span><br><span class=\"line\"><span class=\"meta\">#</span>    \"start:nuxt\": \"nuxt build\"</span><br><span class=\"line\"><span class=\"meta\">#</span>&#125;</span><br><span class=\"line\">pm2 start npm -- run start:nuxt --name 'nuxt'</span><br></pre></td></tr></table></figure>\n"},{"title":"node性能优化","catalog":true,"date":"2019-12-23T15:14:51.000Z","subtitle":null,"header-img":null,"_content":"\n## 性能测试\n\n### 压力测试工具\n\n1. ab\n2. webBench\n\n简单介绍下 ab 测试工具使用\n\n```shell\n// -c200 模拟200个客户端并发请求 -n1600 一共请求1600次 -t15 压测15s\nab -c200 -n1600 http://127.0.0.1:3000/download\n```\n\n测试完有个测试报告，主要关心几个数值：\n\n1.  qps（request per second）: 并发数\n2.  Transfer rate （吞吐量）\n3.  Time per request（平均响应时间）\n\n### 找到性能瓶颈所在地\n\n1. top （检查 cpu、内存使用情况）\n2. iostat （检查 io 设备情况）\n3. 后端服务\n\n---\n\n## 性能分析\n\n1. 工具\n\n- Node.js 自带 profile\n\n```js\n// 启用profile模式，生成性能的log文件\nnode --prof 入口文件\n\n// 打开ab进行压测\nab -c200 -t15 http://127.0.0.1:3000/download\n\n// ab测试完之后 分析生成的profile\nnode --prof-process 刚才生成的log文件\n```\n\n- chrome devtool\n\n```js\n// inspect-brk 启动时暂停代码执行 debugger模式\nnode --inspect-brk 入口文件\n\n// 进行压测\n\n// 在chrome devtool的profiler下查看cpu使用情况 地址：chrome://inspect\n\n```\n\n- Clinic.js\n","source":"_posts/node性能优化.md","raw":"---\ntitle: node性能优化\ncatalog: true\ndate: 2019-12-23 23:14:51\nsubtitle:\nheader-img:\ntags: node\n---\n\n## 性能测试\n\n### 压力测试工具\n\n1. ab\n2. webBench\n\n简单介绍下 ab 测试工具使用\n\n```shell\n// -c200 模拟200个客户端并发请求 -n1600 一共请求1600次 -t15 压测15s\nab -c200 -n1600 http://127.0.0.1:3000/download\n```\n\n测试完有个测试报告，主要关心几个数值：\n\n1.  qps（request per second）: 并发数\n2.  Transfer rate （吞吐量）\n3.  Time per request（平均响应时间）\n\n### 找到性能瓶颈所在地\n\n1. top （检查 cpu、内存使用情况）\n2. iostat （检查 io 设备情况）\n3. 后端服务\n\n---\n\n## 性能分析\n\n1. 工具\n\n- Node.js 自带 profile\n\n```js\n// 启用profile模式，生成性能的log文件\nnode --prof 入口文件\n\n// 打开ab进行压测\nab -c200 -t15 http://127.0.0.1:3000/download\n\n// ab测试完之后 分析生成的profile\nnode --prof-process 刚才生成的log文件\n```\n\n- chrome devtool\n\n```js\n// inspect-brk 启动时暂停代码执行 debugger模式\nnode --inspect-brk 入口文件\n\n// 进行压测\n\n// 在chrome devtool的profiler下查看cpu使用情况 地址：chrome://inspect\n\n```\n\n- Clinic.js\n","slug":"node性能优化","published":1,"updated":"2019-12-23T15:45:33.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982h000hgu1puv0l5d3b","content":"<h2><span id=\"性能测试\">性能测试</span></h2>\n<h3><span id=\"压力测试工具\">压力测试工具</span></h3>\n<ol>\n<li>ab</li>\n<li>webBench</li>\n</ol>\n<p>简单介绍下 ab 测试工具使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -c200 模拟200个客户端并发请求 -n1600 一共请求1600次 -t15 压测15s</span><br><span class=\"line\">ab -c200 -n1600 http://127.0.0.1:3000/download</span><br></pre></td></tr></table></figure>\n<p>测试完有个测试报告，主要关心几个数值：</p>\n<ol>\n<li>qps（request per second）: 并发数</li>\n<li>Transfer rate （吞吐量）</li>\n<li>Time per request（平均响应时间）</li>\n</ol>\n<h3><span id=\"找到性能瓶颈所在地\">找到性能瓶颈所在地</span></h3>\n<ol>\n<li>top （检查 cpu、内存使用情况）</li>\n<li>iostat （检查 io 设备情况）</li>\n<li>后端服务</li>\n</ol>\n<hr>\n<h2><span id=\"性能分析\">性能分析</span></h2>\n<ol>\n<li>工具</li>\n</ol>\n<ul>\n<li>Node.js 自带 profile</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启用profile模式，生成性能的log文件</span></span><br><span class=\"line\">node --prof 入口文件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打开ab进行压测</span></span><br><span class=\"line\">ab -c200 -t15 http:<span class=\"comment\">//127.0.0.1:3000/download</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ab测试完之后 分析生成的profile</span></span><br><span class=\"line\">node --prof-process 刚才生成的log文件</span><br></pre></td></tr></table></figure>\n<ul>\n<li>chrome devtool</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inspect-brk 启动时暂停代码执行 debugger模式</span></span><br><span class=\"line\">node --inspect-brk 入口文件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行压测</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在chrome devtool的profiler下查看cpu使用情况 地址：chrome://inspect</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Clinic.js</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>性能测试</h2>\n<h3>压力测试工具</h3>\n<ol>\n<li>ab</li>\n<li>webBench</li>\n</ol>\n<p>简单介绍下 ab 测试工具使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -c200 模拟200个客户端并发请求 -n1600 一共请求1600次 -t15 压测15s</span><br><span class=\"line\">ab -c200 -n1600 http://127.0.0.1:3000/download</span><br></pre></td></tr></table></figure>\n<p>测试完有个测试报告，主要关心几个数值：</p>\n<ol>\n<li>qps（request per second）: 并发数</li>\n<li>Transfer rate （吞吐量）</li>\n<li>Time per request（平均响应时间）</li>\n</ol>\n<h3>找到性能瓶颈所在地</h3>\n<ol>\n<li>top （检查 cpu、内存使用情况）</li>\n<li>iostat （检查 io 设备情况）</li>\n<li>后端服务</li>\n</ol>\n<hr>\n<h2>性能分析</h2>\n<ol>\n<li>工具</li>\n</ol>\n<ul>\n<li>Node.js 自带 profile</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启用profile模式，生成性能的log文件</span></span><br><span class=\"line\">node --prof 入口文件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打开ab进行压测</span></span><br><span class=\"line\">ab -c200 -t15 http:<span class=\"comment\">//127.0.0.1:3000/download</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ab测试完之后 分析生成的profile</span></span><br><span class=\"line\">node --prof-process 刚才生成的log文件</span><br></pre></td></tr></table></figure>\n<ul>\n<li>chrome devtool</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inspect-brk 启动时暂停代码执行 debugger模式</span></span><br><span class=\"line\">node --inspect-brk 入口文件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进行压测</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在chrome devtool的profiler下查看cpu使用情况 地址：chrome://inspect</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Clinic.js</li>\n</ul>\n"},{"title":"linux常用指令记录","catalog":true,"date":"2019-03-25T12:41:36.000Z","subtitle":null,"header-img":null,"_content":"\n1. 软连接\n\nln -s 软件源目录 /usr/local/bin/\n\n比如安装完 node 将`/app/software/nodejs/bin/node`的命令提示符直接通过`node`去访问\n\n```shell\n# ln -s 源文件bin目录 系统bin目录\nln -s /app/software/nodejs/bin/node /usr/local/bin/node\n```\n\n删除软连接\n\n```shell\nrm -rf /usr/local/bin/node\n```\n\n2. 创建文件\n\n```shell\ntouch XXX\n```\n\n3.  查看进程\n\n```shell\nnetstat -ntpl\n```\n\n4. 设置环境变量\n\n`vi /etc/profile`在文件的最下方倒数第三行里面编写变量名，例如：`export NGINX=/usr/local/webserver/nginx/conf` 保存之后不会立即生效，需要输入`source /etc/profile`，之后`echo $NGINX`查看是否生效\n\n5. `rsync`跨服务器传输文件\n\n```shell\n  rsync  -rzte 'ssh -p 22' 源目录 目的地目录\n```\n\n要是服务器 A 要传文件到服务器 B，可能会存在没有权限的问题，这个时候就要 A 生成公钥`ssh-keygen`，将 A 的公钥`id_rsa.pub`内容复制到 B 服务器`.ssh/authorized_keys`内容下方，就可以解决权限问题了。\n\n6. 设置新建立的`shell`等脚本拥有可执行权限\n\n```shell\nchmod +x 路径\n```\n\n7. 将指定用户/用户组加入到其他组\n\n```shell\n gpasswd -a www root   // www将入到root组\n```\n\n8. 给指定目录以指定用户/用户组的所有权限\n\n```shell\nchown -R www:www /data/www-data/test\n```\n\n9. source\n\n用户登录系统会自动创建一个父`shell`，如果在这个父`shell`里面执行一个`shell`则为子`shell`，两者创建的变量是不会共享的，如果需要登陆的`shell`可以访问内部的`shell`变量，需要用`source`命令，在当前父`shell`窗口立刻执行子`shell`，能访问子`shell`变量，也不用注销用户登录。\n`export`是父`shell`暴露变量给子`shell`使用\n\n[source 详解](https://www.cnblogs.com/ThatsMyTiger/p/6865817.html)\n\n10. curl\n\n- -O 将指定地址的文件下载到本地\n\n```shell\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.6.tgz\n```\n\n11. tar 解压/压缩\n\n-c: 压缩\n-x：解压\n-t：查看内容\n-r：向压缩归档文件末尾追加文件\n-u：更新原压缩包中的文件\n-f：（必选且必须在最后一个参数）使用源文件名字\n-z：有 gzip 属性的\n-j：有 bz2 属性的\n-Z：有 compress 属性的\n-v：显示所有过程\n-O：将文件解开到标准输出\n\n```shell\ntar -zxvf 源文件\n```\n\n12. grep\n\n查找字符串中指定的字符\n\n```shell\ngrep [-acinv] [--color=auto] '搜寻字符串' filename\n```\n\n选项与参数：\n-a ：将 binary 文件以 text 文件的方式搜寻数据\n-c ：计算找到 '搜寻字符串' 的次数\n-i ：忽略大小写的不同，所以大小写视为相同\n-n ：顺便输出行号\n-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！\n--color=auto ：可以将找到的关键词部分加上颜色的显示喔！\n\n14. rm\n\n-r 向下遍历目录文件依次删除\n-f 强制删除\n\n全部删除但排除某个文件\n\n比如：排除.git 之外的所有文件\n\n```shell\nrm -rf `ls |grep -v .git`\n```\n\n15. cp\n\ncp -r 源目录地址 目标目录地址\n\n16. 新打开一个 shell 自动执行一些配置项 在/root/.bashrc 下编辑默认环境变量 全部 shell 共享需要修改/etc/profile\n\n17. ansible\n\n远程服务器 切换目录`chdir`\n\n```shell\nansible -i /opt/script/xxx.hosts duapp-node-common-service -u root -m shell -a 'chdir=/data/www-data/hupu.com/node-common sh start.sh'\n```\n\n18. 全局查找某个文件\n\n```shell\nfind / -name 文件名\n```\n\n常见错误处理参考链接：\n\n- [nginx 在 reload 时候报错 invalid PID number](https://www.cnblogs.com/tielemao/p/6163419.html)\n- [nginx: [emerg] invalid socket number ](https://blog.csdn.net/bikeorcl/article/details/78850265)\n","source":"_posts/linux常用指令记录.md","raw":"---\ntitle: linux常用指令记录\ncatalog: true\ndate: 2019-03-25 20:41:36\nsubtitle:\nheader-img:\ntags: linux\n---\n\n1. 软连接\n\nln -s 软件源目录 /usr/local/bin/\n\n比如安装完 node 将`/app/software/nodejs/bin/node`的命令提示符直接通过`node`去访问\n\n```shell\n# ln -s 源文件bin目录 系统bin目录\nln -s /app/software/nodejs/bin/node /usr/local/bin/node\n```\n\n删除软连接\n\n```shell\nrm -rf /usr/local/bin/node\n```\n\n2. 创建文件\n\n```shell\ntouch XXX\n```\n\n3.  查看进程\n\n```shell\nnetstat -ntpl\n```\n\n4. 设置环境变量\n\n`vi /etc/profile`在文件的最下方倒数第三行里面编写变量名，例如：`export NGINX=/usr/local/webserver/nginx/conf` 保存之后不会立即生效，需要输入`source /etc/profile`，之后`echo $NGINX`查看是否生效\n\n5. `rsync`跨服务器传输文件\n\n```shell\n  rsync  -rzte 'ssh -p 22' 源目录 目的地目录\n```\n\n要是服务器 A 要传文件到服务器 B，可能会存在没有权限的问题，这个时候就要 A 生成公钥`ssh-keygen`，将 A 的公钥`id_rsa.pub`内容复制到 B 服务器`.ssh/authorized_keys`内容下方，就可以解决权限问题了。\n\n6. 设置新建立的`shell`等脚本拥有可执行权限\n\n```shell\nchmod +x 路径\n```\n\n7. 将指定用户/用户组加入到其他组\n\n```shell\n gpasswd -a www root   // www将入到root组\n```\n\n8. 给指定目录以指定用户/用户组的所有权限\n\n```shell\nchown -R www:www /data/www-data/test\n```\n\n9. source\n\n用户登录系统会自动创建一个父`shell`，如果在这个父`shell`里面执行一个`shell`则为子`shell`，两者创建的变量是不会共享的，如果需要登陆的`shell`可以访问内部的`shell`变量，需要用`source`命令，在当前父`shell`窗口立刻执行子`shell`，能访问子`shell`变量，也不用注销用户登录。\n`export`是父`shell`暴露变量给子`shell`使用\n\n[source 详解](https://www.cnblogs.com/ThatsMyTiger/p/6865817.html)\n\n10. curl\n\n- -O 将指定地址的文件下载到本地\n\n```shell\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.6.tgz\n```\n\n11. tar 解压/压缩\n\n-c: 压缩\n-x：解压\n-t：查看内容\n-r：向压缩归档文件末尾追加文件\n-u：更新原压缩包中的文件\n-f：（必选且必须在最后一个参数）使用源文件名字\n-z：有 gzip 属性的\n-j：有 bz2 属性的\n-Z：有 compress 属性的\n-v：显示所有过程\n-O：将文件解开到标准输出\n\n```shell\ntar -zxvf 源文件\n```\n\n12. grep\n\n查找字符串中指定的字符\n\n```shell\ngrep [-acinv] [--color=auto] '搜寻字符串' filename\n```\n\n选项与参数：\n-a ：将 binary 文件以 text 文件的方式搜寻数据\n-c ：计算找到 '搜寻字符串' 的次数\n-i ：忽略大小写的不同，所以大小写视为相同\n-n ：顺便输出行号\n-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！\n--color=auto ：可以将找到的关键词部分加上颜色的显示喔！\n\n14. rm\n\n-r 向下遍历目录文件依次删除\n-f 强制删除\n\n全部删除但排除某个文件\n\n比如：排除.git 之外的所有文件\n\n```shell\nrm -rf `ls |grep -v .git`\n```\n\n15. cp\n\ncp -r 源目录地址 目标目录地址\n\n16. 新打开一个 shell 自动执行一些配置项 在/root/.bashrc 下编辑默认环境变量 全部 shell 共享需要修改/etc/profile\n\n17. ansible\n\n远程服务器 切换目录`chdir`\n\n```shell\nansible -i /opt/script/xxx.hosts duapp-node-common-service -u root -m shell -a 'chdir=/data/www-data/hupu.com/node-common sh start.sh'\n```\n\n18. 全局查找某个文件\n\n```shell\nfind / -name 文件名\n```\n\n常见错误处理参考链接：\n\n- [nginx 在 reload 时候报错 invalid PID number](https://www.cnblogs.com/tielemao/p/6163419.html)\n- [nginx: [emerg] invalid socket number ](https://blog.csdn.net/bikeorcl/article/details/78850265)\n","slug":"linux常用指令记录","published":1,"updated":"2019-07-26T04:10:39.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982i000jgu1p0fvyr643","content":"<ol>\n<li>软连接</li>\n</ol>\n<p>ln -s 软件源目录 /usr/local/bin/</p>\n<p>比如安装完 node 将<code>/app/software/nodejs/bin/node</code>的命令提示符直接通过<code>node</code>去访问</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> ln -s 源文件bin目录 系统bin目录</span><br><span class=\"line\">ln -s /app/software/nodejs/bin/node /usr/local/bin/node</span><br></pre></td></tr></table></figure>\n<p>删除软连接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf /usr/local/bin/node</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>创建文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch XXX</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>查看进程</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntpl</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>设置环境变量</li>\n</ol>\n<p><code>vi /etc/profile</code>在文件的最下方倒数第三行里面编写变量名，例如：<code>export NGINX=/usr/local/webserver/nginx/conf</code> 保存之后不会立即生效，需要输入<code>source /etc/profile</code>，之后<code>echo $NGINX</code>查看是否生效</p>\n<ol start=\"5\">\n<li><code>rsync</code>跨服务器传输文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync  -rzte 'ssh -p 22' 源目录 目的地目录</span><br></pre></td></tr></table></figure>\n<p>要是服务器 A 要传文件到服务器 B，可能会存在没有权限的问题，这个时候就要 A 生成公钥<code>ssh-keygen</code>，将 A 的公钥<code>id_rsa.pub</code>内容复制到 B 服务器<code>.ssh/authorized_keys</code>内容下方，就可以解决权限问题了。</p>\n<ol start=\"6\">\n<li>设置新建立的<code>shell</code>等脚本拥有可执行权限</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x 路径</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>将指定用户/用户组加入到其他组</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpasswd -a www root   // www将入到root组</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>给指定目录以指定用户/用户组的所有权限</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -R www:www /data/www-data/test</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>source</li>\n</ol>\n<p>用户登录系统会自动创建一个父<code>shell</code>，如果在这个父<code>shell</code>里面执行一个<code>shell</code>则为子<code>shell</code>，两者创建的变量是不会共享的，如果需要登陆的<code>shell</code>可以访问内部的<code>shell</code>变量，需要用<code>source</code>命令，在当前父<code>shell</code>窗口立刻执行子<code>shell</code>，能访问子<code>shell</code>变量，也不用注销用户登录。<br>\n<code>export</code>是父<code>shell</code>暴露变量给子<code>shell</code>使用</p>\n<p><a href=\"https://www.cnblogs.com/ThatsMyTiger/p/6865817.html\" target=\"_blank\" rel=\"noopener\">source 详解</a></p>\n<ol start=\"10\">\n<li>curl</li>\n</ol>\n<ul>\n<li>-O 将指定地址的文件下载到本地</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.6.tgz</span><br></pre></td></tr></table></figure>\n<ol start=\"11\">\n<li>tar 解压/压缩</li>\n</ol>\n<p>-c: 压缩<br>\n-x：解压<br>\n-t：查看内容<br>\n-r：向压缩归档文件末尾追加文件<br>\n-u：更新原压缩包中的文件<br>\n-f：（必选且必须在最后一个参数）使用源文件名字<br>\n-z：有 gzip 属性的<br>\n-j：有 bz2 属性的<br>\n-Z：有 compress 属性的<br>\n-v：显示所有过程<br>\n-O：将文件解开到标准输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf 源文件</span><br></pre></td></tr></table></figure>\n<ol start=\"12\">\n<li>grep</li>\n</ol>\n<p>查找字符串中指定的字符</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [-acinv] [--color=auto] '搜寻字符串' filename</span><br></pre></td></tr></table></figure>\n<p>选项与参数：<br>\n-a ：将 binary 文件以 text 文件的方式搜寻数据<br>\n-c ：计算找到 ‘搜寻字符串’ 的次数<br>\n-i ：忽略大小写的不同，所以大小写视为相同<br>\n-n ：顺便输出行号<br>\n-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！<br>\n–color=auto ：可以将找到的关键词部分加上颜色的显示喔！</p>\n<ol start=\"14\">\n<li>rm</li>\n</ol>\n<p>-r 向下遍历目录文件依次删除<br>\n-f 强制删除</p>\n<p>全部删除但排除某个文件</p>\n<p>比如：排除.git 之外的所有文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf `ls |grep -v .git`</span><br></pre></td></tr></table></figure>\n<ol start=\"15\">\n<li>cp</li>\n</ol>\n<p>cp -r 源目录地址 目标目录地址</p>\n<ol start=\"16\">\n<li>\n<p>新打开一个 shell 自动执行一些配置项 在/root/.bashrc 下编辑默认环境变量 全部 shell 共享需要修改/etc/profile</p>\n</li>\n<li>\n<p>ansible</p>\n</li>\n</ol>\n<p>远程服务器 切换目录<code>chdir</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible -i /opt/script/xxx.hosts duapp-node-common-service -u root -m shell -a 'chdir=/data/www-data/hupu.com/node-common sh start.sh'</span><br></pre></td></tr></table></figure>\n<ol start=\"18\">\n<li>全局查找某个文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name 文件名</span><br></pre></td></tr></table></figure>\n<p>常见错误处理参考链接：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/tielemao/p/6163419.html\" target=\"_blank\" rel=\"noopener\">nginx 在 reload 时候报错 invalid PID number</a></li>\n<li><a href=\"https://blog.csdn.net/bikeorcl/article/details/78850265\" target=\"_blank\" rel=\"noopener\">nginx: [emerg] invalid socket number </a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>软连接</li>\n</ol>\n<p>ln -s 软件源目录 /usr/local/bin/</p>\n<p>比如安装完 node 将<code>/app/software/nodejs/bin/node</code>的命令提示符直接通过<code>node</code>去访问</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> ln -s 源文件bin目录 系统bin目录</span><br><span class=\"line\">ln -s /app/software/nodejs/bin/node /usr/local/bin/node</span><br></pre></td></tr></table></figure>\n<p>删除软连接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf /usr/local/bin/node</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>创建文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch XXX</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>查看进程</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntpl</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>设置环境变量</li>\n</ol>\n<p><code>vi /etc/profile</code>在文件的最下方倒数第三行里面编写变量名，例如：<code>export NGINX=/usr/local/webserver/nginx/conf</code> 保存之后不会立即生效，需要输入<code>source /etc/profile</code>，之后<code>echo $NGINX</code>查看是否生效</p>\n<ol start=\"5\">\n<li><code>rsync</code>跨服务器传输文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rsync  -rzte 'ssh -p 22' 源目录 目的地目录</span><br></pre></td></tr></table></figure>\n<p>要是服务器 A 要传文件到服务器 B，可能会存在没有权限的问题，这个时候就要 A 生成公钥<code>ssh-keygen</code>，将 A 的公钥<code>id_rsa.pub</code>内容复制到 B 服务器<code>.ssh/authorized_keys</code>内容下方，就可以解决权限问题了。</p>\n<ol start=\"6\">\n<li>设置新建立的<code>shell</code>等脚本拥有可执行权限</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x 路径</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>将指定用户/用户组加入到其他组</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpasswd -a www root   // www将入到root组</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>给指定目录以指定用户/用户组的所有权限</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -R www:www /data/www-data/test</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>source</li>\n</ol>\n<p>用户登录系统会自动创建一个父<code>shell</code>，如果在这个父<code>shell</code>里面执行一个<code>shell</code>则为子<code>shell</code>，两者创建的变量是不会共享的，如果需要登陆的<code>shell</code>可以访问内部的<code>shell</code>变量，需要用<code>source</code>命令，在当前父<code>shell</code>窗口立刻执行子<code>shell</code>，能访问子<code>shell</code>变量，也不用注销用户登录。<br>\n<code>export</code>是父<code>shell</code>暴露变量给子<code>shell</code>使用</p>\n<p><a href=\"https://www.cnblogs.com/ThatsMyTiger/p/6865817.html\" target=\"_blank\" rel=\"noopener\">source 详解</a></p>\n<ol start=\"10\">\n<li>curl</li>\n</ol>\n<ul>\n<li>-O 将指定地址的文件下载到本地</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.6.tgz</span><br></pre></td></tr></table></figure>\n<ol start=\"11\">\n<li>tar 解压/压缩</li>\n</ol>\n<p>-c: 压缩<br>\n-x：解压<br>\n-t：查看内容<br>\n-r：向压缩归档文件末尾追加文件<br>\n-u：更新原压缩包中的文件<br>\n-f：（必选且必须在最后一个参数）使用源文件名字<br>\n-z：有 gzip 属性的<br>\n-j：有 bz2 属性的<br>\n-Z：有 compress 属性的<br>\n-v：显示所有过程<br>\n-O：将文件解开到标准输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf 源文件</span><br></pre></td></tr></table></figure>\n<ol start=\"12\">\n<li>grep</li>\n</ol>\n<p>查找字符串中指定的字符</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [-acinv] [--color=auto] '搜寻字符串' filename</span><br></pre></td></tr></table></figure>\n<p>选项与参数：<br>\n-a ：将 binary 文件以 text 文件的方式搜寻数据<br>\n-c ：计算找到 ‘搜寻字符串’ 的次数<br>\n-i ：忽略大小写的不同，所以大小写视为相同<br>\n-n ：顺便输出行号<br>\n-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！<br>\n–color=auto ：可以将找到的关键词部分加上颜色的显示喔！</p>\n<ol start=\"14\">\n<li>rm</li>\n</ol>\n<p>-r 向下遍历目录文件依次删除<br>\n-f 强制删除</p>\n<p>全部删除但排除某个文件</p>\n<p>比如：排除.git 之外的所有文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf `ls |grep -v .git`</span><br></pre></td></tr></table></figure>\n<ol start=\"15\">\n<li>cp</li>\n</ol>\n<p>cp -r 源目录地址 目标目录地址</p>\n<ol start=\"16\">\n<li>\n<p>新打开一个 shell 自动执行一些配置项 在/root/.bashrc 下编辑默认环境变量 全部 shell 共享需要修改/etc/profile</p>\n</li>\n<li>\n<p>ansible</p>\n</li>\n</ol>\n<p>远程服务器 切换目录<code>chdir</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ansible -i /opt/script/xxx.hosts duapp-node-common-service -u root -m shell -a 'chdir=/data/www-data/hupu.com/node-common sh start.sh'</span><br></pre></td></tr></table></figure>\n<ol start=\"18\">\n<li>全局查找某个文件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find / -name 文件名</span><br></pre></td></tr></table></figure>\n<p>常见错误处理参考链接：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/tielemao/p/6163419.html\" target=\"_blank\" rel=\"noopener\">nginx 在 reload 时候报错 invalid PID number</a></li>\n<li><a href=\"https://blog.csdn.net/bikeorcl/article/details/78850265\" target=\"_blank\" rel=\"noopener\">nginx: [emerg] invalid socket number </a></li>\n</ul>\n"},{"title":"react-hooks入门","catalog":true,"date":"2020-01-08T08:50:48.000Z","subtitle":null,"header-img":null,"_content":"\nreact hooks 发布于 React16.8.0 版本，这样的一个新的特性的作用是什么呢？\n\n众所周知，react 默认使用组件类的语法，当我们在编写和维护这些组件类的时候，往往会遇到如下一些问题：\n\n1. 组件之间复用状态逻辑比较困难\n\nReact 本身没有提供将可复用性行为添加到组件的方式，当然针对这些问题有一些方案，比如 render props 和高阶组件；但是在使用这些方案时，往往会需要重新组织当前组件的结构，这会比较麻烦。另外由 providers、consumers、高阶组件组成的抽象组件会形成`嵌套地狱`。基于这样的问题需要 React 本身为共享状态逻辑提供更高的原生途径。\n\nhooks 可以在无需更改组件结构的情况下，提取状态逻辑，单独测试并复用。\n\n2. 复杂组件很难拆分、重构、测试\n\n我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。比如生命周期常常包含不相关逻辑，如果状态逻辑之间有关联更容易产生问题，多数情况下，因为状态逻辑无处不在，导致不能将组件拆分为更小粒度。\n\nhooks 可以将组件相关的部分拆分成更小的函数，而非强制按照生命周期划分。\n\n## Hook 含义\n\nHook 就是加强版本的函数组件，如果需要外部功能（react 其他功能）和副作用，就用钩子把外部代码\"钩\"进来。\n\n参考文档：\n\n1. [React Hooks 入门教程](http://www.ruanyifeng.com/blog/2019/09/react-hooks.html)\n2. [React 官方文档 Hook 简介](https://react.docschina.org/docs/hooks-intro.html)\n","source":"_posts/react-hooks入门.md","raw":"---\ntitle: react-hooks入门\ncatalog: true\ndate: 2020-01-08 16:50:48\nsubtitle:\nheader-img:\ntags: react\n---\n\nreact hooks 发布于 React16.8.0 版本，这样的一个新的特性的作用是什么呢？\n\n众所周知，react 默认使用组件类的语法，当我们在编写和维护这些组件类的时候，往往会遇到如下一些问题：\n\n1. 组件之间复用状态逻辑比较困难\n\nReact 本身没有提供将可复用性行为添加到组件的方式，当然针对这些问题有一些方案，比如 render props 和高阶组件；但是在使用这些方案时，往往会需要重新组织当前组件的结构，这会比较麻烦。另外由 providers、consumers、高阶组件组成的抽象组件会形成`嵌套地狱`。基于这样的问题需要 React 本身为共享状态逻辑提供更高的原生途径。\n\nhooks 可以在无需更改组件结构的情况下，提取状态逻辑，单独测试并复用。\n\n2. 复杂组件很难拆分、重构、测试\n\n我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。比如生命周期常常包含不相关逻辑，如果状态逻辑之间有关联更容易产生问题，多数情况下，因为状态逻辑无处不在，导致不能将组件拆分为更小粒度。\n\nhooks 可以将组件相关的部分拆分成更小的函数，而非强制按照生命周期划分。\n\n## Hook 含义\n\nHook 就是加强版本的函数组件，如果需要外部功能（react 其他功能）和副作用，就用钩子把外部代码\"钩\"进来。\n\n参考文档：\n\n1. [React Hooks 入门教程](http://www.ruanyifeng.com/blog/2019/09/react-hooks.html)\n2. [React 官方文档 Hook 简介](https://react.docschina.org/docs/hooks-intro.html)\n","slug":"react-hooks入门","published":1,"updated":"2020-01-08T10:39:19.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982j000lgu1p27wy9otl","content":"<p>react hooks 发布于 React16.8.0 版本，这样的一个新的特性的作用是什么呢？</p>\n<p>众所周知，react 默认使用组件类的语法，当我们在编写和维护这些组件类的时候，往往会遇到如下一些问题：</p>\n<ol>\n<li>组件之间复用状态逻辑比较困难</li>\n</ol>\n<p>React 本身没有提供将可复用性行为添加到组件的方式，当然针对这些问题有一些方案，比如 render props 和高阶组件；但是在使用这些方案时，往往会需要重新组织当前组件的结构，这会比较麻烦。另外由 providers、consumers、高阶组件组成的抽象组件会形成<code>嵌套地狱</code>。基于这样的问题需要 React 本身为共享状态逻辑提供更高的原生途径。</p>\n<p>hooks 可以在无需更改组件结构的情况下，提取状态逻辑，单独测试并复用。</p>\n<ol start=\"2\">\n<li>复杂组件很难拆分、重构、测试</li>\n</ol>\n<p>我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。比如生命周期常常包含不相关逻辑，如果状态逻辑之间有关联更容易产生问题，多数情况下，因为状态逻辑无处不在，导致不能将组件拆分为更小粒度。</p>\n<p>hooks 可以将组件相关的部分拆分成更小的函数，而非强制按照生命周期划分。</p>\n<h2><span id=\"hook-含义\">Hook 含义</span></h2>\n<p>Hook 就是加强版本的函数组件，如果需要外部功能（react 其他功能）和副作用，就用钩子把外部代码&quot;钩&quot;进来。</p>\n<p>参考文档：</p>\n<ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2019/09/react-hooks.html\" target=\"_blank\" rel=\"noopener\">React Hooks 入门教程</a></li>\n<li><a href=\"https://react.docschina.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"noopener\">React 官方文档 Hook 简介</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>react hooks 发布于 React16.8.0 版本，这样的一个新的特性的作用是什么呢？</p>\n<p>众所周知，react 默认使用组件类的语法，当我们在编写和维护这些组件类的时候，往往会遇到如下一些问题：</p>\n<ol>\n<li>组件之间复用状态逻辑比较困难</li>\n</ol>\n<p>React 本身没有提供将可复用性行为添加到组件的方式，当然针对这些问题有一些方案，比如 render props 和高阶组件；但是在使用这些方案时，往往会需要重新组织当前组件的结构，这会比较麻烦。另外由 providers、consumers、高阶组件组成的抽象组件会形成<code>嵌套地狱</code>。基于这样的问题需要 React 本身为共享状态逻辑提供更高的原生途径。</p>\n<p>hooks 可以在无需更改组件结构的情况下，提取状态逻辑，单独测试并复用。</p>\n<ol start=\"2\">\n<li>复杂组件很难拆分、重构、测试</li>\n</ol>\n<p>我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。比如生命周期常常包含不相关逻辑，如果状态逻辑之间有关联更容易产生问题，多数情况下，因为状态逻辑无处不在，导致不能将组件拆分为更小粒度。</p>\n<p>hooks 可以将组件相关的部分拆分成更小的函数，而非强制按照生命周期划分。</p>\n<h2>Hook 含义</h2>\n<p>Hook 就是加强版本的函数组件，如果需要外部功能（react 其他功能）和副作用，就用钩子把外部代码&quot;钩&quot;进来。</p>\n<p>参考文档：</p>\n<ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2019/09/react-hooks.html\" target=\"_blank\" rel=\"noopener\">React Hooks 入门教程</a></li>\n<li><a href=\"https://react.docschina.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"noopener\">React 官方文档 Hook 简介</a></li>\n</ol>\n"},{"title":"python爬虫框架scrapy","catalog":true,"date":"2019-06-19T06:07:34.000Z","subtitle":null,"header-img":null,"_content":"\n### 基本用法\n\n1.创建项目\n\n```shell\nscrapy startproject 项目名称\n```\n\n2.创建一个爬虫\n\n```shell\nscrapy genspider XX XX.com\n```\n\n3.启动脚本\n\n```shell\nscrapy crawl XX\n```\n\n也可以新建一个启动文件，比如`start.py`\n\n```python\nfrom scrapy.cmdline import execute\n\nexecute('scrapy crawl stockX'.split())\n```\n\n4.爬虫脚本\n\n必须要有`name`，这个是和启动对应命令对应的的名称\n\n`parse`以及`start_urls`和`allowed_domains`可选\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\n\nclass BaiduSpider(scrapy.Spider):\n    name = 'baidu'\n    allowed_domains = ['baidu.com']\n    start_urls = ['https://www.baidu.com/']\n\n    def parse(self, response):\n        print(response.text)\n```\n\n其中 start_urls 可以接受多个 url 参数，也可以拆分成多个步骤\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\n\nclass BaiduSpider(scrapy.Spider):\n    name = 'baidu'\n    allowed_domains = ['baidu.com']\n    # start_urls = ['https://www.baidu.com/']\n\n    def start_requests(self):\n        yield scrapy.Request('https://www.baidu.com')\n\n    def parse(self, response):\n        print(response.text)\n```\n\n---\n\n1. `Items`相当于定义的需要输出的数据模型，用来存储数据，推送给`pipline`解析处理；\n\n2. 如果要爬取多组数据，最好是建立多个模型，即`Item`；\n\n---\n\n## Pipline\n\n### 1. 介绍\n\n当 item 在 Spider 中被收集之后，会传递到 item pipline 中处理；\n\n作用：\n\n- 清理 html 数据\n- 验证爬取数据\n- 去重并丢弃\n- 数据持久化\n\n### 2. 编写 item pipline\n\n2.1 必须实现的函数\n\n- process_item\n\n  每个`pipline`都是一个 python 类，负责接收到`item`并执行一些行为，内部必须实现`process_item(self, item, spider)`方法，必须返回一个`dict`或者`item`对象。\n\n  `piplines`只能接受字典和`items`，在主程序通过`yield`推送到`piplines`\n\n  2.2 可以选择实现\n\n- `open_spider(self, spider)`表示当 spider 开启的时候调用的方法；\n- `close_spider(self, spider)`标识当 spider 关闭的时候调用的方法；\n\n注意：\n\n- `pipline`写完需要在配置项`settings`的`ITEM_PIPELINES`里写入来启动\n\n```python\nITEM_PIPELINE {\n  demo.pipelines.testDemoPipeline : 300    // 300是优先级 越大优先级越高\n}\n```\n\n- 文件流写入是缓冲一定字节的数据再一次性写入\n\n  强制立刻写入\n\n```python\nself.file.flush()\n```\n\n---\n\n2.3 如果编写多个`pipeline`，则会改成指定大小去依次执行每次推过来的`item`，如果需要丢弃`item`\n\n```python\n from scrapy.exceptions import DropItem\n\n raise DropItem()\n```\n\n2.4 推送过来的`item`并不是一个 list，如果需要存储数据，则需要转成字典\n\n```python\n self.json_file.writelines(json.dumps(dict(item), ensure_ascii=False) + '\\r')\n```\n","source":"_posts/python爬虫框架scrapy.md","raw":"---\ntitle: python爬虫框架scrapy\ncatalog: true\ndate: 2019-06-19 14:07:34\nsubtitle:\nheader-img:\ntags: python\n---\n\n### 基本用法\n\n1.创建项目\n\n```shell\nscrapy startproject 项目名称\n```\n\n2.创建一个爬虫\n\n```shell\nscrapy genspider XX XX.com\n```\n\n3.启动脚本\n\n```shell\nscrapy crawl XX\n```\n\n也可以新建一个启动文件，比如`start.py`\n\n```python\nfrom scrapy.cmdline import execute\n\nexecute('scrapy crawl stockX'.split())\n```\n\n4.爬虫脚本\n\n必须要有`name`，这个是和启动对应命令对应的的名称\n\n`parse`以及`start_urls`和`allowed_domains`可选\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\n\nclass BaiduSpider(scrapy.Spider):\n    name = 'baidu'\n    allowed_domains = ['baidu.com']\n    start_urls = ['https://www.baidu.com/']\n\n    def parse(self, response):\n        print(response.text)\n```\n\n其中 start_urls 可以接受多个 url 参数，也可以拆分成多个步骤\n\n```python\n# -*- coding: utf-8 -*-\nimport scrapy\n\nclass BaiduSpider(scrapy.Spider):\n    name = 'baidu'\n    allowed_domains = ['baidu.com']\n    # start_urls = ['https://www.baidu.com/']\n\n    def start_requests(self):\n        yield scrapy.Request('https://www.baidu.com')\n\n    def parse(self, response):\n        print(response.text)\n```\n\n---\n\n1. `Items`相当于定义的需要输出的数据模型，用来存储数据，推送给`pipline`解析处理；\n\n2. 如果要爬取多组数据，最好是建立多个模型，即`Item`；\n\n---\n\n## Pipline\n\n### 1. 介绍\n\n当 item 在 Spider 中被收集之后，会传递到 item pipline 中处理；\n\n作用：\n\n- 清理 html 数据\n- 验证爬取数据\n- 去重并丢弃\n- 数据持久化\n\n### 2. 编写 item pipline\n\n2.1 必须实现的函数\n\n- process_item\n\n  每个`pipline`都是一个 python 类，负责接收到`item`并执行一些行为，内部必须实现`process_item(self, item, spider)`方法，必须返回一个`dict`或者`item`对象。\n\n  `piplines`只能接受字典和`items`，在主程序通过`yield`推送到`piplines`\n\n  2.2 可以选择实现\n\n- `open_spider(self, spider)`表示当 spider 开启的时候调用的方法；\n- `close_spider(self, spider)`标识当 spider 关闭的时候调用的方法；\n\n注意：\n\n- `pipline`写完需要在配置项`settings`的`ITEM_PIPELINES`里写入来启动\n\n```python\nITEM_PIPELINE {\n  demo.pipelines.testDemoPipeline : 300    // 300是优先级 越大优先级越高\n}\n```\n\n- 文件流写入是缓冲一定字节的数据再一次性写入\n\n  强制立刻写入\n\n```python\nself.file.flush()\n```\n\n---\n\n2.3 如果编写多个`pipeline`，则会改成指定大小去依次执行每次推过来的`item`，如果需要丢弃`item`\n\n```python\n from scrapy.exceptions import DropItem\n\n raise DropItem()\n```\n\n2.4 推送过来的`item`并不是一个 list，如果需要存储数据，则需要转成字典\n\n```python\n self.json_file.writelines(json.dumps(dict(item), ensure_ascii=False) + '\\r')\n```\n","slug":"python爬虫框架scrapy","published":1,"updated":"2019-09-19T07:44:48.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982k000ogu1pybk4e0zu","content":"<h3><span id=\"基本用法\">基本用法</span></h3>\n<p>1.创建项目</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject 项目名称</span><br></pre></td></tr></table></figure>\n<p>2.创建一个爬虫</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy genspider XX XX.com</span><br></pre></td></tr></table></figure>\n<p>3.启动脚本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl XX</span><br></pre></td></tr></table></figure>\n<p>也可以新建一个启动文件，比如<code>start.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.cmdline <span class=\"keyword\">import</span> execute</span><br><span class=\"line\"></span><br><span class=\"line\">execute(<span class=\"string\">'scrapy crawl stockX'</span>.split())</span><br></pre></td></tr></table></figure>\n<p>4.爬虫脚本</p>\n<p>必须要有<code>name</code>，这个是和启动对应命令对应的的名称</p>\n<p><code>parse</code>以及<code>start_urls</code>和<code>allowed_domains</code>可选</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'baidu'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'baidu.com'</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">'https://www.baidu.com/'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(response.text)</span><br></pre></td></tr></table></figure>\n<p>其中 start_urls 可以接受多个 url 参数，也可以拆分成多个步骤</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'baidu'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'baidu.com'</span>]</span><br><span class=\"line\">    <span class=\"comment\"># start_urls = ['https://www.baidu.com/']</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_requests</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">yield</span> scrapy.Request(<span class=\"string\">'https://www.baidu.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(response.text)</span><br></pre></td></tr></table></figure>\n<hr>\n<ol>\n<li>\n<p><code>Items</code>相当于定义的需要输出的数据模型，用来存储数据，推送给<code>pipline</code>解析处理；</p>\n</li>\n<li>\n<p>如果要爬取多组数据，最好是建立多个模型，即<code>Item</code>；</p>\n</li>\n</ol>\n<hr>\n<h2><span id=\"pipline\">Pipline</span></h2>\n<h3><span id=\"1-介绍\">1. 介绍</span></h3>\n<p>当 item 在 Spider 中被收集之后，会传递到 item pipline 中处理；</p>\n<p>作用：</p>\n<ul>\n<li>清理 html 数据</li>\n<li>验证爬取数据</li>\n<li>去重并丢弃</li>\n<li>数据持久化</li>\n</ul>\n<h3><span id=\"2-编写-item-pipline\">2. 编写 item pipline</span></h3>\n<p>2.1 必须实现的函数</p>\n<ul>\n<li>\n<p>process_item</p>\n<p>每个<code>pipline</code>都是一个 python 类，负责接收到<code>item</code>并执行一些行为，内部必须实现<code>process_item(self, item, spider)</code>方法，必须返回一个<code>dict</code>或者<code>item</code>对象。</p>\n<p><code>piplines</code>只能接受字典和<code>items</code>，在主程序通过<code>yield</code>推送到<code>piplines</code></p>\n<p>2.2 可以选择实现</p>\n</li>\n<li>\n<p><code>open_spider(self, spider)</code>表示当 spider 开启的时候调用的方法；</p>\n</li>\n<li>\n<p><code>close_spider(self, spider)</code>标识当 spider 关闭的时候调用的方法；</p>\n</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li><code>pipline</code>写完需要在配置项<code>settings</code>的<code>ITEM_PIPELINES</code>里写入来启动</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ITEM_PIPELINE &#123;</span><br><span class=\"line\">  demo.pipelines.testDemoPipeline : <span class=\"number\">300</span>    // <span class=\"number\">300</span>是优先级 越大优先级越高</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>文件流写入是缓冲一定字节的数据再一次性写入</p>\n<p>强制立刻写入</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.file.flush()</span><br></pre></td></tr></table></figure>\n<hr>\n<p>2.3 如果编写多个<code>pipeline</code>，则会改成指定大小去依次执行每次推过来的<code>item</code>，如果需要丢弃<code>item</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.exceptions <span class=\"keyword\">import</span> DropItem</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">raise</span> DropItem()</span><br></pre></td></tr></table></figure>\n<p>2.4 推送过来的<code>item</code>并不是一个 list，如果需要存储数据，则需要转成字典</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.json_file.writelines(json.dumps(dict(item), ensure_ascii=<span class=\"literal\">False</span>) + <span class=\"string\">'\\r'</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3>基本用法</h3>\n<p>1.创建项目</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy startproject 项目名称</span><br></pre></td></tr></table></figure>\n<p>2.创建一个爬虫</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy genspider XX XX.com</span><br></pre></td></tr></table></figure>\n<p>3.启动脚本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrapy crawl XX</span><br></pre></td></tr></table></figure>\n<p>也可以新建一个启动文件，比如<code>start.py</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.cmdline <span class=\"keyword\">import</span> execute</span><br><span class=\"line\"></span><br><span class=\"line\">execute(<span class=\"string\">'scrapy crawl stockX'</span>.split())</span><br></pre></td></tr></table></figure>\n<p>4.爬虫脚本</p>\n<p>必须要有<code>name</code>，这个是和启动对应命令对应的的名称</p>\n<p><code>parse</code>以及<code>start_urls</code>和<code>allowed_domains</code>可选</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'baidu'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'baidu.com'</span>]</span><br><span class=\"line\">    start_urls = [<span class=\"string\">'https://www.baidu.com/'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(response.text)</span><br></pre></td></tr></table></figure>\n<p>其中 start_urls 可以接受多个 url 参数，也可以拆分成多个步骤</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiduSpider</span><span class=\"params\">(scrapy.Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'baidu'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'baidu.com'</span>]</span><br><span class=\"line\">    <span class=\"comment\"># start_urls = ['https://www.baidu.com/']</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_requests</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">yield</span> scrapy.Request(<span class=\"string\">'https://www.baidu.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        print(response.text)</span><br></pre></td></tr></table></figure>\n<hr>\n<ol>\n<li>\n<p><code>Items</code>相当于定义的需要输出的数据模型，用来存储数据，推送给<code>pipline</code>解析处理；</p>\n</li>\n<li>\n<p>如果要爬取多组数据，最好是建立多个模型，即<code>Item</code>；</p>\n</li>\n</ol>\n<hr>\n<h2>Pipline</h2>\n<h3>1. 介绍</h3>\n<p>当 item 在 Spider 中被收集之后，会传递到 item pipline 中处理；</p>\n<p>作用：</p>\n<ul>\n<li>清理 html 数据</li>\n<li>验证爬取数据</li>\n<li>去重并丢弃</li>\n<li>数据持久化</li>\n</ul>\n<h3>2. 编写 item pipline</h3>\n<p>2.1 必须实现的函数</p>\n<ul>\n<li>\n<p>process_item</p>\n<p>每个<code>pipline</code>都是一个 python 类，负责接收到<code>item</code>并执行一些行为，内部必须实现<code>process_item(self, item, spider)</code>方法，必须返回一个<code>dict</code>或者<code>item</code>对象。</p>\n<p><code>piplines</code>只能接受字典和<code>items</code>，在主程序通过<code>yield</code>推送到<code>piplines</code></p>\n<p>2.2 可以选择实现</p>\n</li>\n<li>\n<p><code>open_spider(self, spider)</code>表示当 spider 开启的时候调用的方法；</p>\n</li>\n<li>\n<p><code>close_spider(self, spider)</code>标识当 spider 关闭的时候调用的方法；</p>\n</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li><code>pipline</code>写完需要在配置项<code>settings</code>的<code>ITEM_PIPELINES</code>里写入来启动</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ITEM_PIPELINE &#123;</span><br><span class=\"line\">  demo.pipelines.testDemoPipeline : <span class=\"number\">300</span>    // <span class=\"number\">300</span>是优先级 越大优先级越高</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>文件流写入是缓冲一定字节的数据再一次性写入</p>\n<p>强制立刻写入</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.file.flush()</span><br></pre></td></tr></table></figure>\n<hr>\n<p>2.3 如果编写多个<code>pipeline</code>，则会改成指定大小去依次执行每次推过来的<code>item</code>，如果需要丢弃<code>item</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> scrapy.exceptions <span class=\"keyword\">import</span> DropItem</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">raise</span> DropItem()</span><br></pre></td></tr></table></figure>\n<p>2.4 推送过来的<code>item</code>并不是一个 list，如果需要存储数据，则需要转成字典</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.json_file.writelines(json.dumps(dict(item), ensure_ascii=<span class=\"literal\">False</span>) + <span class=\"string\">'\\r'</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"react/vue中dom-diff简易版实现","catalog":true,"date":"2019-06-20T03:33:40.000Z","subtitle":null,"header-img":null,"_content":"\n## 一、创建虚拟dom\n\n利用 `create-react-app`快速创建一个项目模板；\n\n删掉src下的源文件，替换成 index.js\n\n首先我们先要用一个对象定义一个虚拟DOM的数据结构：\n\n```shell\nElement {\n    type: 'ul',\n    props: {\n        class: 'list'\n    },\n    children: [\n        Element{\n            type: 'li',\n            props: {\n                class: 'item'\n            },\n            children: ['a']\n        }\n    ]\n}\n```\n\n开始码代码实现虚拟dom的方法实现。\n\n!['虚拟DOM结构'](https://user-gold-cdn.xitu.io/2018/11/3/166d7c8c5aa6083b?w=2956&h=992&f=png&s=271739)\n浏览器上查看打印的日志信息，如下：\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7ca53ba8fef7?w=1210&h=410&f=png&s=97781)\n\n既然虚拟DOM方法已经写好，下一步就要将这个虚拟dom插入到页面中，那我们可以专门写一个渲染真实节点的方法`render`\n\n先遍历最外层`ul`的`type`和`props`两个属性\n\n![render](https://user-gold-cdn.xitu.io/2018/11/3/166d7e8001b419a3?w=2568&h=1244&f=png&s=359336)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7e9fddde1a34?w=1078&h=128&f=png&s=25171)\n\n注意：`input`标签的`value`属性 还有所有标签的`style`属性\n\n好了，接下来就是继续遍历`children`属性，此时`children`会有两种情况\n\n1. 如果是文本 直接插入；\n2. 如果是子元素，递归遍历直到最终的结果是文本；\n\n![遍历虚拟don元素转换为真实dom结构](https://user-gold-cdn.xitu.io/2018/11/3/166d7f0b58ed9735?w=1036&h=484&f=png&s=95541)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7f0d50748a42?w=676&h=198&f=png&s=31439)\n\n下一步我们将这个实际的DOM元素结构插入到页面中\n\n![append](https://user-gold-cdn.xitu.io/2018/11/3/166d8078bce16225?w=2988&h=774&f=png&s=270016)\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d805dec820f97?w=1120&h=862&f=png&s=112852)\n\n完成第一部分。\n\n---\n\n## 二、实现dom-diff算法\n\n`dom-diff`算法就是在两棵抽象语法树的同一位置采用先序的深度遍历算法做比较，同时用补丁的形式记录需要更新的节点位置。\n\n若`type`不一致直接替换当前节点以及当前节点下的子节点；\n如果两个父节点一致，则从左往后遍历子节点，若子节点一致，遍历子节点下的子节点，依次递归。\n\n补丁包的定义规则如下：\n\n1. 属性不同（type: 'ATTRS', attrs）\n2. 新的节点被删除了 （type: 'REMOVE', index: xxxx）\n3. 节点类型不同/\b新增 （type: 'REPLACE', newNode）\n4. 仅仅是文本变化（type: 'TEXT', text）\n\n新建一个`dom-diff.js`，专门处理`diff`算法\n\n手动调用`diff`方法（react中\b调用`diff`算法是在触发`setState`之后）\n\n两个虚拟dom结构如下：\n\n![虚拟dom结构](https://user-gold-cdn.xitu.io/2018/11/4/166ddf9046719203?w=1272&h=896&f=png&s=189549)\n\n先处理`type`相同，属性不同的情况。\n\n![属性不同](https://user-gold-cdn.xitu.io/2018/11/4/166dca2da79ddd4a?w=1240&h=1688&f=png&s=288100)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166dca49d1e2ece5?w=1158&h=420&f=png&s=70893)\n\n发现控制台已经打印到属性变化的补丁包，最后我们把属性的小补丁包存放到最外层的大补丁包中\n\n```shell\n// 补丁包 存放两个虚拟dom的差异部分\nlet patchs = {}\n// 放到最外层的大补丁包中\nif (currentPatchs.length > 0) {\n  patchs[index] = currentPatchs\n}\n```\n\n好了 相同类型的父节点一样，在属性比较完成之后，就需要比较`children`的属性是否有变化\n比较`children`属性内部元素是否变化，利用递归去遍历\n\n```shell\nlet globalIndex = 0\n\nfunction diffChildren (oldChildrens, newChildrens) {\n  oldChildrens.forEach((child, idx) => {\n    walk(child, newChildrens[idx], ++globalIndex)\n  })\n}\n```\n\n如果一开始`type`类型不相同不需要再去比较，直接用新节点替换老节点即可；\n\n```shell\n// type不一致\ncurrentPatchs.push({\n  type: TYPES.REPLACE,\n  newNode: newTree\n})\n```\n\n兼容并处理好各种情况，比如：新节点不存在的情况，新节点增加，新节点类型改变，新节点文本改变以及新节点的属性变化等情况；\n\n最终拿到所有与旧节点有差异的对象放入patchs这样的一个补丁对象中。\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166dde85f556609a?w=1432&h=1092&f=png&s=211043)\n\n补丁包的`key`就是对应新节点有变化的数据位置。\n\n---\n\n## 三、 打补丁更新视图\n\n最后一步将补丁的差异对象与现有虚拟DOM节点遍历进行一一比较与替换。\n\n![开始打补丁](https://user-gold-cdn.xitu.io/2018/11/4/166ddee92a1a76de?w=1098&h=426&f=png&s=61221)\n\n![补丁步骤](https://user-gold-cdn.xitu.io/2018/11/4/166ddeed8a40ba8c?w=1096&h=1094&f=png&s=175704)\n\n根据之前定义的不同补丁对象结构依次处理\n\n![补丁步骤](https://user-gold-cdn.xitu.io/2018/11/4/166ddf0cc87aaa5d?w=1248&h=1138&f=png&s=192351)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166ddf097e341aaf?w=1006&h=1032&f=png&s=120960)\n\n大功告成！\n\n---\n\n这只是diff算法的一个简易实现，还存在一些复杂情况处理的情况以及还有很多算法上面优化的方案，不过已经让我们大概了解了`diff`算法的原理。\n\n如有笔误或者其他实现不对的地方，还望大家指出，谢谢！\n\n具体代码可以参考github链接查看：[dom-diff-demo](https://github.com/Megan-TA/dom-diff-demo)\n","source":"_posts/react-vue中dom-diff简易版实现.md","raw":"---\ntitle: react/vue中dom-diff简易版实现\ncatalog: true\ndate: 2019-06-20 11:33:40\nsubtitle:\nheader-img:\ntags: vue react\n---\n\n## 一、创建虚拟dom\n\n利用 `create-react-app`快速创建一个项目模板；\n\n删掉src下的源文件，替换成 index.js\n\n首先我们先要用一个对象定义一个虚拟DOM的数据结构：\n\n```shell\nElement {\n    type: 'ul',\n    props: {\n        class: 'list'\n    },\n    children: [\n        Element{\n            type: 'li',\n            props: {\n                class: 'item'\n            },\n            children: ['a']\n        }\n    ]\n}\n```\n\n开始码代码实现虚拟dom的方法实现。\n\n!['虚拟DOM结构'](https://user-gold-cdn.xitu.io/2018/11/3/166d7c8c5aa6083b?w=2956&h=992&f=png&s=271739)\n浏览器上查看打印的日志信息，如下：\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7ca53ba8fef7?w=1210&h=410&f=png&s=97781)\n\n既然虚拟DOM方法已经写好，下一步就要将这个虚拟dom插入到页面中，那我们可以专门写一个渲染真实节点的方法`render`\n\n先遍历最外层`ul`的`type`和`props`两个属性\n\n![render](https://user-gold-cdn.xitu.io/2018/11/3/166d7e8001b419a3?w=2568&h=1244&f=png&s=359336)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7e9fddde1a34?w=1078&h=128&f=png&s=25171)\n\n注意：`input`标签的`value`属性 还有所有标签的`style`属性\n\n好了，接下来就是继续遍历`children`属性，此时`children`会有两种情况\n\n1. 如果是文本 直接插入；\n2. 如果是子元素，递归遍历直到最终的结果是文本；\n\n![遍历虚拟don元素转换为真实dom结构](https://user-gold-cdn.xitu.io/2018/11/3/166d7f0b58ed9735?w=1036&h=484&f=png&s=95541)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d7f0d50748a42?w=676&h=198&f=png&s=31439)\n\n下一步我们将这个实际的DOM元素结构插入到页面中\n\n![append](https://user-gold-cdn.xitu.io/2018/11/3/166d8078bce16225?w=2988&h=774&f=png&s=270016)\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/3/166d805dec820f97?w=1120&h=862&f=png&s=112852)\n\n完成第一部分。\n\n---\n\n## 二、实现dom-diff算法\n\n`dom-diff`算法就是在两棵抽象语法树的同一位置采用先序的深度遍历算法做比较，同时用补丁的形式记录需要更新的节点位置。\n\n若`type`不一致直接替换当前节点以及当前节点下的子节点；\n如果两个父节点一致，则从左往后遍历子节点，若子节点一致，遍历子节点下的子节点，依次递归。\n\n补丁包的定义规则如下：\n\n1. 属性不同（type: 'ATTRS', attrs）\n2. 新的节点被删除了 （type: 'REMOVE', index: xxxx）\n3. 节点类型不同/\b新增 （type: 'REPLACE', newNode）\n4. 仅仅是文本变化（type: 'TEXT', text）\n\n新建一个`dom-diff.js`，专门处理`diff`算法\n\n手动调用`diff`方法（react中\b调用`diff`算法是在触发`setState`之后）\n\n两个虚拟dom结构如下：\n\n![虚拟dom结构](https://user-gold-cdn.xitu.io/2018/11/4/166ddf9046719203?w=1272&h=896&f=png&s=189549)\n\n先处理`type`相同，属性不同的情况。\n\n![属性不同](https://user-gold-cdn.xitu.io/2018/11/4/166dca2da79ddd4a?w=1240&h=1688&f=png&s=288100)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166dca49d1e2ece5?w=1158&h=420&f=png&s=70893)\n\n发现控制台已经打印到属性变化的补丁包，最后我们把属性的小补丁包存放到最外层的大补丁包中\n\n```shell\n// 补丁包 存放两个虚拟dom的差异部分\nlet patchs = {}\n// 放到最外层的大补丁包中\nif (currentPatchs.length > 0) {\n  patchs[index] = currentPatchs\n}\n```\n\n好了 相同类型的父节点一样，在属性比较完成之后，就需要比较`children`的属性是否有变化\n比较`children`属性内部元素是否变化，利用递归去遍历\n\n```shell\nlet globalIndex = 0\n\nfunction diffChildren (oldChildrens, newChildrens) {\n  oldChildrens.forEach((child, idx) => {\n    walk(child, newChildrens[idx], ++globalIndex)\n  })\n}\n```\n\n如果一开始`type`类型不相同不需要再去比较，直接用新节点替换老节点即可；\n\n```shell\n// type不一致\ncurrentPatchs.push({\n  type: TYPES.REPLACE,\n  newNode: newTree\n})\n```\n\n兼容并处理好各种情况，比如：新节点不存在的情况，新节点增加，新节点类型改变，新节点文本改变以及新节点的属性变化等情况；\n\n最终拿到所有与旧节点有差异的对象放入patchs这样的一个补丁对象中。\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166dde85f556609a?w=1432&h=1092&f=png&s=211043)\n\n补丁包的`key`就是对应新节点有变化的数据位置。\n\n---\n\n## 三、 打补丁更新视图\n\n最后一步将补丁的差异对象与现有虚拟DOM节点遍历进行一一比较与替换。\n\n![开始打补丁](https://user-gold-cdn.xitu.io/2018/11/4/166ddee92a1a76de?w=1098&h=426&f=png&s=61221)\n\n![补丁步骤](https://user-gold-cdn.xitu.io/2018/11/4/166ddeed8a40ba8c?w=1096&h=1094&f=png&s=175704)\n\n根据之前定义的不同补丁对象结构依次处理\n\n![补丁步骤](https://user-gold-cdn.xitu.io/2018/11/4/166ddf0cc87aaa5d?w=1248&h=1138&f=png&s=192351)\n\n![控制台日志](https://user-gold-cdn.xitu.io/2018/11/4/166ddf097e341aaf?w=1006&h=1032&f=png&s=120960)\n\n大功告成！\n\n---\n\n这只是diff算法的一个简易实现，还存在一些复杂情况处理的情况以及还有很多算法上面优化的方案，不过已经让我们大概了解了`diff`算法的原理。\n\n如有笔误或者其他实现不对的地方，还望大家指出，谢谢！\n\n具体代码可以参考github链接查看：[dom-diff-demo](https://github.com/Megan-TA/dom-diff-demo)\n","slug":"react-vue中dom-diff简易版实现","published":1,"updated":"2019-07-23T01:57:31.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982l000qgu1p2tsxafsm","content":"<h2><span id=\"一-创建虚拟dom\">一、创建虚拟dom</span></h2>\n<p>利用 <code>create-react-app</code>快速创建一个项目模板；</p>\n<p>删掉src下的源文件，替换成 index.js</p>\n<p>首先我们先要用一个对象定义一个虚拟DOM的数据结构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element &#123;</span><br><span class=\"line\">    type: 'ul',</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        class: 'list'</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">        Element&#123;</span><br><span class=\"line\">            type: 'li',</span><br><span class=\"line\">            props: &#123;</span><br><span class=\"line\">                class: 'item'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            children: ['a']</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开始码代码实现虚拟dom的方法实现。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7c8c5aa6083b?w=2956&amp;h=992&amp;f=png&amp;s=271739\" alt=\"'虚拟DOM结构'\"><br>\n浏览器上查看打印的日志信息，如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7ca53ba8fef7?w=1210&amp;h=410&amp;f=png&amp;s=97781\" alt=\"控制台日志\"></p>\n<p>既然虚拟DOM方法已经写好，下一步就要将这个虚拟dom插入到页面中，那我们可以专门写一个渲染真实节点的方法<code>render</code></p>\n<p>先遍历最外层<code>ul</code>的<code>type</code>和<code>props</code>两个属性</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7e8001b419a3?w=2568&amp;h=1244&amp;f=png&amp;s=359336\" alt=\"render\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7e9fddde1a34?w=1078&amp;h=128&amp;f=png&amp;s=25171\" alt=\"控制台日志\"></p>\n<p>注意：<code>input</code>标签的<code>value</code>属性 还有所有标签的<code>style</code>属性</p>\n<p>好了，接下来就是继续遍历<code>children</code>属性，此时<code>children</code>会有两种情况</p>\n<ol>\n<li>如果是文本 直接插入；</li>\n<li>如果是子元素，递归遍历直到最终的结果是文本；</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7f0b58ed9735?w=1036&amp;h=484&amp;f=png&amp;s=95541\" alt=\"遍历虚拟don元素转换为真实dom结构\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7f0d50748a42?w=676&amp;h=198&amp;f=png&amp;s=31439\" alt=\"控制台日志\"></p>\n<p>下一步我们将这个实际的DOM元素结构插入到页面中</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d8078bce16225?w=2988&amp;h=774&amp;f=png&amp;s=270016\" alt=\"append\"><br>\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d805dec820f97?w=1120&amp;h=862&amp;f=png&amp;s=112852\" alt=\"控制台日志\"></p>\n<p>完成第一部分。</p>\n<hr>\n<h2><span id=\"二-实现dom-diff算法\">二、实现dom-diff算法</span></h2>\n<p><code>dom-diff</code>算法就是在两棵抽象语法树的同一位置采用先序的深度遍历算法做比较，同时用补丁的形式记录需要更新的节点位置。</p>\n<p>若<code>type</code>不一致直接替换当前节点以及当前节点下的子节点；<br>\n如果两个父节点一致，则从左往后遍历子节点，若子节点一致，遍历子节点下的子节点，依次递归。</p>\n<p>补丁包的定义规则如下：</p>\n<ol>\n<li>属性不同（type: ‘ATTRS’, attrs）</li>\n<li>新的节点被删除了 （type: ‘REMOVE’, index: xxxx）</li>\n<li>节点类型不同/\b新增 （type: ‘REPLACE’, newNode）</li>\n<li>仅仅是文本变化（type: ‘TEXT’, text）</li>\n</ol>\n<p>新建一个<code>dom-diff.js</code>，专门处理<code>diff</code>算法</p>\n<p>手动调用<code>diff</code>方法（react中\b调用<code>diff</code>算法是在触发<code>setState</code>之后）</p>\n<p>两个虚拟dom结构如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf9046719203?w=1272&amp;h=896&amp;f=png&amp;s=189549\" alt=\"虚拟dom结构\"></p>\n<p>先处理<code>type</code>相同，属性不同的情况。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dca2da79ddd4a?w=1240&amp;h=1688&amp;f=png&amp;s=288100\" alt=\"属性不同\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dca49d1e2ece5?w=1158&amp;h=420&amp;f=png&amp;s=70893\" alt=\"控制台日志\"></p>\n<p>发现控制台已经打印到属性变化的补丁包，最后我们把属性的小补丁包存放到最外层的大补丁包中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 补丁包 存放两个虚拟dom的差异部分</span><br><span class=\"line\">let patchs = &#123;&#125;</span><br><span class=\"line\">// 放到最外层的大补丁包中</span><br><span class=\"line\">if (currentPatchs.length &gt; 0) &#123;</span><br><span class=\"line\">  patchs[index] = currentPatchs</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了 相同类型的父节点一样，在属性比较完成之后，就需要比较<code>children</code>的属性是否有变化<br>\n比较<code>children</code>属性内部元素是否变化，利用递归去遍历</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let globalIndex = 0</span><br><span class=\"line\"></span><br><span class=\"line\">function diffChildren (oldChildrens, newChildrens) &#123;</span><br><span class=\"line\">  oldChildrens.forEach((child, idx) =&gt; &#123;</span><br><span class=\"line\">    walk(child, newChildrens[idx], ++globalIndex)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一开始<code>type</code>类型不相同不需要再去比较，直接用新节点替换老节点即可；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// type不一致</span><br><span class=\"line\">currentPatchs.push(&#123;</span><br><span class=\"line\">  type: TYPES.REPLACE,</span><br><span class=\"line\">  newNode: newTree</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>兼容并处理好各种情况，比如：新节点不存在的情况，新节点增加，新节点类型改变，新节点文本改变以及新节点的属性变化等情况；</p>\n<p>最终拿到所有与旧节点有差异的对象放入patchs这样的一个补丁对象中。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dde85f556609a?w=1432&amp;h=1092&amp;f=png&amp;s=211043\" alt=\"控制台日志\"></p>\n<p>补丁包的<code>key</code>就是对应新节点有变化的数据位置。</p>\n<hr>\n<h2><span id=\"三-打补丁更新视图\">三、 打补丁更新视图</span></h2>\n<p>最后一步将补丁的差异对象与现有虚拟DOM节点遍历进行一一比较与替换。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddee92a1a76de?w=1098&amp;h=426&amp;f=png&amp;s=61221\" alt=\"开始打补丁\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddeed8a40ba8c?w=1096&amp;h=1094&amp;f=png&amp;s=175704\" alt=\"补丁步骤\"></p>\n<p>根据之前定义的不同补丁对象结构依次处理</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf0cc87aaa5d?w=1248&amp;h=1138&amp;f=png&amp;s=192351\" alt=\"补丁步骤\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf097e341aaf?w=1006&amp;h=1032&amp;f=png&amp;s=120960\" alt=\"控制台日志\"></p>\n<p>大功告成！</p>\n<hr>\n<p>这只是diff算法的一个简易实现，还存在一些复杂情况处理的情况以及还有很多算法上面优化的方案，不过已经让我们大概了解了<code>diff</code>算法的原理。</p>\n<p>如有笔误或者其他实现不对的地方，还望大家指出，谢谢！</p>\n<p>具体代码可以参考github链接查看：<a href=\"https://github.com/Megan-TA/dom-diff-demo\" target=\"_blank\" rel=\"noopener\">dom-diff-demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>一、创建虚拟dom</h2>\n<p>利用 <code>create-react-app</code>快速创建一个项目模板；</p>\n<p>删掉src下的源文件，替换成 index.js</p>\n<p>首先我们先要用一个对象定义一个虚拟DOM的数据结构：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element &#123;</span><br><span class=\"line\">    type: 'ul',</span><br><span class=\"line\">    props: &#123;</span><br><span class=\"line\">        class: 'list'</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [</span><br><span class=\"line\">        Element&#123;</span><br><span class=\"line\">            type: 'li',</span><br><span class=\"line\">            props: &#123;</span><br><span class=\"line\">                class: 'item'</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            children: ['a']</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开始码代码实现虚拟dom的方法实现。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7c8c5aa6083b?w=2956&amp;h=992&amp;f=png&amp;s=271739\" alt=\"'虚拟DOM结构'\"><br>\n浏览器上查看打印的日志信息，如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7ca53ba8fef7?w=1210&amp;h=410&amp;f=png&amp;s=97781\" alt=\"控制台日志\"></p>\n<p>既然虚拟DOM方法已经写好，下一步就要将这个虚拟dom插入到页面中，那我们可以专门写一个渲染真实节点的方法<code>render</code></p>\n<p>先遍历最外层<code>ul</code>的<code>type</code>和<code>props</code>两个属性</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7e8001b419a3?w=2568&amp;h=1244&amp;f=png&amp;s=359336\" alt=\"render\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7e9fddde1a34?w=1078&amp;h=128&amp;f=png&amp;s=25171\" alt=\"控制台日志\"></p>\n<p>注意：<code>input</code>标签的<code>value</code>属性 还有所有标签的<code>style</code>属性</p>\n<p>好了，接下来就是继续遍历<code>children</code>属性，此时<code>children</code>会有两种情况</p>\n<ol>\n<li>如果是文本 直接插入；</li>\n<li>如果是子元素，递归遍历直到最终的结果是文本；</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7f0b58ed9735?w=1036&amp;h=484&amp;f=png&amp;s=95541\" alt=\"遍历虚拟don元素转换为真实dom结构\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d7f0d50748a42?w=676&amp;h=198&amp;f=png&amp;s=31439\" alt=\"控制台日志\"></p>\n<p>下一步我们将这个实际的DOM元素结构插入到页面中</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d8078bce16225?w=2988&amp;h=774&amp;f=png&amp;s=270016\" alt=\"append\"><br>\n<img src=\"https://user-gold-cdn.xitu.io/2018/11/3/166d805dec820f97?w=1120&amp;h=862&amp;f=png&amp;s=112852\" alt=\"控制台日志\"></p>\n<p>完成第一部分。</p>\n<hr>\n<h2>二、实现dom-diff算法</h2>\n<p><code>dom-diff</code>算法就是在两棵抽象语法树的同一位置采用先序的深度遍历算法做比较，同时用补丁的形式记录需要更新的节点位置。</p>\n<p>若<code>type</code>不一致直接替换当前节点以及当前节点下的子节点；<br>\n如果两个父节点一致，则从左往后遍历子节点，若子节点一致，遍历子节点下的子节点，依次递归。</p>\n<p>补丁包的定义规则如下：</p>\n<ol>\n<li>属性不同（type: ‘ATTRS’, attrs）</li>\n<li>新的节点被删除了 （type: ‘REMOVE’, index: xxxx）</li>\n<li>节点类型不同/\b新增 （type: ‘REPLACE’, newNode）</li>\n<li>仅仅是文本变化（type: ‘TEXT’, text）</li>\n</ol>\n<p>新建一个<code>dom-diff.js</code>，专门处理<code>diff</code>算法</p>\n<p>手动调用<code>diff</code>方法（react中\b调用<code>diff</code>算法是在触发<code>setState</code>之后）</p>\n<p>两个虚拟dom结构如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf9046719203?w=1272&amp;h=896&amp;f=png&amp;s=189549\" alt=\"虚拟dom结构\"></p>\n<p>先处理<code>type</code>相同，属性不同的情况。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dca2da79ddd4a?w=1240&amp;h=1688&amp;f=png&amp;s=288100\" alt=\"属性不同\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dca49d1e2ece5?w=1158&amp;h=420&amp;f=png&amp;s=70893\" alt=\"控制台日志\"></p>\n<p>发现控制台已经打印到属性变化的补丁包，最后我们把属性的小补丁包存放到最外层的大补丁包中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 补丁包 存放两个虚拟dom的差异部分</span><br><span class=\"line\">let patchs = &#123;&#125;</span><br><span class=\"line\">// 放到最外层的大补丁包中</span><br><span class=\"line\">if (currentPatchs.length &gt; 0) &#123;</span><br><span class=\"line\">  patchs[index] = currentPatchs</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了 相同类型的父节点一样，在属性比较完成之后，就需要比较<code>children</code>的属性是否有变化<br>\n比较<code>children</code>属性内部元素是否变化，利用递归去遍历</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let globalIndex = 0</span><br><span class=\"line\"></span><br><span class=\"line\">function diffChildren (oldChildrens, newChildrens) &#123;</span><br><span class=\"line\">  oldChildrens.forEach((child, idx) =&gt; &#123;</span><br><span class=\"line\">    walk(child, newChildrens[idx], ++globalIndex)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一开始<code>type</code>类型不相同不需要再去比较，直接用新节点替换老节点即可；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// type不一致</span><br><span class=\"line\">currentPatchs.push(&#123;</span><br><span class=\"line\">  type: TYPES.REPLACE,</span><br><span class=\"line\">  newNode: newTree</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>兼容并处理好各种情况，比如：新节点不存在的情况，新节点增加，新节点类型改变，新节点文本改变以及新节点的属性变化等情况；</p>\n<p>最终拿到所有与旧节点有差异的对象放入patchs这样的一个补丁对象中。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166dde85f556609a?w=1432&amp;h=1092&amp;f=png&amp;s=211043\" alt=\"控制台日志\"></p>\n<p>补丁包的<code>key</code>就是对应新节点有变化的数据位置。</p>\n<hr>\n<h2>三、 打补丁更新视图</h2>\n<p>最后一步将补丁的差异对象与现有虚拟DOM节点遍历进行一一比较与替换。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddee92a1a76de?w=1098&amp;h=426&amp;f=png&amp;s=61221\" alt=\"开始打补丁\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddeed8a40ba8c?w=1096&amp;h=1094&amp;f=png&amp;s=175704\" alt=\"补丁步骤\"></p>\n<p>根据之前定义的不同补丁对象结构依次处理</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf0cc87aaa5d?w=1248&amp;h=1138&amp;f=png&amp;s=192351\" alt=\"补丁步骤\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/4/166ddf097e341aaf?w=1006&amp;h=1032&amp;f=png&amp;s=120960\" alt=\"控制台日志\"></p>\n<p>大功告成！</p>\n<hr>\n<p>这只是diff算法的一个简易实现，还存在一些复杂情况处理的情况以及还有很多算法上面优化的方案，不过已经让我们大概了解了<code>diff</code>算法的原理。</p>\n<p>如有笔误或者其他实现不对的地方，还望大家指出，谢谢！</p>\n<p>具体代码可以参考github链接查看：<a href=\"https://github.com/Megan-TA/dom-diff-demo\" target=\"_blank\" rel=\"noopener\">dom-diff-demo</a></p>\n"},{"title":"vue项目接入sentry","catalog":true,"date":"2019-10-11T07:51:00.000Z","subtitle":null,"header-img":null,"_content":"\n首先需要下载官方提供的 sdk，在项目入口处加入进去。\n\n```shell\nyarn add @sentry/browser\nyarn add @sentry/integrations\n```\n\n在应用的入口文件，比如 app.js，加入如下配置：\n\n```javascript\nimport Vue from 'vue'\nimport * as Sentry from '@sentry/browser'\nimport * as Integrations from '@sentry/integrations'\n\nSentry.init({\n\tdsn: 'https://xxxx@sentry.io/1772852',\n\tintegrations: [new Integrations.Vue({ Vue, attachProps: true })]\n})\n```\n\n其中 dsn 是在 sentry 创建的项目的设置中，找到 dsn 的选项 tab，找到项目的默认 dsn\n\n当然如果 application 打包的时候，觉得入口文件体积很大，或者是出于打包速度优化的考虑，可以将 sentry 相关插件通过 cdn 方式引用\n\n```html\n<!-- <script src=\"https://browser.sentry-cdn.com/5.7.1/bundle.es6.min.js\" integrity=\"sha384-h+FyW7fMq0eyUQeRnmnwiWXMxycy0z8n5sOtIH3NJx5GfqxdletL62letiWALtKy\" crossorigin=\"anonymous\"></script> -->\n<script\n\tsrc=\"https://browser.sentry-cdn.com/5.7.1/bundle.min.js\"\n\tintegrity=\"sha384-KMv6bBTABABhv0NI+rVWly6PIRvdippFEgjpKyxUcpEmDWZTkDOiueL5xW+cztZZ\"\n\tcrossorigin=\"anonymous\"\n></script>\n\n<!-- If you include the integration it will be available under Sentry.Integrations.Vue -->\n<script\n\tsrc=\"https://browser.sentry-cdn.com/5.7.1/vue.min.js\"\n\tcrossorigin=\"anonymous\"\n></script>\n```\n\n做完第一步骤之后，此时项目已经具备有异常错误向 sentry 上报日志的功能，如果我们有更精确知道某些异常错误是哪个发布版本带上的，导致相关异常的开发者是谁，还有想要统计某个版本相对于之前的发布版本，错误情况如何等需求，此时需要使用 sentry 提供的 release 功能。\n\n默认接入 release 官方有几种方式，由于我们发布版本并没有走 gitlab、github 等的 ci 流程，我们采用`sentry-cli`提供的全局命令编写脚本去集成到项目发布流程中。\n\n简单的 release 脚本如下：\n\n```shell\n#!/bin/sh\nexport SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\nexport SENTRY_ORG=poizon\n\nPROJECT=\"ticket-platform\"\n\nVERSION=`sentry-cli releases propose-version`\n\n\n# Create a release\nsentry-cli releases -p PROJECT new $VERSION\n\n# upload sourcemap\n# upload-sourcemaps 指定打包后的js文件在项目的路径\n# --url-prefix 外部通过url访问到js静态资源的路径\nsentry-cli releases -p $PROJECT files $VERSION upload-sourcemaps ./dist/js/ --url-prefix ~/js/\n\n```\n\n同时需要在初始化 sentry 的入口出加上版本号（commitid），和后台看到的版本名称要一致，比如当前 git 的 commitid 前 6 为是 123456，需要改成如下设置：\n\n```javascript\nSentry.init({\n\trelease: '123456',\n\tdsn: 'https://xxxx@sentry.io/1772852',\n\tintegrations: [new Integrations.Vue({ Vue, attachProps: true })]\n})\n```\n\n这时候我们在 sentry 后台系统下查看当前项目的的 release 的 tab 下，能看到已经将 sourcemap 文件都上传到 sentry 服务器。默认`sentry-cli`提供的 release 版本号是根据最后一次 git 提交的 commitid，这样会导致我们在查看版本的时候，面对一连串的 commitid，并不能很简单明了的看到当前版本号，所以需要我们手动指定版本号。\n\n1. 通过手动指定版本号\n\n```shell\n#!/bin/sh\nexport SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\nexport SENTRY_ORG=poizon\n\nTAG=\"ticket-platform@2.10.1\"\n\nPROJECT=\"ticket-platform\"\n\nsentry-cli releases -p $PROJECT new $TAG\n\nsentry-cli releases -p $PROJECT files $TAG upload-sourcemaps ./dist/js/ --url-prefix ~/js/\n\n```\n\n初始化的入口处传入的 release 也设置为`ticket-platform@2.10.1`，可以看到这样的方式很繁琐。\n\n2. 通过官方提供的 webpack 插件`@sentry/webpack-plugin`\n\n前提：项目下新建一个`.sentryclirc`文件，写好 sentry 配置项\n\n```\n[defaults]\nurl=https://xxx.xxxx.com\norg=xxx\nproject=ticket-platform\n\n[auth]\ntoken=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\n```\n\n修改项目本身的 webpack 配置\n\n```javascript\nconst SentryCliPlugin = require('@sentry/webpack-plugin');\n\nconst config = {\n  plugins: [\n    new SentryCliPlugin({\n      include: './dist/js',\n      ignore: ['node_modules']\n      urlPrefix: '~/js/'\n    }),\n  ],\n};\n```\n\n可以看到默认提供的插件也是按照 commitid，在我们项目中在构建的过程时流程大概如下：\n\n- 标准的 git coommit（commitizen/cz-cli）\n- 发版前 standard-version 生成本次的版本号\n- 打包时 获取`package.json`的 version 传入`SentryCliPlugin`的配置项`release`\n\n至此 vue 项目完美接入 sentry\n\n参考资料：\n\n1. [sentry 文档接入 vue](https://docs.sentry.io/platforms/javascript/vue/)\n2. [@sentry/webpack-plugin](https://www.npmjs.com/package/@sentry/webpack-plugin)\n3. [Sentry 前端部署拓展篇（sourcemap 关联、issue 关联、release 控制）](https://segmentfault.com/a/1190000014683598#articleHeader5)\n4. [前端日志监控平台 sentry 使用 @sentry/browser @sentry/webpack-plugin](https://juejin.im/post/5bfe0d5be51d4562587b40b9)\n","source":"_posts/vue项目接入sentry.md","raw":"---\ntitle: vue项目接入sentry\ncatalog: true\ndate: 2019-10-11 15:51:00\nsubtitle:\nheader-img:\ntags: 监控\n---\n\n首先需要下载官方提供的 sdk，在项目入口处加入进去。\n\n```shell\nyarn add @sentry/browser\nyarn add @sentry/integrations\n```\n\n在应用的入口文件，比如 app.js，加入如下配置：\n\n```javascript\nimport Vue from 'vue'\nimport * as Sentry from '@sentry/browser'\nimport * as Integrations from '@sentry/integrations'\n\nSentry.init({\n\tdsn: 'https://xxxx@sentry.io/1772852',\n\tintegrations: [new Integrations.Vue({ Vue, attachProps: true })]\n})\n```\n\n其中 dsn 是在 sentry 创建的项目的设置中，找到 dsn 的选项 tab，找到项目的默认 dsn\n\n当然如果 application 打包的时候，觉得入口文件体积很大，或者是出于打包速度优化的考虑，可以将 sentry 相关插件通过 cdn 方式引用\n\n```html\n<!-- <script src=\"https://browser.sentry-cdn.com/5.7.1/bundle.es6.min.js\" integrity=\"sha384-h+FyW7fMq0eyUQeRnmnwiWXMxycy0z8n5sOtIH3NJx5GfqxdletL62letiWALtKy\" crossorigin=\"anonymous\"></script> -->\n<script\n\tsrc=\"https://browser.sentry-cdn.com/5.7.1/bundle.min.js\"\n\tintegrity=\"sha384-KMv6bBTABABhv0NI+rVWly6PIRvdippFEgjpKyxUcpEmDWZTkDOiueL5xW+cztZZ\"\n\tcrossorigin=\"anonymous\"\n></script>\n\n<!-- If you include the integration it will be available under Sentry.Integrations.Vue -->\n<script\n\tsrc=\"https://browser.sentry-cdn.com/5.7.1/vue.min.js\"\n\tcrossorigin=\"anonymous\"\n></script>\n```\n\n做完第一步骤之后，此时项目已经具备有异常错误向 sentry 上报日志的功能，如果我们有更精确知道某些异常错误是哪个发布版本带上的，导致相关异常的开发者是谁，还有想要统计某个版本相对于之前的发布版本，错误情况如何等需求，此时需要使用 sentry 提供的 release 功能。\n\n默认接入 release 官方有几种方式，由于我们发布版本并没有走 gitlab、github 等的 ci 流程，我们采用`sentry-cli`提供的全局命令编写脚本去集成到项目发布流程中。\n\n简单的 release 脚本如下：\n\n```shell\n#!/bin/sh\nexport SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\nexport SENTRY_ORG=poizon\n\nPROJECT=\"ticket-platform\"\n\nVERSION=`sentry-cli releases propose-version`\n\n\n# Create a release\nsentry-cli releases -p PROJECT new $VERSION\n\n# upload sourcemap\n# upload-sourcemaps 指定打包后的js文件在项目的路径\n# --url-prefix 外部通过url访问到js静态资源的路径\nsentry-cli releases -p $PROJECT files $VERSION upload-sourcemaps ./dist/js/ --url-prefix ~/js/\n\n```\n\n同时需要在初始化 sentry 的入口出加上版本号（commitid），和后台看到的版本名称要一致，比如当前 git 的 commitid 前 6 为是 123456，需要改成如下设置：\n\n```javascript\nSentry.init({\n\trelease: '123456',\n\tdsn: 'https://xxxx@sentry.io/1772852',\n\tintegrations: [new Integrations.Vue({ Vue, attachProps: true })]\n})\n```\n\n这时候我们在 sentry 后台系统下查看当前项目的的 release 的 tab 下，能看到已经将 sourcemap 文件都上传到 sentry 服务器。默认`sentry-cli`提供的 release 版本号是根据最后一次 git 提交的 commitid，这样会导致我们在查看版本的时候，面对一连串的 commitid，并不能很简单明了的看到当前版本号，所以需要我们手动指定版本号。\n\n1. 通过手动指定版本号\n\n```shell\n#!/bin/sh\nexport SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\nexport SENTRY_ORG=poizon\n\nTAG=\"ticket-platform@2.10.1\"\n\nPROJECT=\"ticket-platform\"\n\nsentry-cli releases -p $PROJECT new $TAG\n\nsentry-cli releases -p $PROJECT files $TAG upload-sourcemaps ./dist/js/ --url-prefix ~/js/\n\n```\n\n初始化的入口处传入的 release 也设置为`ticket-platform@2.10.1`，可以看到这样的方式很繁琐。\n\n2. 通过官方提供的 webpack 插件`@sentry/webpack-plugin`\n\n前提：项目下新建一个`.sentryclirc`文件，写好 sentry 配置项\n\n```\n[defaults]\nurl=https://xxx.xxxx.com\norg=xxx\nproject=ticket-platform\n\n[auth]\ntoken=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33\n```\n\n修改项目本身的 webpack 配置\n\n```javascript\nconst SentryCliPlugin = require('@sentry/webpack-plugin');\n\nconst config = {\n  plugins: [\n    new SentryCliPlugin({\n      include: './dist/js',\n      ignore: ['node_modules']\n      urlPrefix: '~/js/'\n    }),\n  ],\n};\n```\n\n可以看到默认提供的插件也是按照 commitid，在我们项目中在构建的过程时流程大概如下：\n\n- 标准的 git coommit（commitizen/cz-cli）\n- 发版前 standard-version 生成本次的版本号\n- 打包时 获取`package.json`的 version 传入`SentryCliPlugin`的配置项`release`\n\n至此 vue 项目完美接入 sentry\n\n参考资料：\n\n1. [sentry 文档接入 vue](https://docs.sentry.io/platforms/javascript/vue/)\n2. [@sentry/webpack-plugin](https://www.npmjs.com/package/@sentry/webpack-plugin)\n3. [Sentry 前端部署拓展篇（sourcemap 关联、issue 关联、release 控制）](https://segmentfault.com/a/1190000014683598#articleHeader5)\n4. [前端日志监控平台 sentry 使用 @sentry/browser @sentry/webpack-plugin](https://juejin.im/post/5bfe0d5be51d4562587b40b9)\n","slug":"vue项目接入sentry","published":1,"updated":"2019-10-27T09:08:51.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982l000sgu1pawj0bmqh","content":"<p>首先需要下载官方提供的 sdk，在项目入口处加入进去。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add @sentry/browser</span><br><span class=\"line\">yarn add @sentry/integrations</span><br></pre></td></tr></table></figure>\n<p>在应用的入口文件，比如 app.js，加入如下配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Sentry <span class=\"keyword\">from</span> <span class=\"string\">'@sentry/browser'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Integrations <span class=\"keyword\">from</span> <span class=\"string\">'@sentry/integrations'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Sentry.init(&#123;</span><br><span class=\"line\">\tdsn: <span class=\"string\">'https://xxxx@sentry.io/1772852'</span>,</span><br><span class=\"line\">\tintegrations: [<span class=\"keyword\">new</span> Integrations.Vue(&#123; Vue, <span class=\"attr\">attachProps</span>: <span class=\"literal\">true</span> &#125;)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中 dsn 是在 sentry 创建的项目的设置中，找到 dsn 的选项 tab，找到项目的默认 dsn</p>\n<p>当然如果 application 打包的时候，觉得入口文件体积很大，或者是出于打包速度优化的考虑，可以将 sentry 相关插件通过 cdn 方式引用</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;script src=\"https://browser.sentry-cdn.com/5.7.1/bundle.es6.min.js\" integrity=\"sha384-h+FyW7fMq0eyUQeRnmnwiWXMxycy0z8n5sOtIH3NJx5GfqxdletL62letiWALtKy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">src</span>=<span class=\"string\">\"https://browser.sentry-cdn.com/5.7.1/bundle.min.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">integrity</span>=<span class=\"string\">\"sha384-KMv6bBTABABhv0NI+rVWly6PIRvdippFEgjpKyxUcpEmDWZTkDOiueL5xW+cztZZ\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">\"anonymous\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- If you include the integration it will be available under Sentry.Integrations.Vue --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">src</span>=<span class=\"string\">\"https://browser.sentry-cdn.com/5.7.1/vue.min.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">\"anonymous\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>做完第一步骤之后，此时项目已经具备有异常错误向 sentry 上报日志的功能，如果我们有更精确知道某些异常错误是哪个发布版本带上的，导致相关异常的开发者是谁，还有想要统计某个版本相对于之前的发布版本，错误情况如何等需求，此时需要使用 sentry 提供的 release 功能。</p>\n<p>默认接入 release 官方有几种方式，由于我们发布版本并没有走 gitlab、github 等的 ci 流程，我们采用<code>sentry-cli</code>提供的全局命令编写脚本去集成到项目发布流程中。</p>\n<p>简单的 release 脚本如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\">export SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br><span class=\"line\">export SENTRY_ORG=poizon</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT=\"ticket-platform\"</span><br><span class=\"line\"></span><br><span class=\"line\">VERSION=`sentry-cli releases propose-version`</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> Create a release</span><br><span class=\"line\">sentry-cli releases -p PROJECT new $VERSION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> upload sourcemap</span><br><span class=\"line\"><span class=\"meta\">#</span> upload-sourcemaps 指定打包后的js文件在项目的路径</span><br><span class=\"line\"><span class=\"meta\">#</span> --url-prefix 外部通过url访问到js静态资源的路径</span><br><span class=\"line\">sentry-cli releases -p $PROJECT files $VERSION upload-sourcemaps ./dist/js/ --url-prefix ~/js/</span><br></pre></td></tr></table></figure>\n<p>同时需要在初始化 sentry 的入口出加上版本号（commitid），和后台看到的版本名称要一致，比如当前 git 的 commitid 前 6 为是 123456，需要改成如下设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sentry.init(&#123;</span><br><span class=\"line\">\trelease: <span class=\"string\">'123456'</span>,</span><br><span class=\"line\">\tdsn: <span class=\"string\">'https://xxxx@sentry.io/1772852'</span>,</span><br><span class=\"line\">\tintegrations: [<span class=\"keyword\">new</span> Integrations.Vue(&#123; Vue, <span class=\"attr\">attachProps</span>: <span class=\"literal\">true</span> &#125;)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候我们在 sentry 后台系统下查看当前项目的的 release 的 tab 下，能看到已经将 sourcemap 文件都上传到 sentry 服务器。默认<code>sentry-cli</code>提供的 release 版本号是根据最后一次 git 提交的 commitid，这样会导致我们在查看版本的时候，面对一连串的 commitid，并不能很简单明了的看到当前版本号，所以需要我们手动指定版本号。</p>\n<ol>\n<li>通过手动指定版本号</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\">export SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br><span class=\"line\">export SENTRY_ORG=poizon</span><br><span class=\"line\"></span><br><span class=\"line\">TAG=\"ticket-platform@2.10.1\"</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT=\"ticket-platform\"</span><br><span class=\"line\"></span><br><span class=\"line\">sentry-cli releases -p $PROJECT new $TAG</span><br><span class=\"line\"></span><br><span class=\"line\">sentry-cli releases -p $PROJECT files $TAG upload-sourcemaps ./dist/js/ --url-prefix ~/js/</span><br></pre></td></tr></table></figure>\n<p>初始化的入口处传入的 release 也设置为<code>ticket-platform@2.10.1</code>，可以看到这样的方式很繁琐。</p>\n<ol start=\"2\">\n<li>通过官方提供的 webpack 插件<code>@sentry/webpack-plugin</code></li>\n</ol>\n<p>前提：项目下新建一个<code>.sentryclirc</code>文件，写好 sentry 配置项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[defaults]</span><br><span class=\"line\">url=https://xxx.xxxx.com</span><br><span class=\"line\">org=xxx</span><br><span class=\"line\">project=ticket-platform</span><br><span class=\"line\"></span><br><span class=\"line\">[auth]</span><br><span class=\"line\">token=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br></pre></td></tr></table></figure>\n<p>修改项目本身的 webpack 配置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SentryCliPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'@sentry/webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> SentryCliPlugin(&#123;</span><br><span class=\"line\">      include: <span class=\"string\">'./dist/js'</span>,</span><br><span class=\"line\">      ignore: [<span class=\"string\">'node_modules'</span>]</span><br><span class=\"line\">      urlPrefix: <span class=\"string\">'~/js/'</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到默认提供的插件也是按照 commitid，在我们项目中在构建的过程时流程大概如下：</p>\n<ul>\n<li>标准的 git coommit（commitizen/cz-cli）</li>\n<li>发版前 standard-version 生成本次的版本号</li>\n<li>打包时 获取<code>package.json</code>的 version 传入<code>SentryCliPlugin</code>的配置项<code>release</code></li>\n</ul>\n<p>至此 vue 项目完美接入 sentry</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://docs.sentry.io/platforms/javascript/vue/\" target=\"_blank\" rel=\"noopener\">sentry 文档接入 vue</a></li>\n<li><a href=\"https://www.npmjs.com/package/@sentry/webpack-plugin\" target=\"_blank\" rel=\"noopener\">@sentry/webpack-plugin</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000014683598#articleHeader5\" target=\"_blank\" rel=\"noopener\">Sentry 前端部署拓展篇（sourcemap 关联、issue 关联、release 控制）</a></li>\n<li><a href=\"https://juejin.im/post/5bfe0d5be51d4562587b40b9\" target=\"_blank\" rel=\"noopener\">前端日志监控平台 sentry 使用 @sentry/browser @sentry/webpack-plugin</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>首先需要下载官方提供的 sdk，在项目入口处加入进去。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add @sentry/browser</span><br><span class=\"line\">yarn add @sentry/integrations</span><br></pre></td></tr></table></figure>\n<p>在应用的入口文件，比如 app.js，加入如下配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Sentry <span class=\"keyword\">from</span> <span class=\"string\">'@sentry/browser'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Integrations <span class=\"keyword\">from</span> <span class=\"string\">'@sentry/integrations'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Sentry.init(&#123;</span><br><span class=\"line\">\tdsn: <span class=\"string\">'https://xxxx@sentry.io/1772852'</span>,</span><br><span class=\"line\">\tintegrations: [<span class=\"keyword\">new</span> Integrations.Vue(&#123; Vue, <span class=\"attr\">attachProps</span>: <span class=\"literal\">true</span> &#125;)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>其中 dsn 是在 sentry 创建的项目的设置中，找到 dsn 的选项 tab，找到项目的默认 dsn</p>\n<p>当然如果 application 打包的时候，觉得入口文件体积很大，或者是出于打包速度优化的考虑，可以将 sentry 相关插件通过 cdn 方式引用</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;script src=\"https://browser.sentry-cdn.com/5.7.1/bundle.es6.min.js\" integrity=\"sha384-h+FyW7fMq0eyUQeRnmnwiWXMxycy0z8n5sOtIH3NJx5GfqxdletL62letiWALtKy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">src</span>=<span class=\"string\">\"https://browser.sentry-cdn.com/5.7.1/bundle.min.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">integrity</span>=<span class=\"string\">\"sha384-KMv6bBTABABhv0NI+rVWly6PIRvdippFEgjpKyxUcpEmDWZTkDOiueL5xW+cztZZ\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">\"anonymous\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- If you include the integration it will be available under Sentry.Integrations.Vue --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">src</span>=<span class=\"string\">\"https://browser.sentry-cdn.com/5.7.1/vue.min.js\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">crossorigin</span>=<span class=\"string\">\"anonymous\"</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>做完第一步骤之后，此时项目已经具备有异常错误向 sentry 上报日志的功能，如果我们有更精确知道某些异常错误是哪个发布版本带上的，导致相关异常的开发者是谁，还有想要统计某个版本相对于之前的发布版本，错误情况如何等需求，此时需要使用 sentry 提供的 release 功能。</p>\n<p>默认接入 release 官方有几种方式，由于我们发布版本并没有走 gitlab、github 等的 ci 流程，我们采用<code>sentry-cli</code>提供的全局命令编写脚本去集成到项目发布流程中。</p>\n<p>简单的 release 脚本如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\">export SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br><span class=\"line\">export SENTRY_ORG=poizon</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT=\"ticket-platform\"</span><br><span class=\"line\"></span><br><span class=\"line\">VERSION=`sentry-cli releases propose-version`</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> Create a release</span><br><span class=\"line\">sentry-cli releases -p PROJECT new $VERSION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> upload sourcemap</span><br><span class=\"line\"><span class=\"meta\">#</span> upload-sourcemaps 指定打包后的js文件在项目的路径</span><br><span class=\"line\"><span class=\"meta\">#</span> --url-prefix 外部通过url访问到js静态资源的路径</span><br><span class=\"line\">sentry-cli releases -p $PROJECT files $VERSION upload-sourcemaps ./dist/js/ --url-prefix ~/js/</span><br></pre></td></tr></table></figure>\n<p>同时需要在初始化 sentry 的入口出加上版本号（commitid），和后台看到的版本名称要一致，比如当前 git 的 commitid 前 6 为是 123456，需要改成如下设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sentry.init(&#123;</span><br><span class=\"line\">\trelease: <span class=\"string\">'123456'</span>,</span><br><span class=\"line\">\tdsn: <span class=\"string\">'https://xxxx@sentry.io/1772852'</span>,</span><br><span class=\"line\">\tintegrations: [<span class=\"keyword\">new</span> Integrations.Vue(&#123; Vue, <span class=\"attr\">attachProps</span>: <span class=\"literal\">true</span> &#125;)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候我们在 sentry 后台系统下查看当前项目的的 release 的 tab 下，能看到已经将 sourcemap 文件都上传到 sentry 服务器。默认<code>sentry-cli</code>提供的 release 版本号是根据最后一次 git 提交的 commitid，这样会导致我们在查看版本的时候，面对一连串的 commitid，并不能很简单明了的看到当前版本号，所以需要我们手动指定版本号。</p>\n<ol>\n<li>通过手动指定版本号</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/sh</span><br><span class=\"line\">export SENTRY_AUTH_TOKEN=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br><span class=\"line\">export SENTRY_ORG=poizon</span><br><span class=\"line\"></span><br><span class=\"line\">TAG=\"ticket-platform@2.10.1\"</span><br><span class=\"line\"></span><br><span class=\"line\">PROJECT=\"ticket-platform\"</span><br><span class=\"line\"></span><br><span class=\"line\">sentry-cli releases -p $PROJECT new $TAG</span><br><span class=\"line\"></span><br><span class=\"line\">sentry-cli releases -p $PROJECT files $TAG upload-sourcemaps ./dist/js/ --url-prefix ~/js/</span><br></pre></td></tr></table></figure>\n<p>初始化的入口处传入的 release 也设置为<code>ticket-platform@2.10.1</code>，可以看到这样的方式很繁琐。</p>\n<ol start=\"2\">\n<li>通过官方提供的 webpack 插件<code>@sentry/webpack-plugin</code></li>\n</ol>\n<p>前提：项目下新建一个<code>.sentryclirc</code>文件，写好 sentry 配置项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[defaults]</span><br><span class=\"line\">url=https://xxx.xxxx.com</span><br><span class=\"line\">org=xxx</span><br><span class=\"line\">project=ticket-platform</span><br><span class=\"line\"></span><br><span class=\"line\">[auth]</span><br><span class=\"line\">token=9b4f6bf1c75e478cab30bb714e0f8e83d712c02a920640e7b7fbf4dc307c1b33</span><br></pre></td></tr></table></figure>\n<p>修改项目本身的 webpack 配置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SentryCliPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'@sentry/webpack-plugin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> SentryCliPlugin(&#123;</span><br><span class=\"line\">      include: <span class=\"string\">'./dist/js'</span>,</span><br><span class=\"line\">      ignore: [<span class=\"string\">'node_modules'</span>]</span><br><span class=\"line\">      urlPrefix: <span class=\"string\">'~/js/'</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到默认提供的插件也是按照 commitid，在我们项目中在构建的过程时流程大概如下：</p>\n<ul>\n<li>标准的 git coommit（commitizen/cz-cli）</li>\n<li>发版前 standard-version 生成本次的版本号</li>\n<li>打包时 获取<code>package.json</code>的 version 传入<code>SentryCliPlugin</code>的配置项<code>release</code></li>\n</ul>\n<p>至此 vue 项目完美接入 sentry</p>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://docs.sentry.io/platforms/javascript/vue/\" target=\"_blank\" rel=\"noopener\">sentry 文档接入 vue</a></li>\n<li><a href=\"https://www.npmjs.com/package/@sentry/webpack-plugin\" target=\"_blank\" rel=\"noopener\">@sentry/webpack-plugin</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000014683598#articleHeader5\" target=\"_blank\" rel=\"noopener\">Sentry 前端部署拓展篇（sourcemap 关联、issue 关联、release 控制）</a></li>\n<li><a href=\"https://juejin.im/post/5bfe0d5be51d4562587b40b9\" target=\"_blank\" rel=\"noopener\">前端日志监控平台 sentry 使用 @sentry/browser @sentry/webpack-plugin</a></li>\n</ol>\n"},{"title":"rollup.js使用","catalog":true,"date":"2019-09-25T03:29:27.000Z","subtitle":null,"header-img":null,"_content":"\noutput.format 生成包的格式，有如下格式：\n\n1. amd -- 异步模块定义，用于像 RequestJS 这样的模块加载器。\n2. cjs -- CommonJS, 适用于 Node 或 Browserify/webpack\n3. es -- 将软件包保存为 ES 模块文件。\n4. iife -- 一个自动执行的功能，适合作为 <script>标签这样的。\n5. umd -- 通用模块定义，以 amd, cjs, 和 iife 为一体。\n","source":"_posts/rollup-js使用.md","raw":"---\ntitle: rollup.js使用\ncatalog: true\ndate: 2019-09-25 11:29:27\nsubtitle:\nheader-img:\ntags: javascript\n---\n\noutput.format 生成包的格式，有如下格式：\n\n1. amd -- 异步模块定义，用于像 RequestJS 这样的模块加载器。\n2. cjs -- CommonJS, 适用于 Node 或 Browserify/webpack\n3. es -- 将软件包保存为 ES 模块文件。\n4. iife -- 一个自动执行的功能，适合作为 <script>标签这样的。\n5. umd -- 通用模块定义，以 amd, cjs, 和 iife 为一体。\n","slug":"rollup-js使用","published":1,"updated":"2019-09-25T03:29:47.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982m000ugu1pgpp8x07p","content":"<p>output.format 生成包的格式，有如下格式：</p>\n<ol>\n<li>amd – 异步模块定义，用于像 RequestJS 这样的模块加载器。</li>\n<li>cjs – CommonJS, 适用于 Node 或 Browserify/webpack</li>\n<li>es – 将软件包保存为 ES 模块文件。</li>\n<li>iife – 一个自动执行的功能，适合作为 <script>标签这样的。</li>\n<li>umd – 通用模块定义，以 amd, cjs, 和 iife 为一体。</li>\n</ol>\n</script></li></ol>","site":{"data":{}},"excerpt":"","more":"<p>output.format 生成包的格式，有如下格式：</p>\n<ol>\n<li>amd – 异步模块定义，用于像 RequestJS 这样的模块加载器。</li>\n<li>cjs – CommonJS, 适用于 Node 或 Browserify/webpack</li>\n<li>es – 将软件包保存为 ES 模块文件。</li>\n<li>iife – 一个自动执行的功能，适合作为 <script>标签这样的。</li>\n<li>umd – 通用模块定义，以 amd, cjs, 和 iife 为一体。</li>\n</ol>\n</script></li></ol>"},{"title":"一些新的api","catalog":true,"date":"2019-07-22T15:00:47.000Z","subtitle":null,"header-img":null,"_content":"\n1. IntersectionObserver\n\n懒加载实现的一种 api，兼容性\n\n参考资料： [谈谈 IntersectionObserver 懒加载](https://www.jianshu.com/p/84a86e41eb2b)\n\n2. css 一个属性`object-fit`实现图片的拉伸、裁剪等\n3. css 动画结束有个事件可以被 js 监听处理\n","source":"_posts/一些新的api.md","raw":"---\ntitle: 一些新的api\ncatalog: true\ndate: 2019-07-22 23:00:47\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n1. IntersectionObserver\n\n懒加载实现的一种 api，兼容性\n\n参考资料： [谈谈 IntersectionObserver 懒加载](https://www.jianshu.com/p/84a86e41eb2b)\n\n2. css 一个属性`object-fit`实现图片的拉伸、裁剪等\n3. css 动画结束有个事件可以被 js 监听处理\n","slug":"一些新的api","published":1,"updated":"2019-12-18T14:13:05.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982n000vgu1p8oelpkta","content":"<ol>\n<li>IntersectionObserver</li>\n</ol>\n<p>懒加载实现的一种 api，兼容性</p>\n<p>参考资料： <a href=\"https://www.jianshu.com/p/84a86e41eb2b\" target=\"_blank\" rel=\"noopener\">谈谈 IntersectionObserver 懒加载</a></p>\n<ol start=\"2\">\n<li>css 一个属性<code>object-fit</code>实现图片的拉伸、裁剪等</li>\n<li>css 动画结束有个事件可以被 js 监听处理</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>IntersectionObserver</li>\n</ol>\n<p>懒加载实现的一种 api，兼容性</p>\n<p>参考资料： <a href=\"https://www.jianshu.com/p/84a86e41eb2b\" target=\"_blank\" rel=\"noopener\">谈谈 IntersectionObserver 懒加载</a></p>\n<ol start=\"2\">\n<li>css 一个属性<code>object-fit</code>实现图片的拉伸、裁剪等</li>\n<li>css 动画结束有个事件可以被 js 监听处理</li>\n</ol>\n"},{"title":"前端算法题整理","catalog":true,"date":"2019-12-16T10:52:54.000Z","subtitle":null,"header-img":null,"_content":"\n1. 两个有序数组合并成一个有序数组\n\n```javascript\nvar a = [1, 7, 10];\nvar b = [2, 4, 12, 16];\n\nfunction merge(arg1, arg2) {\n  var m = arg1.length;\n  var n = arg2.length;\n\n  while (n > 0) {\n    // 原数组的数比插入的数组数大 则将最大的数往后移动到 n+m-1位置\n    // 对应的数组索引减一，继续和两一个数组的值比较\n    if (arg1[m - 1] > arg2[n - 1]) {\n      arg1[n + m - 1] = arg1[m - 1];\n      m--;\n    } else {\n      arg1[n + m - 1] = arg2[n - 1];\n      n--;\n    }\n  }\n\n  return arg1;\n}\n```\n\n2. 斐波那契数列实现\n\n斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N\\*）\n\n```javascript\nfunction fib(nMonth) {\n  return nMonth <= 2\n    ? 1\n    : arguments.callee(nMonth - 1) + arguments.callee(nMonth - 2);\n}\n```\n\n3. 冒泡排序\n\n1、比较相邻的两个元素，如果前一个比后一个大，则交换位置。\n2、比较完第一轮的时候，最后一个元素是最大的元素。\n3、这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。\n\n```javascript\nfunction pop(arr) {\n  for (let i = 0; i <= arr.length - 1; i++) {\n    for (let j = 0; j <= arr.length - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        let temp = arr[j + 1];\n        arr[j + 1] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  return arr;\n}\n```\n\n4. 快速排序\n\n```javascript\nfunction quick(arr) {\n  if (arr.length === 0) return arr;\n  let p = arr[0];\n  let leftArr = [];\n  let rightArr = [];\n  for (let i = 1; i <= arr.length - 2; i++) {\n    if (arr[i] > p) {\n      rightArr.push(arr[i]);\n    } else {\n      leftArr.push(arr[i]);\n    }\n  }\n\n  return quick(leftArr).concat(p, quick(rightArr));\n}\n```\n","source":"_posts/前端算法题整理.md","raw":"---\ntitle: 前端算法题整理\ncatalog: true\ndate: 2019-12-16 18:52:54\nsubtitle:\nheader-img:\ntags:\n---\n\n1. 两个有序数组合并成一个有序数组\n\n```javascript\nvar a = [1, 7, 10];\nvar b = [2, 4, 12, 16];\n\nfunction merge(arg1, arg2) {\n  var m = arg1.length;\n  var n = arg2.length;\n\n  while (n > 0) {\n    // 原数组的数比插入的数组数大 则将最大的数往后移动到 n+m-1位置\n    // 对应的数组索引减一，继续和两一个数组的值比较\n    if (arg1[m - 1] > arg2[n - 1]) {\n      arg1[n + m - 1] = arg1[m - 1];\n      m--;\n    } else {\n      arg1[n + m - 1] = arg2[n - 1];\n      n--;\n    }\n  }\n\n  return arg1;\n}\n```\n\n2. 斐波那契数列实现\n\n斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=3，n∈N\\*）\n\n```javascript\nfunction fib(nMonth) {\n  return nMonth <= 2\n    ? 1\n    : arguments.callee(nMonth - 1) + arguments.callee(nMonth - 2);\n}\n```\n\n3. 冒泡排序\n\n1、比较相邻的两个元素，如果前一个比后一个大，则交换位置。\n2、比较完第一轮的时候，最后一个元素是最大的元素。\n3、这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。\n\n```javascript\nfunction pop(arr) {\n  for (let i = 0; i <= arr.length - 1; i++) {\n    for (let j = 0; j <= arr.length - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        let temp = arr[j + 1];\n        arr[j + 1] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  return arr;\n}\n```\n\n4. 快速排序\n\n```javascript\nfunction quick(arr) {\n  if (arr.length === 0) return arr;\n  let p = arr[0];\n  let leftArr = [];\n  let rightArr = [];\n  for (let i = 1; i <= arr.length - 2; i++) {\n    if (arr[i] > p) {\n      rightArr.push(arr[i]);\n    } else {\n      leftArr.push(arr[i]);\n    }\n  }\n\n  return quick(leftArr).concat(p, quick(rightArr));\n}\n```\n","slug":"前端算法题整理","published":1,"updated":"2019-12-16T15:37:33.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982o000ygu1p9rqscten","content":"<ol>\n<li>两个有序数组合并成一个有序数组</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">12</span>, <span class=\"number\">16</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> m = arg1.length;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = arg2.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原数组的数比插入的数组数大 则将最大的数往后移动到 n+m-1位置</span></span><br><span class=\"line\">    <span class=\"comment\">// 对应的数组索引减一，继续和两一个数组的值比较</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg1[m - <span class=\"number\">1</span>] &gt; arg2[n - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      arg1[n + m - <span class=\"number\">1</span>] = arg1[m - <span class=\"number\">1</span>];</span><br><span class=\"line\">      m--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      arg1[n + m - <span class=\"number\">1</span>] = arg2[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">      n--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>斐波那契数列实现</li>\n</ol>\n<p>斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fib</span>(<span class=\"params\">nMonth</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nMonth &lt;= <span class=\"number\">2</span></span><br><span class=\"line\">    ? <span class=\"number\">1</span></span><br><span class=\"line\">    : <span class=\"built_in\">arguments</span>.callee(nMonth - <span class=\"number\">1</span>) + <span class=\"built_in\">arguments</span>.callee(nMonth - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>冒泡排序</li>\n</ol>\n<p>1、比较相邻的两个元素，如果前一个比后一个大，则交换位置。<br>\n2、比较完第一轮的时候，最后一个元素是最大的元素。<br>\n3、这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pop</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= arr.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= arr.length - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> temp = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">        arr[j] = temp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>快速排序</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quick</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> leftArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= arr.length - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &gt; p) &#123;</span><br><span class=\"line\">      rightArr.push(arr[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      leftArr.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> quick(leftArr).concat(p, quick(rightArr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>两个有序数组合并成一个有序数组</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">12</span>, <span class=\"number\">16</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> m = arg1.length;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = arg2.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原数组的数比插入的数组数大 则将最大的数往后移动到 n+m-1位置</span></span><br><span class=\"line\">    <span class=\"comment\">// 对应的数组索引减一，继续和两一个数组的值比较</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg1[m - <span class=\"number\">1</span>] &gt; arg2[n - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      arg1[n + m - <span class=\"number\">1</span>] = arg1[m - <span class=\"number\">1</span>];</span><br><span class=\"line\">      m--;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      arg1[n + m - <span class=\"number\">1</span>] = arg2[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">      n--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>斐波那契数列实现</li>\n</ol>\n<p>斐波那契数列指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fib</span>(<span class=\"params\">nMonth</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nMonth &lt;= <span class=\"number\">2</span></span><br><span class=\"line\">    ? <span class=\"number\">1</span></span><br><span class=\"line\">    : <span class=\"built_in\">arguments</span>.callee(nMonth - <span class=\"number\">1</span>) + <span class=\"built_in\">arguments</span>.callee(nMonth - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>冒泡排序</li>\n</ol>\n<p>1、比较相邻的两个元素，如果前一个比后一个大，则交换位置。<br>\n2、比较完第一轮的时候，最后一个元素是最大的元素。<br>\n3、这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pop</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= arr.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= arr.length - i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> temp = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">        arr[j] = temp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>快速排序</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quick</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> leftArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rightArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= arr.length - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &gt; p) &#123;</span><br><span class=\"line\">      rightArr.push(arr[i]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      leftArr.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> quick(leftArr).concat(p, quick(rightArr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"分享个人vscode常用插件","catalog":true,"date":"2019-06-19T05:39:11.000Z","subtitle":null,"header-img":null,"_content":"\n1. Visual Studio IntelliCode 智能补全\n2. prettier 快速格式化 CMD+Shift+P\n3. Regex Previewer 正则表达式测试\n4. stylelint\n5. vetur # 开发 vue，语法补全、提示助手 （必备插件）\n6. vscode-icons # vscode 图标显示\n7. 小程序助手\n8. vscode-element-helper\n9. SVG Viewer # 预览 SVG\n10. Path Intellisense 路径自动补全\n11. minapp # 小程序开发语法补全、提示助手\n12. markdownlint markdown 语法支持和预览\n13. Live Server\n14. koroFileHeader # 函数注释、文件信息\n15. GitLens # git 辅助工具\n16. javascript code snippets # js 代码提示、补全\n17. Eslint # 代码风格提示\n18. Element UI Snippets\n19. EditorConfig for vs code\n20. Document This\n21. Debugger for Chrome\n22. Color HighLight\n23. CodeIf\n24. Code Runner\n25. Chinese Lanfguage Pack for vs code\n26. Bracket Pair Colorizer 括号以多彩颜色区分\n27. Beautify # 美化代码\n28. Auto Rename Tag # 自动重命名标签\n29. Auto Close Tag # 自动闭合标签\n","source":"_posts/分享个人vscode常用插件.md","raw":"---\ntitle: 分享个人vscode常用插件\ncatalog: true\ndate: 2019-06-19 13:39:11\nsubtitle:\nheader-img:\ntags: IDE\n---\n\n1. Visual Studio IntelliCode 智能补全\n2. prettier 快速格式化 CMD+Shift+P\n3. Regex Previewer 正则表达式测试\n4. stylelint\n5. vetur # 开发 vue，语法补全、提示助手 （必备插件）\n6. vscode-icons # vscode 图标显示\n7. 小程序助手\n8. vscode-element-helper\n9. SVG Viewer # 预览 SVG\n10. Path Intellisense 路径自动补全\n11. minapp # 小程序开发语法补全、提示助手\n12. markdownlint markdown 语法支持和预览\n13. Live Server\n14. koroFileHeader # 函数注释、文件信息\n15. GitLens # git 辅助工具\n16. javascript code snippets # js 代码提示、补全\n17. Eslint # 代码风格提示\n18. Element UI Snippets\n19. EditorConfig for vs code\n20. Document This\n21. Debugger for Chrome\n22. Color HighLight\n23. CodeIf\n24. Code Runner\n25. Chinese Lanfguage Pack for vs code\n26. Bracket Pair Colorizer 括号以多彩颜色区分\n27. Beautify # 美化代码\n28. Auto Rename Tag # 自动重命名标签\n29. Auto Close Tag # 自动闭合标签\n","slug":"分享个人vscode常用插件","published":1,"updated":"2019-07-23T01:57:31.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982p0010gu1p7r8isdqy","content":"<ol>\n<li>Visual Studio IntelliCode 智能补全</li>\n<li>prettier 快速格式化 CMD+Shift+P</li>\n<li>Regex Previewer 正则表达式测试</li>\n<li>stylelint</li>\n<li>vetur # 开发 vue，语法补全、提示助手 （必备插件）</li>\n<li>vscode-icons # vscode 图标显示</li>\n<li>小程序助手</li>\n<li>vscode-element-helper</li>\n<li>SVG Viewer # 预览 SVG</li>\n<li>Path Intellisense 路径自动补全</li>\n<li>minapp # 小程序开发语法补全、提示助手</li>\n<li>markdownlint markdown 语法支持和预览</li>\n<li>Live Server</li>\n<li>koroFileHeader # 函数注释、文件信息</li>\n<li>GitLens # git 辅助工具</li>\n<li>javascript code snippets # js 代码提示、补全</li>\n<li>Eslint # 代码风格提示</li>\n<li>Element UI Snippets</li>\n<li>EditorConfig for vs code</li>\n<li>Document This</li>\n<li>Debugger for Chrome</li>\n<li>Color HighLight</li>\n<li>CodeIf</li>\n<li>Code Runner</li>\n<li>Chinese Lanfguage Pack for vs code</li>\n<li>Bracket Pair Colorizer 括号以多彩颜色区分</li>\n<li>Beautify # 美化代码</li>\n<li>Auto Rename Tag # 自动重命名标签</li>\n<li>Auto Close Tag # 自动闭合标签</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>Visual Studio IntelliCode 智能补全</li>\n<li>prettier 快速格式化 CMD+Shift+P</li>\n<li>Regex Previewer 正则表达式测试</li>\n<li>stylelint</li>\n<li>vetur # 开发 vue，语法补全、提示助手 （必备插件）</li>\n<li>vscode-icons # vscode 图标显示</li>\n<li>小程序助手</li>\n<li>vscode-element-helper</li>\n<li>SVG Viewer # 预览 SVG</li>\n<li>Path Intellisense 路径自动补全</li>\n<li>minapp # 小程序开发语法补全、提示助手</li>\n<li>markdownlint markdown 语法支持和预览</li>\n<li>Live Server</li>\n<li>koroFileHeader # 函数注释、文件信息</li>\n<li>GitLens # git 辅助工具</li>\n<li>javascript code snippets # js 代码提示、补全</li>\n<li>Eslint # 代码风格提示</li>\n<li>Element UI Snippets</li>\n<li>EditorConfig for vs code</li>\n<li>Document This</li>\n<li>Debugger for Chrome</li>\n<li>Color HighLight</li>\n<li>CodeIf</li>\n<li>Code Runner</li>\n<li>Chinese Lanfguage Pack for vs code</li>\n<li>Bracket Pair Colorizer 括号以多彩颜色区分</li>\n<li>Beautify # 美化代码</li>\n<li>Auto Rename Tag # 自动重命名标签</li>\n<li>Auto Close Tag # 自动闭合标签</li>\n</ol>\n"},{"title":"前端多项目公共模块管理实践","catalog":false,"date":"2019-06-21T06:12:19.000Z","subtitle":null,"header-img":null,"_content":"\n### 1、背景\n\n由于现在公司业务发展比较迅速，产品数量急剧增多，对应的项目也越来越多，光是前端项目目前就已经拥有几十个项目，目测项目的数量会越来越多，这个时候就需要我们将一些公共模块、方法、组件提取出来单独维护和管理，避免同样功能的代码在各个项目中重复开发、复制粘贴以及不好统一维护的难题。\n\n### 2、调研\n\n参考别的一些开源项目以及现在的一些解决方案，梳理下大概有现在几种解决方案：\n\n1. 搭建私有npm仓库；\n2. git submodule；\n3. 外部脚本SDK形式；\n4. iframe；\n\n其中方案1、2比较符合现在工程化和模块化开发形式；\n\n方案2会将远程代码拉下来，在项目中存在多个node_modules文件夹，优点比较适合前期频繁迭代开发；\n\n方案3存在受到浏览器缓存影响，需要及时更新资源的时候在多项目使用的时候会比较难处理；\n\n方案4存在资源隔离，代码不方便控制以及存在影响性能等问题；\n","source":"_posts/前端多项目公共模块管理实践.md","raw":"---\ntitle: 前端多项目公共模块管理实践\ncatalog: false\ndate: 2019-06-21 14:12:19\nsubtitle:\nheader-img:\ntags: web\n---\n\n### 1、背景\n\n由于现在公司业务发展比较迅速，产品数量急剧增多，对应的项目也越来越多，光是前端项目目前就已经拥有几十个项目，目测项目的数量会越来越多，这个时候就需要我们将一些公共模块、方法、组件提取出来单独维护和管理，避免同样功能的代码在各个项目中重复开发、复制粘贴以及不好统一维护的难题。\n\n### 2、调研\n\n参考别的一些开源项目以及现在的一些解决方案，梳理下大概有现在几种解决方案：\n\n1. 搭建私有npm仓库；\n2. git submodule；\n3. 外部脚本SDK形式；\n4. iframe；\n\n其中方案1、2比较符合现在工程化和模块化开发形式；\n\n方案2会将远程代码拉下来，在项目中存在多个node_modules文件夹，优点比较适合前期频繁迭代开发；\n\n方案3存在受到浏览器缓存影响，需要及时更新资源的时候在多项目使用的时候会比较难处理；\n\n方案4存在资源隔离，代码不方便控制以及存在影响性能等问题；\n","slug":"前端多项目公共模块管理实践","published":1,"updated":"2019-07-23T01:57:31.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982q0013gu1p5b855drh","content":"<h3><span id=\"1-背景\">1、背景</span></h3>\n<p>由于现在公司业务发展比较迅速，产品数量急剧增多，对应的项目也越来越多，光是前端项目目前就已经拥有几十个项目，目测项目的数量会越来越多，这个时候就需要我们将一些公共模块、方法、组件提取出来单独维护和管理，避免同样功能的代码在各个项目中重复开发、复制粘贴以及不好统一维护的难题。</p>\n<h3><span id=\"2-调研\">2、调研</span></h3>\n<p>参考别的一些开源项目以及现在的一些解决方案，梳理下大概有现在几种解决方案：</p>\n<ol>\n<li>搭建私有npm仓库；</li>\n<li>git submodule；</li>\n<li>外部脚本SDK形式；</li>\n<li>iframe；</li>\n</ol>\n<p>其中方案1、2比较符合现在工程化和模块化开发形式；</p>\n<p>方案2会将远程代码拉下来，在项目中存在多个node_modules文件夹，优点比较适合前期频繁迭代开发；</p>\n<p>方案3存在受到浏览器缓存影响，需要及时更新资源的时候在多项目使用的时候会比较难处理；</p>\n<p>方案4存在资源隔离，代码不方便控制以及存在影响性能等问题；</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>1、背景</h3>\n<p>由于现在公司业务发展比较迅速，产品数量急剧增多，对应的项目也越来越多，光是前端项目目前就已经拥有几十个项目，目测项目的数量会越来越多，这个时候就需要我们将一些公共模块、方法、组件提取出来单独维护和管理，避免同样功能的代码在各个项目中重复开发、复制粘贴以及不好统一维护的难题。</p>\n<h3>2、调研</h3>\n<p>参考别的一些开源项目以及现在的一些解决方案，梳理下大概有现在几种解决方案：</p>\n<ol>\n<li>搭建私有npm仓库；</li>\n<li>git submodule；</li>\n<li>外部脚本SDK形式；</li>\n<li>iframe；</li>\n</ol>\n<p>其中方案1、2比较符合现在工程化和模块化开发形式；</p>\n<p>方案2会将远程代码拉下来，在项目中存在多个node_modules文件夹，优点比较适合前期频繁迭代开发；</p>\n<p>方案3存在受到浏览器缓存影响，需要及时更新资源的时候在多项目使用的时候会比较难处理；</p>\n<p>方案4存在资源隔离，代码不方便控制以及存在影响性能等问题；</p>\n"},{"title":"常用npm包整理","catalog":false,"date":"2019-07-03T01:56:32.000Z","subtitle":null,"header-img":null,"_content":"\n## git 钩子\n\n- husky\n- lint-staged\n\n## 代码风格相关\n\n- commitizen\n- eslint\n- standard-version\n- stylelint\n\n```shell\nnpm install commitizen -g\n\ncommitizen init cz-conventional-changelog --yarn --dev --exact\n\n\nyarn add standard-version -D\n\n```\n\n配置`package.json`\n\n```json\n\n\"scripts\": {\n\"release\": \"standard-version\"\n},\n\"husky\": {\n    \"hooks\": {\n        \"pre-commit\": \"lint-staged\"\n    }\n},\n\"lint-staged\": {\n    \"src/**/*.{js}\": [\n        \"eslint --fix\",\n        \"git add\"\n    ]\n}\n```\n\n参考链接：\n\n1. [commitizen](https://github.com/commitizen/cz-cli)\n\n## tildify\n\n将绝对路径转换为波形路径 比如/Users/sindresorhus/dev → ~/dev\n\n## ora\n\n这个模块用于在终端里有显示载入动画\n\n## download-git-repo\n\n一个用于下载 git 仓库的项目的模块\n\n## inquirer\n\n是一个命令行的回答的模块，你可以自己设定终端的问题，然后对这些回答给出相应的处理\n\n## commander\n\n可以将文字输出到终端当中 多用于提示 根据定义的 bin 的 name 触发对应脚本\n\n## verdaccio\n\n搭建私有 npm 库\n\n## protocol-buffers\n\nnodejs 处理 rpc 通信的一种数据序列化格式模块 类似 JSON\n","source":"_posts/常用npm包整理.md","raw":"---\ntitle: 常用npm包整理\ncatalog: false\ndate: 2019-07-03 09:56:32\nsubtitle:\nheader-img:\ntags: npm\n---\n\n## git 钩子\n\n- husky\n- lint-staged\n\n## 代码风格相关\n\n- commitizen\n- eslint\n- standard-version\n- stylelint\n\n```shell\nnpm install commitizen -g\n\ncommitizen init cz-conventional-changelog --yarn --dev --exact\n\n\nyarn add standard-version -D\n\n```\n\n配置`package.json`\n\n```json\n\n\"scripts\": {\n\"release\": \"standard-version\"\n},\n\"husky\": {\n    \"hooks\": {\n        \"pre-commit\": \"lint-staged\"\n    }\n},\n\"lint-staged\": {\n    \"src/**/*.{js}\": [\n        \"eslint --fix\",\n        \"git add\"\n    ]\n}\n```\n\n参考链接：\n\n1. [commitizen](https://github.com/commitizen/cz-cli)\n\n## tildify\n\n将绝对路径转换为波形路径 比如/Users/sindresorhus/dev → ~/dev\n\n## ora\n\n这个模块用于在终端里有显示载入动画\n\n## download-git-repo\n\n一个用于下载 git 仓库的项目的模块\n\n## inquirer\n\n是一个命令行的回答的模块，你可以自己设定终端的问题，然后对这些回答给出相应的处理\n\n## commander\n\n可以将文字输出到终端当中 多用于提示 根据定义的 bin 的 name 触发对应脚本\n\n## verdaccio\n\n搭建私有 npm 库\n\n## protocol-buffers\n\nnodejs 处理 rpc 通信的一种数据序列化格式模块 类似 JSON\n","slug":"常用npm包整理","published":1,"updated":"2019-12-18T14:16:40.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982r0015gu1pkx4v13c8","content":"<h2><span id=\"git-钩子\">git 钩子</span></h2>\n<ul>\n<li>husky</li>\n<li>lint-staged</li>\n</ul>\n<h2><span id=\"代码风格相关\">代码风格相关</span></h2>\n<ul>\n<li>commitizen</li>\n<li>eslint</li>\n<li>standard-version</li>\n<li>stylelint</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install commitizen -g</span><br><span class=\"line\"></span><br><span class=\"line\">commitizen init cz-conventional-changelog --yarn --dev --exact</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">yarn add standard-version -D</span><br></pre></td></tr></table></figure>\n<p>配置<code>package.json</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">\"release\": \"standard-version\"</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"husky\": &#123;</span><br><span class=\"line\">    \"hooks\": &#123;</span><br><span class=\"line\">        \"pre-commit\": \"lint-staged\"</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"lint-staged\": &#123;</span><br><span class=\"line\">    \"src/**/*.&#123;js&#125;\": [</span><br><span class=\"line\">        \"eslint --fix\",</span><br><span class=\"line\">        <span class=\"string\">\"git add\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://github.com/commitizen/cz-cli\" target=\"_blank\" rel=\"noopener\">commitizen</a></li>\n</ol>\n<h2><span id=\"tildify\">tildify</span></h2>\n<p>将绝对路径转换为波形路径 比如/Users/sindresorhus/dev → ~/dev</p>\n<h2><span id=\"ora\">ora</span></h2>\n<p>这个模块用于在终端里有显示载入动画</p>\n<h2><span id=\"download-git-repo\">download-git-repo</span></h2>\n<p>一个用于下载 git 仓库的项目的模块</p>\n<h2><span id=\"inquirer\">inquirer</span></h2>\n<p>是一个命令行的回答的模块，你可以自己设定终端的问题，然后对这些回答给出相应的处理</p>\n<h2><span id=\"commander\">commander</span></h2>\n<p>可以将文字输出到终端当中 多用于提示 根据定义的 bin 的 name 触发对应脚本</p>\n<h2><span id=\"verdaccio\">verdaccio</span></h2>\n<p>搭建私有 npm 库</p>\n<h2><span id=\"protocol-buffers\">protocol-buffers</span></h2>\n<p>nodejs 处理 rpc 通信的一种数据序列化格式模块 类似 JSON</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>git 钩子</h2>\n<ul>\n<li>husky</li>\n<li>lint-staged</li>\n</ul>\n<h2>代码风格相关</h2>\n<ul>\n<li>commitizen</li>\n<li>eslint</li>\n<li>standard-version</li>\n<li>stylelint</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install commitizen -g</span><br><span class=\"line\"></span><br><span class=\"line\">commitizen init cz-conventional-changelog --yarn --dev --exact</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">yarn add standard-version -D</span><br></pre></td></tr></table></figure>\n<p>配置<code>package.json</code></p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\"scripts\": &#123;</span><br><span class=\"line\">\"release\": \"standard-version\"</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"husky\": &#123;</span><br><span class=\"line\">    \"hooks\": &#123;</span><br><span class=\"line\">        \"pre-commit\": \"lint-staged\"</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">\"lint-staged\": &#123;</span><br><span class=\"line\">    \"src/**/*.&#123;js&#125;\": [</span><br><span class=\"line\">        \"eslint --fix\",</span><br><span class=\"line\">        <span class=\"string\">\"git add\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://github.com/commitizen/cz-cli\" target=\"_blank\" rel=\"noopener\">commitizen</a></li>\n</ol>\n<h2>tildify</h2>\n<p>将绝对路径转换为波形路径 比如/Users/sindresorhus/dev → ~/dev</p>\n<h2>ora</h2>\n<p>这个模块用于在终端里有显示载入动画</p>\n<h2>download-git-repo</h2>\n<p>一个用于下载 git 仓库的项目的模块</p>\n<h2>inquirer</h2>\n<p>是一个命令行的回答的模块，你可以自己设定终端的问题，然后对这些回答给出相应的处理</p>\n<h2>commander</h2>\n<p>可以将文字输出到终端当中 多用于提示 根据定义的 bin 的 name 触发对应脚本</p>\n<h2>verdaccio</h2>\n<p>搭建私有 npm 库</p>\n<h2>protocol-buffers</h2>\n<p>nodejs 处理 rpc 通信的一种数据序列化格式模块 类似 JSON</p>\n"},{"title":"掉坑记录","catalog":true,"date":"2019-08-28T01:57:42.000Z","subtitle":null,"header-img":null,"_content":"\n1. fetch 的 mode 设置 no-cors 返回的 response 永远都是无效信息\n\n---\n\n### UI\n\n1. `element-ui`的 dialog 组件中存在多个 select 组件，其中一个 select 组件的切换影响另一个 selct 的 options，此时会出现另一个的 select 的值选中之后并不会在 UI 层显示，必须使用 vue 提供的`$forceUpdate`方法强制更新；\n\n2. `element-ui`的走马灯`item`接受数据，要是数据源有变化，会触发重新更新数据源的操作，丢弃当前索引，导致一些特定场景（比如：实时给走马灯添加新数据展示）需要保留索引出问题；\n\n3. `element-ui`的走马灯不断鼠标 hover 的时候，会导致没有完全清除掉定时器，导致瞬间滑动的问题；\n\n4. `element-ui`的走马灯`trigger`方式默认`hover`，有时鼠标从下往上或者反方向滑动会导致索引值不知道偏移到哪里，导致出问题；\n\n---\n\n### linux\n\n1. 后端接口并没有统一提供路径给前端做反向代理，在前端项目请求后端接口时候统一加了`/api/`路径给`nginx`转发，在 nginx 那一层需要对新加的`/api/`路径的接口，去掉`/api/`路径，再将请求转发到指定目标服务。\n\n```nginx\nlocation ~ /api/ {\n    rewrite /api/(.*)$ /$1 break;\n\n    proxy_pass  http://www.baidu.com;\n}\n```\n\n### UI 框架\n\n1. vue 动态更改 data 的数据必须要用`$set`方法设置，否则可能无法响应式，出现场景：表单下拉选中切换展示不同的表单，会出现表单无法输入值来响应。\n\n2. 编辑页面场景，父组件先获取详情接口，然后取到值通过 props 传递值给子组件（比如下拉组件），子组件本身也有调用接口获取下拉数据，就导致 props 传递的值的顺序和本身接口响应拿到值的顺序不可控。为了解决这个问题，在 vue 下通过 v-if 控制子组件的渲染，只有父组件接口取到值了才渲染子组件，可以完美解决 props 传值和接口获取值的顺序不可控。但又会带来下面几个缺点：\n\n- 子组件本身封装不彻底\n- 父组件接口响应慢或者失败导致子组件有明显显示延迟或者不显示\n\n### npm\n\n1. 本地改完代码，直接发包，本地代码未推送；\n2. 多个包在各自分支维护发布，导致不能在一个分支找到所有最新代码；\n","source":"_posts/掉坑记录.md","raw":"---\ntitle: 掉坑记录\ncatalog: true\ndate: 2019-08-28 09:57:42\nsubtitle:\nheader-img:\ntags:\n---\n\n1. fetch 的 mode 设置 no-cors 返回的 response 永远都是无效信息\n\n---\n\n### UI\n\n1. `element-ui`的 dialog 组件中存在多个 select 组件，其中一个 select 组件的切换影响另一个 selct 的 options，此时会出现另一个的 select 的值选中之后并不会在 UI 层显示，必须使用 vue 提供的`$forceUpdate`方法强制更新；\n\n2. `element-ui`的走马灯`item`接受数据，要是数据源有变化，会触发重新更新数据源的操作，丢弃当前索引，导致一些特定场景（比如：实时给走马灯添加新数据展示）需要保留索引出问题；\n\n3. `element-ui`的走马灯不断鼠标 hover 的时候，会导致没有完全清除掉定时器，导致瞬间滑动的问题；\n\n4. `element-ui`的走马灯`trigger`方式默认`hover`，有时鼠标从下往上或者反方向滑动会导致索引值不知道偏移到哪里，导致出问题；\n\n---\n\n### linux\n\n1. 后端接口并没有统一提供路径给前端做反向代理，在前端项目请求后端接口时候统一加了`/api/`路径给`nginx`转发，在 nginx 那一层需要对新加的`/api/`路径的接口，去掉`/api/`路径，再将请求转发到指定目标服务。\n\n```nginx\nlocation ~ /api/ {\n    rewrite /api/(.*)$ /$1 break;\n\n    proxy_pass  http://www.baidu.com;\n}\n```\n\n### UI 框架\n\n1. vue 动态更改 data 的数据必须要用`$set`方法设置，否则可能无法响应式，出现场景：表单下拉选中切换展示不同的表单，会出现表单无法输入值来响应。\n\n2. 编辑页面场景，父组件先获取详情接口，然后取到值通过 props 传递值给子组件（比如下拉组件），子组件本身也有调用接口获取下拉数据，就导致 props 传递的值的顺序和本身接口响应拿到值的顺序不可控。为了解决这个问题，在 vue 下通过 v-if 控制子组件的渲染，只有父组件接口取到值了才渲染子组件，可以完美解决 props 传值和接口获取值的顺序不可控。但又会带来下面几个缺点：\n\n- 子组件本身封装不彻底\n- 父组件接口响应慢或者失败导致子组件有明显显示延迟或者不显示\n\n### npm\n\n1. 本地改完代码，直接发包，本地代码未推送；\n2. 多个包在各自分支维护发布，导致不能在一个分支找到所有最新代码；\n","slug":"掉坑记录","published":1,"updated":"2020-01-03T07:00:55.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982s0018gu1p3l0gbuh1","content":"<ol>\n<li>fetch 的 mode 设置 no-cors 返回的 response 永远都是无效信息</li>\n</ol>\n<hr>\n<h3><span id=\"ui\">UI</span></h3>\n<ol>\n<li>\n<p><code>element-ui</code>的 dialog 组件中存在多个 select 组件，其中一个 select 组件的切换影响另一个 selct 的 options，此时会出现另一个的 select 的值选中之后并不会在 UI 层显示，必须使用 vue 提供的<code>$forceUpdate</code>方法强制更新；</p>\n</li>\n<li>\n<p><code>element-ui</code>的走马灯<code>item</code>接受数据，要是数据源有变化，会触发重新更新数据源的操作，丢弃当前索引，导致一些特定场景（比如：实时给走马灯添加新数据展示）需要保留索引出问题；</p>\n</li>\n<li>\n<p><code>element-ui</code>的走马灯不断鼠标 hover 的时候，会导致没有完全清除掉定时器，导致瞬间滑动的问题；</p>\n</li>\n<li>\n<p><code>element-ui</code>的走马灯<code>trigger</code>方式默认<code>hover</code>，有时鼠标从下往上或者反方向滑动会导致索引值不知道偏移到哪里，导致出问题；</p>\n</li>\n</ol>\n<hr>\n<h3><span id=\"linux\">linux</span></h3>\n<ol>\n<li>后端接口并没有统一提供路径给前端做反向代理，在前端项目请求后端接口时候统一加了<code>/api/</code>路径给<code>nginx</code>转发，在 nginx 那一层需要对新加的<code>/api/</code>路径的接口，去掉<code>/api/</code>路径，再将请求转发到指定目标服务。</li>\n</ol>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">location</span> <span class=\"regexp\">~ /api/</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">rewrite</span> /api/(.*)$ /<span class=\"variable\">$1</span> <span class=\"literal\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span>  http://www.baidu.com;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"ui-框架\">UI 框架</span></h3>\n<ol>\n<li>\n<p>vue 动态更改 data 的数据必须要用<code>$set</code>方法设置，否则可能无法响应式，出现场景：表单下拉选中切换展示不同的表单，会出现表单无法输入值来响应。</p>\n</li>\n<li>\n<p>编辑页面场景，父组件先获取详情接口，然后取到值通过 props 传递值给子组件（比如下拉组件），子组件本身也有调用接口获取下拉数据，就导致 props 传递的值的顺序和本身接口响应拿到值的顺序不可控。为了解决这个问题，在 vue 下通过 v-if 控制子组件的渲染，只有父组件接口取到值了才渲染子组件，可以完美解决 props 传值和接口获取值的顺序不可控。但又会带来下面几个缺点：</p>\n</li>\n</ol>\n<ul>\n<li>子组件本身封装不彻底</li>\n<li>父组件接口响应慢或者失败导致子组件有明显显示延迟或者不显示</li>\n</ul>\n<h3><span id=\"npm\">npm</span></h3>\n<ol>\n<li>本地改完代码，直接发包，本地代码未推送；</li>\n<li>多个包在各自分支维护发布，导致不能在一个分支找到所有最新代码；</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>fetch 的 mode 设置 no-cors 返回的 response 永远都是无效信息</li>\n</ol>\n<hr>\n<h3>UI</h3>\n<ol>\n<li>\n<p><code>element-ui</code>的 dialog 组件中存在多个 select 组件，其中一个 select 组件的切换影响另一个 selct 的 options，此时会出现另一个的 select 的值选中之后并不会在 UI 层显示，必须使用 vue 提供的<code>$forceUpdate</code>方法强制更新；</p>\n</li>\n<li>\n<p><code>element-ui</code>的走马灯<code>item</code>接受数据，要是数据源有变化，会触发重新更新数据源的操作，丢弃当前索引，导致一些特定场景（比如：实时给走马灯添加新数据展示）需要保留索引出问题；</p>\n</li>\n<li>\n<p><code>element-ui</code>的走马灯不断鼠标 hover 的时候，会导致没有完全清除掉定时器，导致瞬间滑动的问题；</p>\n</li>\n<li>\n<p><code>element-ui</code>的走马灯<code>trigger</code>方式默认<code>hover</code>，有时鼠标从下往上或者反方向滑动会导致索引值不知道偏移到哪里，导致出问题；</p>\n</li>\n</ol>\n<hr>\n<h3>linux</h3>\n<ol>\n<li>后端接口并没有统一提供路径给前端做反向代理，在前端项目请求后端接口时候统一加了<code>/api/</code>路径给<code>nginx</code>转发，在 nginx 那一层需要对新加的<code>/api/</code>路径的接口，去掉<code>/api/</code>路径，再将请求转发到指定目标服务。</li>\n</ol>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">location</span> <span class=\"regexp\">~ /api/</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">rewrite</span> /api/(.*)$ /<span class=\"variable\">$1</span> <span class=\"literal\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span>  http://www.baidu.com;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>UI 框架</h3>\n<ol>\n<li>\n<p>vue 动态更改 data 的数据必须要用<code>$set</code>方法设置，否则可能无法响应式，出现场景：表单下拉选中切换展示不同的表单，会出现表单无法输入值来响应。</p>\n</li>\n<li>\n<p>编辑页面场景，父组件先获取详情接口，然后取到值通过 props 传递值给子组件（比如下拉组件），子组件本身也有调用接口获取下拉数据，就导致 props 传递的值的顺序和本身接口响应拿到值的顺序不可控。为了解决这个问题，在 vue 下通过 v-if 控制子组件的渲染，只有父组件接口取到值了才渲染子组件，可以完美解决 props 传值和接口获取值的顺序不可控。但又会带来下面几个缺点：</p>\n</li>\n</ol>\n<ul>\n<li>子组件本身封装不彻底</li>\n<li>父组件接口响应慢或者失败导致子组件有明显显示延迟或者不显示</li>\n</ul>\n<h3>npm</h3>\n<ol>\n<li>本地改完代码，直接发包，本地代码未推送；</li>\n<li>多个包在各自分支维护发布，导致不能在一个分支找到所有最新代码；</li>\n</ol>\n"},{"title":"正则实战","catalog":true,"date":"2019-08-30T06:11:43.000Z","subtitle":null,"header-img":null,"_content":"\n## 10. 正则表达式\n\n> 常用规则\n\n- \\n 回车\n- \\t 制表符\n- \\r 换行符\n- \\s 空格\n- \\u4e00-\\u9fa5 中文\n- \\w 大小写字母\\_数字\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- {n, m} 至少出现 n 次 最多 m 次\n- {n,} 至少 n 次\n- - 任意次\n- - 至少一次\n- {n} 至少 n 次\n- () 分组符号\n- [\\s\\S] 任意字符\n- ^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。\n- 正则的最后位置 , 就代表结束的意思\n\n匹配中文: [\\u4e00-\\u9fa5]\n\n例如：\n\n```\nvar str = '2013-6-7';\nvar re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-\nvar re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-\nvar re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-\n\n--------------------------\nvar str = '2013-6-7';\nvar re = /(\\d+)(-)/g;\n\nstr = str.replace(re,function($0,$1,$2){\n\n    //replace()中如果有子项，\n    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,\n    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )\n    return $1 + '.';  //分别返回2013.   6.\n\n});\n\n```\n\n- [] 表示某个集合中的任意一个\n- [^a] 排除 a\n\n```\n// var re = /\\bclassname\\b/;\n\n// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会\n// 把classname当做一个字符串去匹配。\n\nvar re = new RegExp('\\\\b'+classname+'\\\\b');\n\n// 匹配的时候，classname前面必须是起始或者空格，后面也是。\n\n默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。\n```\n\n---\n\n实战 1\n\n```javascript\n//去掉a标签\na =\n\t'度假：原价购页面<a href=\"jumpType:22,jumplink:273\" style=\"font-size:16px\">sss</a>'\n\n// 其中[\\s\\S]表示任意字符 *? 是一个组合 尽可能匹配少的内容 即不会贪婪匹配到</a>结束\na.replace(/<\\/?a[\\s\\S]*?>/g, '')\n```\n","source":"_posts/正则实战.md","raw":"---\ntitle: 正则实战\ncatalog: true\ndate: 2019-08-30 14:11:43\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n## 10. 正则表达式\n\n> 常用规则\n\n- \\n 回车\n- \\t 制表符\n- \\r 换行符\n- \\s 空格\n- \\u4e00-\\u9fa5 中文\n- \\w 大小写字母\\_数字\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- {n, m} 至少出现 n 次 最多 m 次\n- {n,} 至少 n 次\n- - 任意次\n- - 至少一次\n- {n} 至少 n 次\n- () 分组符号\n- [\\s\\S] 任意字符\n- ^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。\n- 正则的最后位置 , 就代表结束的意思\n\n匹配中文: [\\u4e00-\\u9fa5]\n\n例如：\n\n```\nvar str = '2013-6-7';\nvar re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-\nvar re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-\nvar re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-\n\n--------------------------\nvar str = '2013-6-7';\nvar re = /(\\d+)(-)/g;\n\nstr = str.replace(re,function($0,$1,$2){\n\n    //replace()中如果有子项，\n    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,\n    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )\n    return $1 + '.';  //分别返回2013.   6.\n\n});\n\n```\n\n- [] 表示某个集合中的任意一个\n- [^a] 排除 a\n\n```\n// var re = /\\bclassname\\b/;\n\n// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会\n// 把classname当做一个字符串去匹配。\n\nvar re = new RegExp('\\\\b'+classname+'\\\\b');\n\n// 匹配的时候，classname前面必须是起始或者空格，后面也是。\n\n默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。\n```\n\n---\n\n实战 1\n\n```javascript\n//去掉a标签\na =\n\t'度假：原价购页面<a href=\"jumpType:22,jumplink:273\" style=\"font-size:16px\">sss</a>'\n\n// 其中[\\s\\S]表示任意字符 *? 是一个组合 尽可能匹配少的内容 即不会贪婪匹配到</a>结束\na.replace(/<\\/?a[\\s\\S]*?>/g, '')\n```\n","slug":"正则实战","published":1,"updated":"2019-08-30T06:38:24.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982t001agu1p0bhgq2ly","content":"<h2><span id=\"10-正则表达式\">10. 正则表达式</span></h2>\n<blockquote>\n<p>常用规则</p>\n</blockquote>\n<ul>\n<li>\\n 回车</li>\n<li>\\t 制表符</li>\n<li>\\r 换行符</li>\n<li>\\s 空格</li>\n<li>\\u4e00-\\u9fa5 中文</li>\n<li>\\w 大小写字母_数字</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>{n, m} 至少出现 n 次 最多 m 次</li>\n<li>{n,} 至少 n 次</li>\n<li>\n<ul>\n<li>任意次</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>至少一次</li>\n</ul>\n</li>\n<li>{n} 至少 n 次</li>\n<li>() 分组符号</li>\n<li>[\\s\\S] 任意字符</li>\n<li>^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。</li>\n<li>正则的最后位置 , 就代表结束的意思</li>\n</ul>\n<p>匹配中文: [\\u4e00-\\u9fa5]</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-</span><br><span class=\"line\">var re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-</span><br><span class=\"line\">var re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------</span><br><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //replace()中如果有子项，</span><br><span class=\"line\">    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[] 表示某个集合中的任意一个</li>\n<li>[^a] 排除 a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var re = /\\bclassname\\b/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会</span><br><span class=\"line\">// 把classname当做一个字符串去匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">var re = new RegExp(&apos;\\\\b&apos;+classname+&apos;\\\\b&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配的时候，classname前面必须是起始或者空格，后面也是。</span><br><span class=\"line\"></span><br><span class=\"line\">默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</span><br></pre></td></tr></table></figure>\n<hr>\n<p>实战 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//去掉a标签</span></span><br><span class=\"line\">a =</span><br><span class=\"line\">\t<span class=\"string\">'度假：原价购页面&lt;a href=\"jumpType:22,jumplink:273\" style=\"font-size:16px\"&gt;sss&lt;/a&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其中[\\s\\S]表示任意字符 *? 是一个组合 尽可能匹配少的内容 即不会贪婪匹配到&lt;/a&gt;结束</span></span><br><span class=\"line\">a.replace(<span class=\"regexp\">/&lt;\\/?a[\\s\\S]*?&gt;/g</span>, <span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>10. 正则表达式</h2>\n<blockquote>\n<p>常用规则</p>\n</blockquote>\n<ul>\n<li>\\n 回车</li>\n<li>\\t 制表符</li>\n<li>\\r 换行符</li>\n<li>\\s 空格</li>\n<li>\\u4e00-\\u9fa5 中文</li>\n<li>\\w 大小写字母_数字</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>{n, m} 至少出现 n 次 最多 m 次</li>\n<li>{n,} 至少 n 次</li>\n<li>\n<ul>\n<li>任意次</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>至少一次</li>\n</ul>\n</li>\n<li>{n} 至少 n 次</li>\n<li>() 分组符号</li>\n<li>[\\s\\S] 任意字符</li>\n<li>^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。</li>\n<li>正则的最后位置 , 就代表结束的意思</li>\n</ul>\n<p>匹配中文: [\\u4e00-\\u9fa5]</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-</span><br><span class=\"line\">var re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-</span><br><span class=\"line\">var re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------</span><br><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //replace()中如果有子项，</span><br><span class=\"line\">    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[] 表示某个集合中的任意一个</li>\n<li>[^a] 排除 a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var re = /\\bclassname\\b/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会</span><br><span class=\"line\">// 把classname当做一个字符串去匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">var re = new RegExp(&apos;\\\\b&apos;+classname+&apos;\\\\b&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配的时候，classname前面必须是起始或者空格，后面也是。</span><br><span class=\"line\"></span><br><span class=\"line\">默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</span><br></pre></td></tr></table></figure>\n<hr>\n<p>实战 1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//去掉a标签</span></span><br><span class=\"line\">a =</span><br><span class=\"line\">\t<span class=\"string\">'度假：原价购页面&lt;a href=\"jumpType:22,jumplink:273\" style=\"font-size:16px\"&gt;sss&lt;/a&gt;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其中[\\s\\S]表示任意字符 *? 是一个组合 尽可能匹配少的内容 即不会贪婪匹配到&lt;/a&gt;结束</span></span><br><span class=\"line\">a.replace(<span class=\"regexp\">/&lt;\\/?a[\\s\\S]*?&gt;/g</span>, <span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"序","catalog":true,"date":"2019-06-15T06:00:06.000Z","subtitle":null,"header-img":null,"_content":"\nhello，大家好，我是黄晨，来自江苏泰州，前端开发一枚。\n\n搭建这个博客的原因，主要受限于以下几点：\n\n1. 平时学习、积累的知识需要有一个平台去记录，之前也使用了比如掘金、简书、博客园、github这些网站去在线记录，一开始还能满足自己的需求，后来慢慢觉得还是需要有一个自己的博客，提供一种更自由、个性化的编写体验以及阅读体验；\n2. 知识点需要查阅，温故知新，查漏补缺；\n3. 分享自己遇到的一些知识和经验给其他人去参考和借鉴；\n4. 锻炼书写表达能力；\n5. 希望五年、十年以后回头再查阅自己博客的时候会有另一番风味体验；\n\n如果有任何疑问或者问题咨询，欢迎留言向我咨询；\n\n谢谢。\n","source":"_posts/序.md","raw":"---\ntitle: 序\ncatalog: true\ndate: 2019-06-15 14:00:06\nsubtitle:\nheader-img:\ntags: 随笔\n---\n\nhello，大家好，我是黄晨，来自江苏泰州，前端开发一枚。\n\n搭建这个博客的原因，主要受限于以下几点：\n\n1. 平时学习、积累的知识需要有一个平台去记录，之前也使用了比如掘金、简书、博客园、github这些网站去在线记录，一开始还能满足自己的需求，后来慢慢觉得还是需要有一个自己的博客，提供一种更自由、个性化的编写体验以及阅读体验；\n2. 知识点需要查阅，温故知新，查漏补缺；\n3. 分享自己遇到的一些知识和经验给其他人去参考和借鉴；\n4. 锻炼书写表达能力；\n5. 希望五年、十年以后回头再查阅自己博客的时候会有另一番风味体验；\n\n如果有任何疑问或者问题咨询，欢迎留言向我咨询；\n\n谢谢。\n","slug":"序","published":1,"updated":"2019-07-23T01:57:31.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982u001cgu1pnsffwpaa","content":"<p>hello，大家好，我是黄晨，来自江苏泰州，前端开发一枚。</p>\n<p>搭建这个博客的原因，主要受限于以下几点：</p>\n<ol>\n<li>平时学习、积累的知识需要有一个平台去记录，之前也使用了比如掘金、简书、博客园、github这些网站去在线记录，一开始还能满足自己的需求，后来慢慢觉得还是需要有一个自己的博客，提供一种更自由、个性化的编写体验以及阅读体验；</li>\n<li>知识点需要查阅，温故知新，查漏补缺；</li>\n<li>分享自己遇到的一些知识和经验给其他人去参考和借鉴；</li>\n<li>锻炼书写表达能力；</li>\n<li>希望五年、十年以后回头再查阅自己博客的时候会有另一番风味体验；</li>\n</ol>\n<p>如果有任何疑问或者问题咨询，欢迎留言向我咨询；</p>\n<p>谢谢。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>hello，大家好，我是黄晨，来自江苏泰州，前端开发一枚。</p>\n<p>搭建这个博客的原因，主要受限于以下几点：</p>\n<ol>\n<li>平时学习、积累的知识需要有一个平台去记录，之前也使用了比如掘金、简书、博客园、github这些网站去在线记录，一开始还能满足自己的需求，后来慢慢觉得还是需要有一个自己的博客，提供一种更自由、个性化的编写体验以及阅读体验；</li>\n<li>知识点需要查阅，温故知新，查漏补缺；</li>\n<li>分享自己遇到的一些知识和经验给其他人去参考和借鉴；</li>\n<li>锻炼书写表达能力；</li>\n<li>希望五年、十年以后回头再查阅自己博客的时候会有另一番风味体验；</li>\n</ol>\n<p>如果有任何疑问或者问题咨询，欢迎留言向我咨询；</p>\n<p>谢谢。</p>\n"},{"title":"记录typescript使用的几个注意点","catalog":true,"date":"2019-07-22T05:38:34.000Z","subtitle":null,"header-img":null,"_content":"\n近期在做前端团队公共模块和方法的私有 npm 包的时候，采用`typescript`保证包的代码质量，在使用`ts`的过程遇到一些小问题，特此记录下遇到的一些小问题。\n\n1. 不想一个个导入类型文件，希望有全局引用类型文件\n\n一开始在给每个文件定义类型的时候，都会将文件类型放在`types`文件夹下，通过`es6`模块暴露出来并在项目中引入对应的类型文件，开始引用方式如下：\n\n```javascript\n// types/test.d.ts\nexport declare const test = '123'\n\n// src/test.ts\nimport { test } from '../types/test'\n\n```\n\n这样的话默认也是把`.d.ts`文件当做一个模块，但是每次都引入的时候会比较麻烦，有没有更简便的方法，不需要引入类型文件？\n\n答案是有的：利用全局的`namespace`和`tsconfig.json`配置\n\n以下是`tsconfig.json`一些配置项：\n\n```javascript\n{\n    \"compilerOptions\": {\n      \"target\": \"es5\",\n      \"module\": \"commonjs\",\n      \"outDir\": \"./dist/lib\",\n      \"declaration\": true,  // 开启打包之后会输出.d.ts文件\n      \"declarationDir\": \"./dist/types\",  // 默认.d.ts会输出到文件所在目录下，也可以指定.d.ts存放路径\n      \"strict\": true,\n      \"jsx\": \"preserve\",\n      \"importHelpers\": true,\n      \"removeComments\": true,\n      \"moduleResolution\": \"node\",\n      \"experimentalDecorators\": true,\n      \"allowJs\": false,\n      \"esModuleInterop\": true,\n      \"allowSyntheticDefaultImports\": true,\n      \"sourceMap\": false,\n      \"baseUrl\": \".\",\n      \"types\": [\n        \"node\",\n        \"./types\"  // 本地types所在目录，必须在此引入\n      ],\n      \"lib\": [\n        \"esnext\",\n        \"dom\",\n        \"dom.iterable\",\n        \"scripthost\"\n      ]\n    },\n    \"include\": [\n      \"src/**/*.ts\",\n      \"src/**/**/*.ts\"\n    ],\n    \"exclude\": [\n      \"node_modules\"\n    ]\n}\n\n```\n\n注意上面的 types 配置需要将自己定义的`types`文件导入进来，这样一个未知类型会在这个指定范围去查找。\n\n项目代码使用：\n\n```javascript\n//types/test.d.ts\ndeclare namespace Test {\n    interface Detail {\n        name: string\n    }\n}\n\n// src/test.ts\nfunction getTestDetail (detail: Test.Detail){}\n\n```\n\n这样就不需要项目代码去引用类型文件，缺点是暴露全局的`namespace`，需要自己根据情况作出取舍。\n\n2. 定义自定义对象的属性枚举值\n\n定义一个配置对象，除了`key`之外其他属性一样，利用枚举特性定义`key`\n\n```javascript\ndeclare enum ENV {\n  dev = 'dev',\n  prod = 'prod'\n}\n\nexport interface ConfigResult {\n  region: string\n  accessKeyId: string\n  accessKeySecret: string\n  expAfter: number\n  bucket: string\n  maxSize: number\n  startsWith: string\n  ossHost: string\n  host: string\n}\n\nexport interface Config {\n  [key: string]: {\n    [key in ENV]: ConfigResult\n  }\n}\n\n```\n\n3. 类型文件里面不能导出/定义`枚举值`，枚举值需要单独定义在代码层面，不然会报\n\n```shell\nError: Debug Failure. False expression: Output generation failed\n```\n\n4. 开发第三方库的时候遇到，开发完之后库打包之后，在项目中导入相关方法并没有相关方法的提示，别人是怎么定义包内部方法的提示呢？在 github 上查阅了几个库，在`https://github.com/alibaba/pont`这个项目下发现别人`typing`指向的路径指向本身项目暴露出来的 ts 入口文件，这样就达到使用 ts 的时候有对应的方法提示。\n\n```json\n\"main\": \"lib/index.js\",   // 这个是编译后的库入口文件，一般是js\n\"typings\": \"src/index.ts\", // 这个是给ts用的本身项目开发的出口文件\n```\n\n5. 使用`paths`做路径映射时候，一定要当前项目配置文件指定`baseUrl`为当前目录，遇到继承外部项目公共基础配置，公共基础配置设置`baseUrl`之后，`paths`路径映射是以外部项目为基准；\n\n6. `paths`做了映射之后，利用提供的`tsc`编译后的代码并没有做响应的路径转换，比如`$src/index.ts`，最后编译出来的代码依然是原样，后来是采用`rollup.js`做了打包处理这个问题。\n","source":"_posts/记录typescript使用的几个注意点.md","raw":"---\ntitle: 记录typescript使用的几个注意点\ncatalog: true\ndate: 2019-07-22 13:38:34\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n近期在做前端团队公共模块和方法的私有 npm 包的时候，采用`typescript`保证包的代码质量，在使用`ts`的过程遇到一些小问题，特此记录下遇到的一些小问题。\n\n1. 不想一个个导入类型文件，希望有全局引用类型文件\n\n一开始在给每个文件定义类型的时候，都会将文件类型放在`types`文件夹下，通过`es6`模块暴露出来并在项目中引入对应的类型文件，开始引用方式如下：\n\n```javascript\n// types/test.d.ts\nexport declare const test = '123'\n\n// src/test.ts\nimport { test } from '../types/test'\n\n```\n\n这样的话默认也是把`.d.ts`文件当做一个模块，但是每次都引入的时候会比较麻烦，有没有更简便的方法，不需要引入类型文件？\n\n答案是有的：利用全局的`namespace`和`tsconfig.json`配置\n\n以下是`tsconfig.json`一些配置项：\n\n```javascript\n{\n    \"compilerOptions\": {\n      \"target\": \"es5\",\n      \"module\": \"commonjs\",\n      \"outDir\": \"./dist/lib\",\n      \"declaration\": true,  // 开启打包之后会输出.d.ts文件\n      \"declarationDir\": \"./dist/types\",  // 默认.d.ts会输出到文件所在目录下，也可以指定.d.ts存放路径\n      \"strict\": true,\n      \"jsx\": \"preserve\",\n      \"importHelpers\": true,\n      \"removeComments\": true,\n      \"moduleResolution\": \"node\",\n      \"experimentalDecorators\": true,\n      \"allowJs\": false,\n      \"esModuleInterop\": true,\n      \"allowSyntheticDefaultImports\": true,\n      \"sourceMap\": false,\n      \"baseUrl\": \".\",\n      \"types\": [\n        \"node\",\n        \"./types\"  // 本地types所在目录，必须在此引入\n      ],\n      \"lib\": [\n        \"esnext\",\n        \"dom\",\n        \"dom.iterable\",\n        \"scripthost\"\n      ]\n    },\n    \"include\": [\n      \"src/**/*.ts\",\n      \"src/**/**/*.ts\"\n    ],\n    \"exclude\": [\n      \"node_modules\"\n    ]\n}\n\n```\n\n注意上面的 types 配置需要将自己定义的`types`文件导入进来，这样一个未知类型会在这个指定范围去查找。\n\n项目代码使用：\n\n```javascript\n//types/test.d.ts\ndeclare namespace Test {\n    interface Detail {\n        name: string\n    }\n}\n\n// src/test.ts\nfunction getTestDetail (detail: Test.Detail){}\n\n```\n\n这样就不需要项目代码去引用类型文件，缺点是暴露全局的`namespace`，需要自己根据情况作出取舍。\n\n2. 定义自定义对象的属性枚举值\n\n定义一个配置对象，除了`key`之外其他属性一样，利用枚举特性定义`key`\n\n```javascript\ndeclare enum ENV {\n  dev = 'dev',\n  prod = 'prod'\n}\n\nexport interface ConfigResult {\n  region: string\n  accessKeyId: string\n  accessKeySecret: string\n  expAfter: number\n  bucket: string\n  maxSize: number\n  startsWith: string\n  ossHost: string\n  host: string\n}\n\nexport interface Config {\n  [key: string]: {\n    [key in ENV]: ConfigResult\n  }\n}\n\n```\n\n3. 类型文件里面不能导出/定义`枚举值`，枚举值需要单独定义在代码层面，不然会报\n\n```shell\nError: Debug Failure. False expression: Output generation failed\n```\n\n4. 开发第三方库的时候遇到，开发完之后库打包之后，在项目中导入相关方法并没有相关方法的提示，别人是怎么定义包内部方法的提示呢？在 github 上查阅了几个库，在`https://github.com/alibaba/pont`这个项目下发现别人`typing`指向的路径指向本身项目暴露出来的 ts 入口文件，这样就达到使用 ts 的时候有对应的方法提示。\n\n```json\n\"main\": \"lib/index.js\",   // 这个是编译后的库入口文件，一般是js\n\"typings\": \"src/index.ts\", // 这个是给ts用的本身项目开发的出口文件\n```\n\n5. 使用`paths`做路径映射时候，一定要当前项目配置文件指定`baseUrl`为当前目录，遇到继承外部项目公共基础配置，公共基础配置设置`baseUrl`之后，`paths`路径映射是以外部项目为基准；\n\n6. `paths`做了映射之后，利用提供的`tsc`编译后的代码并没有做响应的路径转换，比如`$src/index.ts`，最后编译出来的代码依然是原样，后来是采用`rollup.js`做了打包处理这个问题。\n","slug":"记录typescript使用的几个注意点","published":1,"updated":"2019-09-24T04:22:23.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982v001egu1pruwlesbc","content":"<p>近期在做前端团队公共模块和方法的私有 npm 包的时候，采用<code>typescript</code>保证包的代码质量，在使用<code>ts</code>的过程遇到一些小问题，特此记录下遇到的一些小问题。</p>\n<ol>\n<li>不想一个个导入类型文件，希望有全局引用类型文件</li>\n</ol>\n<p>一开始在给每个文件定义类型的时候，都会将文件类型放在<code>types</code>文件夹下，通过<code>es6</code>模块暴露出来并在项目中引入对应的类型文件，开始引用方式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// types/test.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> declare <span class=\"keyword\">const</span> test = <span class=\"string\">'123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/test.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; test &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../types/test'</span></span><br></pre></td></tr></table></figure>\n<p>这样的话默认也是把<code>.d.ts</code>文件当做一个模块，但是每次都引入的时候会比较麻烦，有没有更简便的方法，不需要引入类型文件？</p>\n<p>答案是有的：利用全局的<code>namespace</code>和<code>tsconfig.json</code>配置</p>\n<p>以下是<code>tsconfig.json</code>一些配置项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"target\"</span>: <span class=\"string\">\"es5\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"module\"</span>: <span class=\"string\">\"commonjs\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"outDir\"</span>: <span class=\"string\">\"./dist/lib\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"declaration\"</span>: <span class=\"literal\">true</span>,  <span class=\"comment\">// 开启打包之后会输出.d.ts文件</span></span><br><span class=\"line\">      <span class=\"string\">\"declarationDir\"</span>: <span class=\"string\">\"./dist/types\"</span>,  <span class=\"comment\">// 默认.d.ts会输出到文件所在目录下，也可以指定.d.ts存放路径</span></span><br><span class=\"line\">      <span class=\"string\">\"strict\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"jsx\"</span>: <span class=\"string\">\"preserve\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"importHelpers\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"removeComments\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"moduleResolution\"</span>: <span class=\"string\">\"node\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"experimentalDecorators\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"allowJs\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"esModuleInterop\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"allowSyntheticDefaultImports\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"sourceMap\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"baseUrl\"</span>: <span class=\"string\">\".\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"types\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"node\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"./types\"</span>  <span class=\"comment\">// 本地types所在目录，必须在此引入</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"string\">\"lib\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"esnext\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"dom\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"dom.iterable\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"scripthost\"</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"include\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"src/**/*.ts\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"src/**/**/*.ts\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"exclude\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"node_modules\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意上面的 types 配置需要将自己定义的<code>types</code>文件导入进来，这样一个未知类型会在这个指定范围去查找。</p>\n<p>项目代码使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//types/test.d.ts</span></span><br><span class=\"line\">declare namespace Test &#123;</span><br><span class=\"line\">    interface Detail &#123;</span><br><span class=\"line\">        name: string</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/test.ts</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTestDetail</span> (<span class=\"params\">detail: Test.Detail</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就不需要项目代码去引用类型文件，缺点是暴露全局的<code>namespace</code>，需要自己根据情况作出取舍。</p>\n<ol start=\"2\">\n<li>定义自定义对象的属性枚举值</li>\n</ol>\n<p>定义一个配置对象，除了<code>key</code>之外其他属性一样，利用枚举特性定义<code>key</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare enum ENV &#123;</span><br><span class=\"line\">  dev = <span class=\"string\">'dev'</span>,</span><br><span class=\"line\">  prod = <span class=\"string\">'prod'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface ConfigResult &#123;</span><br><span class=\"line\">  region: string</span><br><span class=\"line\">  accessKeyId: string</span><br><span class=\"line\">  accessKeySecret: string</span><br><span class=\"line\">  expAfter: number</span><br><span class=\"line\">  bucket: string</span><br><span class=\"line\">  maxSize: number</span><br><span class=\"line\">  startsWith: string</span><br><span class=\"line\">  ossHost: string</span><br><span class=\"line\">  host: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface Config &#123;</span><br><span class=\"line\">  [key: string]: &#123;</span><br><span class=\"line\">    [key <span class=\"keyword\">in</span> ENV]: ConfigResult</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>类型文件里面不能导出/定义<code>枚举值</code>，枚举值需要单独定义在代码层面，不然会报</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Debug Failure. False expression: Output generation failed</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>开发第三方库的时候遇到，开发完之后库打包之后，在项目中导入相关方法并没有相关方法的提示，别人是怎么定义包内部方法的提示呢？在 github 上查阅了几个库，在<code>https://github.com/alibaba/pont</code>这个项目下发现别人<code>typing</code>指向的路径指向本身项目暴露出来的 ts 入口文件，这样就达到使用 ts 的时候有对应的方法提示。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"main\": \"lib/index.js\",   // 这个是编译后的库入口文件，一般是js</span><br><span class=\"line\">\"typings\": \"src/index.ts\", // 这个是给ts用的本身项目开发的出口文件</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>\n<p>使用<code>paths</code>做路径映射时候，一定要当前项目配置文件指定<code>baseUrl</code>为当前目录，遇到继承外部项目公共基础配置，公共基础配置设置<code>baseUrl</code>之后，<code>paths</code>路径映射是以外部项目为基准；</p>\n</li>\n<li>\n<p><code>paths</code>做了映射之后，利用提供的<code>tsc</code>编译后的代码并没有做响应的路径转换，比如<code>$src/index.ts</code>，最后编译出来的代码依然是原样，后来是采用<code>rollup.js</code>做了打包处理这个问题。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>近期在做前端团队公共模块和方法的私有 npm 包的时候，采用<code>typescript</code>保证包的代码质量，在使用<code>ts</code>的过程遇到一些小问题，特此记录下遇到的一些小问题。</p>\n<ol>\n<li>不想一个个导入类型文件，希望有全局引用类型文件</li>\n</ol>\n<p>一开始在给每个文件定义类型的时候，都会将文件类型放在<code>types</code>文件夹下，通过<code>es6</code>模块暴露出来并在项目中引入对应的类型文件，开始引用方式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// types/test.d.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> declare <span class=\"keyword\">const</span> test = <span class=\"string\">'123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/test.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; test &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../types/test'</span></span><br></pre></td></tr></table></figure>\n<p>这样的话默认也是把<code>.d.ts</code>文件当做一个模块，但是每次都引入的时候会比较麻烦，有没有更简便的方法，不需要引入类型文件？</p>\n<p>答案是有的：利用全局的<code>namespace</code>和<code>tsconfig.json</code>配置</p>\n<p>以下是<code>tsconfig.json</code>一些配置项：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"target\"</span>: <span class=\"string\">\"es5\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"module\"</span>: <span class=\"string\">\"commonjs\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"outDir\"</span>: <span class=\"string\">\"./dist/lib\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"declaration\"</span>: <span class=\"literal\">true</span>,  <span class=\"comment\">// 开启打包之后会输出.d.ts文件</span></span><br><span class=\"line\">      <span class=\"string\">\"declarationDir\"</span>: <span class=\"string\">\"./dist/types\"</span>,  <span class=\"comment\">// 默认.d.ts会输出到文件所在目录下，也可以指定.d.ts存放路径</span></span><br><span class=\"line\">      <span class=\"string\">\"strict\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"jsx\"</span>: <span class=\"string\">\"preserve\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"importHelpers\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"removeComments\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"moduleResolution\"</span>: <span class=\"string\">\"node\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"experimentalDecorators\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"allowJs\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"esModuleInterop\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"allowSyntheticDefaultImports\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"sourceMap\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">\"baseUrl\"</span>: <span class=\"string\">\".\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"types\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"node\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"./types\"</span>  <span class=\"comment\">// 本地types所在目录，必须在此引入</span></span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"string\">\"lib\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"esnext\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"dom\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"dom.iterable\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"scripthost\"</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"include\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"src/**/*.ts\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"src/**/**/*.ts\"</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"exclude\"</span>: [</span><br><span class=\"line\">      <span class=\"string\">\"node_modules\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意上面的 types 配置需要将自己定义的<code>types</code>文件导入进来，这样一个未知类型会在这个指定范围去查找。</p>\n<p>项目代码使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//types/test.d.ts</span></span><br><span class=\"line\">declare namespace Test &#123;</span><br><span class=\"line\">    interface Detail &#123;</span><br><span class=\"line\">        name: string</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src/test.ts</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTestDetail</span> (<span class=\"params\">detail: Test.Detail</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就不需要项目代码去引用类型文件，缺点是暴露全局的<code>namespace</code>，需要自己根据情况作出取舍。</p>\n<ol start=\"2\">\n<li>定义自定义对象的属性枚举值</li>\n</ol>\n<p>定义一个配置对象，除了<code>key</code>之外其他属性一样，利用枚举特性定义<code>key</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare enum ENV &#123;</span><br><span class=\"line\">  dev = <span class=\"string\">'dev'</span>,</span><br><span class=\"line\">  prod = <span class=\"string\">'prod'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface ConfigResult &#123;</span><br><span class=\"line\">  region: string</span><br><span class=\"line\">  accessKeyId: string</span><br><span class=\"line\">  accessKeySecret: string</span><br><span class=\"line\">  expAfter: number</span><br><span class=\"line\">  bucket: string</span><br><span class=\"line\">  maxSize: number</span><br><span class=\"line\">  startsWith: string</span><br><span class=\"line\">  ossHost: string</span><br><span class=\"line\">  host: string</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> interface Config &#123;</span><br><span class=\"line\">  [key: string]: &#123;</span><br><span class=\"line\">    [key <span class=\"keyword\">in</span> ENV]: ConfigResult</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>类型文件里面不能导出/定义<code>枚举值</code>，枚举值需要单独定义在代码层面，不然会报</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: Debug Failure. False expression: Output generation failed</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>开发第三方库的时候遇到，开发完之后库打包之后，在项目中导入相关方法并没有相关方法的提示，别人是怎么定义包内部方法的提示呢？在 github 上查阅了几个库，在<code>https://github.com/alibaba/pont</code>这个项目下发现别人<code>typing</code>指向的路径指向本身项目暴露出来的 ts 入口文件，这样就达到使用 ts 的时候有对应的方法提示。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"main\": \"lib/index.js\",   // 这个是编译后的库入口文件，一般是js</span><br><span class=\"line\">\"typings\": \"src/index.ts\", // 这个是给ts用的本身项目开发的出口文件</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>\n<p>使用<code>paths</code>做路径映射时候，一定要当前项目配置文件指定<code>baseUrl</code>为当前目录，遇到继承外部项目公共基础配置，公共基础配置设置<code>baseUrl</code>之后，<code>paths</code>路径映射是以外部项目为基准；</p>\n</li>\n<li>\n<p><code>paths</code>做了映射之后，利用提供的<code>tsc</code>编译后的代码并没有做响应的路径转换，比如<code>$src/index.ts</code>，最后编译出来的代码依然是原样，后来是采用<code>rollup.js</code>做了打包处理这个问题。</p>\n</li>\n</ol>\n"},{"title":"记录一次node爬虫开发","catalog":true,"date":"2019-05-07T14:42:51.000Z","subtitle":null,"header-img":null,"_content":"\n在做一个爬虫开发需求的使用，由于目标网站是动态的，无法直接处理静态资源，这时候想到使用`google`推出的`node`无头浏览器`puppeteer`，借此尝试一下。\n\n因为我当时开发的时候，在`mac`上开发，开发完毕之后需要部署到远程`centos7`的远程服务器上，部署的时候就有个小问题，如何判断系统环境是 mac、window 还是 linux，来决定导出的文件存放的目录。\n\n```javascript\nconst os = require('os')\n//Linux系统上'Linux'\n//macOS 系统上'Darwin'\n//Windows系统上'Windows_NT'\nlet sysType = os.type()\nif (sysType === 'Windows_NT') {\n\tconsole.log(\"It's windows\")\n}\n```\n\n一切开发顺利，在`centos7`上部署的时候，遇到`pupeteer`几个问题：\n\n- 无法下载（需要翻墙）\n- 无法启动（具体解决见参考链接）\n\n参考链接：\n\n1. [centos 安装 puppeteer 启动失败解决处理](<[https://segmentfault.com/a/1190000011382062](https://segmentfault.com/a/1190000011382062)>)\n","source":"_posts/记录一次node爬虫开发.md","raw":"---\ntitle: 记录一次node爬虫开发\ncatalog: true\ndate: 2019-05-07 22:42:51\nsubtitle:\nheader-img:\ntags: node\n---\n\n在做一个爬虫开发需求的使用，由于目标网站是动态的，无法直接处理静态资源，这时候想到使用`google`推出的`node`无头浏览器`puppeteer`，借此尝试一下。\n\n因为我当时开发的时候，在`mac`上开发，开发完毕之后需要部署到远程`centos7`的远程服务器上，部署的时候就有个小问题，如何判断系统环境是 mac、window 还是 linux，来决定导出的文件存放的目录。\n\n```javascript\nconst os = require('os')\n//Linux系统上'Linux'\n//macOS 系统上'Darwin'\n//Windows系统上'Windows_NT'\nlet sysType = os.type()\nif (sysType === 'Windows_NT') {\n\tconsole.log(\"It's windows\")\n}\n```\n\n一切开发顺利，在`centos7`上部署的时候，遇到`pupeteer`几个问题：\n\n- 无法下载（需要翻墙）\n- 无法启动（具体解决见参考链接）\n\n参考链接：\n\n1. [centos 安装 puppeteer 启动失败解决处理](<[https://segmentfault.com/a/1190000011382062](https://segmentfault.com/a/1190000011382062)>)\n","slug":"记录一次node爬虫开发","published":1,"updated":"2019-07-25T14:49:48.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982w001hgu1pug4wjyf5","content":"<p>在做一个爬虫开发需求的使用，由于目标网站是动态的，无法直接处理静态资源，这时候想到使用<code>google</code>推出的<code>node</code>无头浏览器<code>puppeteer</code>，借此尝试一下。</p>\n<p>因为我当时开发的时候，在<code>mac</code>上开发，开发完毕之后需要部署到远程<code>centos7</code>的远程服务器上，部署的时候就有个小问题，如何判断系统环境是 mac、window 还是 linux，来决定导出的文件存放的目录。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> os = <span class=\"built_in\">require</span>(<span class=\"string\">'os'</span>)</span><br><span class=\"line\"><span class=\"comment\">//Linux系统上'Linux'</span></span><br><span class=\"line\"><span class=\"comment\">//macOS 系统上'Darwin'</span></span><br><span class=\"line\"><span class=\"comment\">//Windows系统上'Windows_NT'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sysType = os.type()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sysType === <span class=\"string\">'Windows_NT'</span>) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"It's windows\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一切开发顺利，在<code>centos7</code>上部署的时候，遇到<code>pupeteer</code>几个问题：</p>\n<ul>\n<li>无法下载（需要翻墙）</li>\n<li>无法启动（具体解决见参考链接）</li>\n</ul>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"%5Bhttps://segmentfault.com/a/1190000011382062%5D(https://segmentfault.com/a/1190000011382062)\">centos 安装 puppeteer 启动失败解决处理</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>在做一个爬虫开发需求的使用，由于目标网站是动态的，无法直接处理静态资源，这时候想到使用<code>google</code>推出的<code>node</code>无头浏览器<code>puppeteer</code>，借此尝试一下。</p>\n<p>因为我当时开发的时候，在<code>mac</code>上开发，开发完毕之后需要部署到远程<code>centos7</code>的远程服务器上，部署的时候就有个小问题，如何判断系统环境是 mac、window 还是 linux，来决定导出的文件存放的目录。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> os = <span class=\"built_in\">require</span>(<span class=\"string\">'os'</span>)</span><br><span class=\"line\"><span class=\"comment\">//Linux系统上'Linux'</span></span><br><span class=\"line\"><span class=\"comment\">//macOS 系统上'Darwin'</span></span><br><span class=\"line\"><span class=\"comment\">//Windows系统上'Windows_NT'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sysType = os.type()</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sysType === <span class=\"string\">'Windows_NT'</span>) &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"It's windows\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一切开发顺利，在<code>centos7</code>上部署的时候，遇到<code>pupeteer</code>几个问题：</p>\n<ul>\n<li>无法下载（需要翻墙）</li>\n<li>无法启动（具体解决见参考链接）</li>\n</ul>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"%5Bhttps://segmentfault.com/a/1190000011382062%5D(https://segmentfault.com/a/1190000011382062)\">centos 安装 puppeteer 启动失败解决处理</a></li>\n</ol>\n"},{"title":"记录工单系统的前端性能优化","catalog":true,"date":"2019-07-22T06:01:38.000Z","subtitle":null,"header-img":null,"_content":"\n","source":"_posts/记录工单系统的前端性能优化.md","raw":"---\ntitle: 记录工单系统的前端性能优化\ncatalog: true\ndate: 2019-07-22 14:01:38\nsubtitle:\nheader-img:\ntags: 前端\n---\n\n","slug":"记录工单系统的前端性能优化","published":1,"updated":"2019-07-23T01:57:31.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982x001jgu1p7x6l7u6c","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"记录平时jenkins使用遇到的问题","catalog":true,"date":"2019-05-21T05:51:07.000Z","subtitle":null,"header-img":null,"_content":"\n1. `gitlab`通过`webhooks`在项目指定的分支 push 之后触发 jekins 自动打包\n\n   - 在 jekins 安装 `gitlab-hook-plugin`和 `gitlab-plugin`插件，安装成功的话会在创建项目的`Build Triggers`构建地方看到一个选项 `Build when a change is pushed to GitLab. GitLab webhook URL`\n\n   ![WechatIMG1.png](https://upload-images.jianshu.io/upload_images/6655013-f765101312bb25b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照如下配置方式在`jekins`里指定`dev-hc`分支触发打包\n\n![WechatIMG2.jpeg](https://upload-images.jianshu.io/upload_images/6655013-16a3ba489550681e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在`gitlab`指定的项目设置`webhooks`，在项目的 url 写上`jekins`的项目 url 以及对应的`token`,完成之后保存下，按下对应的 Test 按钮可以测试下是否返回 200 状态码\n\n![WechatIMG3.png](https://upload-images.jianshu.io/upload_images/6655013-82715e7e25e1f667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![WechatIMG4.png](https://upload-images.jianshu.io/upload_images/6655013-4d8f7dcfa20e6b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. jekins 的时间不正确\n\n打开 【系统管理】->【脚本命令行】运行下面的命令\n\n```shell\nSystem.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')\n```\n\n如果是在 docker 下运行的 jenkins 的话，可能上述还不生效，需要切换到`/etc`目录下\n如果`timezone`\n\n3. jenkins 配置执行的 shell 对接构建参数\n\n比如构建参数有`job`，在 shell 里面对应的参数就为`$job`\n","source":"_posts/记录平时jenkins使用遇到的问题.md","raw":"---\ntitle: 记录平时jenkins使用遇到的问题\ncatalog: true\ndate: 2019-05-21 13:51:07\nsubtitle:\nheader-img:\ntags: jenkins\n---\n\n1. `gitlab`通过`webhooks`在项目指定的分支 push 之后触发 jekins 自动打包\n\n   - 在 jekins 安装 `gitlab-hook-plugin`和 `gitlab-plugin`插件，安装成功的话会在创建项目的`Build Triggers`构建地方看到一个选项 `Build when a change is pushed to GitLab. GitLab webhook URL`\n\n   ![WechatIMG1.png](https://upload-images.jianshu.io/upload_images/6655013-f765101312bb25b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照如下配置方式在`jekins`里指定`dev-hc`分支触发打包\n\n![WechatIMG2.jpeg](https://upload-images.jianshu.io/upload_images/6655013-16a3ba489550681e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在`gitlab`指定的项目设置`webhooks`，在项目的 url 写上`jekins`的项目 url 以及对应的`token`,完成之后保存下，按下对应的 Test 按钮可以测试下是否返回 200 状态码\n\n![WechatIMG3.png](https://upload-images.jianshu.io/upload_images/6655013-82715e7e25e1f667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![WechatIMG4.png](https://upload-images.jianshu.io/upload_images/6655013-4d8f7dcfa20e6b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. jekins 的时间不正确\n\n打开 【系统管理】->【脚本命令行】运行下面的命令\n\n```shell\nSystem.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')\n```\n\n如果是在 docker 下运行的 jenkins 的话，可能上述还不生效，需要切换到`/etc`目录下\n如果`timezone`\n\n3. jenkins 配置执行的 shell 对接构建参数\n\n比如构建参数有`job`，在 shell 里面对应的参数就为`$job`\n","slug":"记录平时jenkins使用遇到的问题","published":1,"updated":"2019-07-25T14:55:00.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982y001mgu1p5t57ugyx","content":"<ol>\n<li>\n<p><code>gitlab</code>通过<code>webhooks</code>在项目指定的分支 push 之后触发 jekins 自动打包</p>\n<ul>\n<li>在 jekins 安装 <code>gitlab-hook-plugin</code>和 <code>gitlab-plugin</code>插件，安装成功的话会在创建项目的<code>Build Triggers</code>构建地方看到一个选项 <code>Build when a change is pushed to GitLab. GitLab webhook URL</code></li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-f765101312bb25b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG1.png\"></p>\n</li>\n</ol>\n<p>按照如下配置方式在<code>jekins</code>里指定<code>dev-hc</code>分支触发打包</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-16a3ba489550681e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG2.jpeg\"></p>\n<p>在<code>gitlab</code>指定的项目设置<code>webhooks</code>，在项目的 url 写上<code>jekins</code>的项目 url 以及对应的<code>token</code>,完成之后保存下，按下对应的 Test 按钮可以测试下是否返回 200 状态码</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-82715e7e25e1f667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG3.png\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-4d8f7dcfa20e6b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG4.png\"></p>\n<ol start=\"2\">\n<li>jekins 的时间不正确</li>\n</ol>\n<p>打开 【系统管理】-&gt;【脚本命令行】运行下面的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')</span><br></pre></td></tr></table></figure>\n<p>如果是在 docker 下运行的 jenkins 的话，可能上述还不生效，需要切换到<code>/etc</code>目录下<br>\n如果<code>timezone</code></p>\n<ol start=\"3\">\n<li>jenkins 配置执行的 shell 对接构建参数</li>\n</ol>\n<p>比如构建参数有<code>job</code>，在 shell 里面对应的参数就为<code>$job</code></p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>\n<p><code>gitlab</code>通过<code>webhooks</code>在项目指定的分支 push 之后触发 jekins 自动打包</p>\n<ul>\n<li>在 jekins 安装 <code>gitlab-hook-plugin</code>和 <code>gitlab-plugin</code>插件，安装成功的话会在创建项目的<code>Build Triggers</code>构建地方看到一个选项 <code>Build when a change is pushed to GitLab. GitLab webhook URL</code></li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-f765101312bb25b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG1.png\"></p>\n</li>\n</ol>\n<p>按照如下配置方式在<code>jekins</code>里指定<code>dev-hc</code>分支触发打包</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-16a3ba489550681e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG2.jpeg\"></p>\n<p>在<code>gitlab</code>指定的项目设置<code>webhooks</code>，在项目的 url 写上<code>jekins</code>的项目 url 以及对应的<code>token</code>,完成之后保存下，按下对应的 Test 按钮可以测试下是否返回 200 状态码</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-82715e7e25e1f667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG3.png\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-4d8f7dcfa20e6b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WechatIMG4.png\"></p>\n<ol start=\"2\">\n<li>jekins 的时间不正确</li>\n</ol>\n<p>打开 【系统管理】-&gt;【脚本命令行】运行下面的命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')</span><br></pre></td></tr></table></figure>\n<p>如果是在 docker 下运行的 jenkins 的话，可能上述还不生效，需要切换到<code>/etc</code>目录下<br>\n如果<code>timezone</code></p>\n<ol start=\"3\">\n<li>jenkins 配置执行的 shell 对接构建参数</li>\n</ol>\n<p>比如构建参数有<code>job</code>，在 shell 里面对应的参数就为<code>$job</code></p>\n"},{"title":"利用verdaccio搭建私有npm仓库","catalog":true,"date":"2019-06-16T00:25:18.000Z","subtitle":null,"header-img":null,"_content":"\n随着时间的推移，前端的工程日益庞大，越来越复杂的依赖包需要包管理器来维护。相比搭建没有优势bower仓储，更好的方式是在局域网搭建NPM仓储，维护项目中package.json中的各个插件的版本即可维护项目依赖。\n\n[verdaccio]([https://github.com/verdaccio/verdaccio](https://github.com/verdaccio/verdaccio)\n)是一个部署简易的可以实现github仓储私有化的npm组件，fork于`sinopia`项目，由于`sinopia`项目现在不太维护，存在一些bug，不建议使用。\n\n使用verdaccio的优势\n\n- 配置简单，开箱即用；\n- 不需要数据库,verdaccio内置一个数据库了；\n- 当源为verdaccio时, verdaccio不存在要安装的包时,会自动去设置的远程npm把包缓存到本地；\n\n## 1. 安装verdaccio\n\n```javascript\nnpm i verdaccio -g\n```\n\n## 2. 启动verdaccio\n\n- 默认开启方式\n\n ```shell\nverdaccio\n```\n\n启动成功截图\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-ec7bd2397fb9d6bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中`config.yaml`是配置文件，相关配置文件说明如下\n\n```shell\nstorage: ./storage  //npm包存放的路径\n\nauth:\n  htpasswd:\n    file: ./htpasswd   //保存用户的账号密码等信息\n    # Maximum amount of users allowed to register, defaults to \"+inf\".\n    # You can set this to -1 to disable registration.\n    max_users: -1  //默认为1000，改为-1，禁止注册\n\n# a list of other known repositories we can talk to\nuplinks:\n  npmjs:\n    url: http://registry.npm.taobao.org/  //默认为npm的官网，由于国情，改为淘宝源\n\npackages:  //配置权限管理\n  '@*/*':\n    # scoped packages\n    access: $all\n    publish: $authenticated\n\n  '*':\n    # allow all users (including non-authenticated users) to read and\n    # publish all packages\n    #\n    # you can specify usernames/groupnames (depending on your auth plugin)\n    # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\"\n    access: $all  // 所有人都能下载\n\n    # allow all known users to publish packages\n    # (anyone can register by default, remember?)\n    publish: $authenticated // 所有人都有发布包的权限，若想指定默认发布改成对应人的名字\n\n    # if package is not available locally, proxy requests to 'npmjs' registry\n    proxy: npmjs  // 若安装的报在simopia没有，会去配置的npmjs地址去下载\n\n# log settings\nlogs:\n  - {type: stdout, format: pretty, level: http}\n  #- {type: file, path: verdaccio.log, level: info}\n\n# you can specify listen address (or simply a port)\nlisten: 0.0.0.0:4873  // 默认没有，只能在本机访问，添加后可以通过外网访问。\n```\n\n若在服务端部署，需要以守护进程的方式，推荐使用`pm2`去开启\n\n```shell\npm2 start `which verdaccio`\n```\n\npm2启动成功截图\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-dcf94831d7b96096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n## 如何使用\n\n 打开浏览器输入对应的暴露的地址，比如`192.168.0.1:4873`，\n\n截图如下\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-d6ae317646b0afc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照截图提示，注册一个用户\n\n```shell\nnpm adduser --registry http://192.168.0.1:4873\n```\n\n安装提示输入账号，密码\n\n## 更改下载源\n\n在每一个客户端中需要更改下载源为verdaccio，这里推荐使用`nrm`，这是一个包下载源管理器。\n\n```shell\nnpm install -g nrm\n\nnrm add verdaccio http://x.x.x.x:4873/\n\nnrm use verdaccio\n```\n\n## 维护\n\n如果需要发布一个包，需要先进行登录\n\n```shell\nnpm login\n```\n\n登录成功之后，在对应的包文件夹下，改好`package.json`版本号，再执行创建发布命令\n\n```shell\nnpm publish\n```\n","source":"_posts/利用verdaccio搭建私有npm仓库.md","raw":"---\ntitle: 利用verdaccio搭建私有npm仓库\ncatalog: true\ndate: 2019-06-16 08:25:18\nsubtitle: \nheader-img:\ntags: node\n---\n\n随着时间的推移，前端的工程日益庞大，越来越复杂的依赖包需要包管理器来维护。相比搭建没有优势bower仓储，更好的方式是在局域网搭建NPM仓储，维护项目中package.json中的各个插件的版本即可维护项目依赖。\n\n[verdaccio]([https://github.com/verdaccio/verdaccio](https://github.com/verdaccio/verdaccio)\n)是一个部署简易的可以实现github仓储私有化的npm组件，fork于`sinopia`项目，由于`sinopia`项目现在不太维护，存在一些bug，不建议使用。\n\n使用verdaccio的优势\n\n- 配置简单，开箱即用；\n- 不需要数据库,verdaccio内置一个数据库了；\n- 当源为verdaccio时, verdaccio不存在要安装的包时,会自动去设置的远程npm把包缓存到本地；\n\n## 1. 安装verdaccio\n\n```javascript\nnpm i verdaccio -g\n```\n\n## 2. 启动verdaccio\n\n- 默认开启方式\n\n ```shell\nverdaccio\n```\n\n启动成功截图\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-ec7bd2397fb9d6bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中`config.yaml`是配置文件，相关配置文件说明如下\n\n```shell\nstorage: ./storage  //npm包存放的路径\n\nauth:\n  htpasswd:\n    file: ./htpasswd   //保存用户的账号密码等信息\n    # Maximum amount of users allowed to register, defaults to \"+inf\".\n    # You can set this to -1 to disable registration.\n    max_users: -1  //默认为1000，改为-1，禁止注册\n\n# a list of other known repositories we can talk to\nuplinks:\n  npmjs:\n    url: http://registry.npm.taobao.org/  //默认为npm的官网，由于国情，改为淘宝源\n\npackages:  //配置权限管理\n  '@*/*':\n    # scoped packages\n    access: $all\n    publish: $authenticated\n\n  '*':\n    # allow all users (including non-authenticated users) to read and\n    # publish all packages\n    #\n    # you can specify usernames/groupnames (depending on your auth plugin)\n    # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\"\n    access: $all  // 所有人都能下载\n\n    # allow all known users to publish packages\n    # (anyone can register by default, remember?)\n    publish: $authenticated // 所有人都有发布包的权限，若想指定默认发布改成对应人的名字\n\n    # if package is not available locally, proxy requests to 'npmjs' registry\n    proxy: npmjs  // 若安装的报在simopia没有，会去配置的npmjs地址去下载\n\n# log settings\nlogs:\n  - {type: stdout, format: pretty, level: http}\n  #- {type: file, path: verdaccio.log, level: info}\n\n# you can specify listen address (or simply a port)\nlisten: 0.0.0.0:4873  // 默认没有，只能在本机访问，添加后可以通过外网访问。\n```\n\n若在服务端部署，需要以守护进程的方式，推荐使用`pm2`去开启\n\n```shell\npm2 start `which verdaccio`\n```\n\npm2启动成功截图\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-dcf94831d7b96096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n## 如何使用\n\n 打开浏览器输入对应的暴露的地址，比如`192.168.0.1:4873`，\n\n截图如下\n\n![image.png](https://upload-images.jianshu.io/upload_images/6655013-d6ae317646b0afc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照截图提示，注册一个用户\n\n```shell\nnpm adduser --registry http://192.168.0.1:4873\n```\n\n安装提示输入账号，密码\n\n## 更改下载源\n\n在每一个客户端中需要更改下载源为verdaccio，这里推荐使用`nrm`，这是一个包下载源管理器。\n\n```shell\nnpm install -g nrm\n\nnrm add verdaccio http://x.x.x.x:4873/\n\nnrm use verdaccio\n```\n\n## 维护\n\n如果需要发布一个包，需要先进行登录\n\n```shell\nnpm login\n```\n\n登录成功之后，在对应的包文件夹下，改好`package.json`版本号，再执行创建发布命令\n\n```shell\nnpm publish\n```\n","slug":"利用verdaccio搭建私有npm仓库","published":1,"updated":"2019-07-23T01:57:31.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556982z001ogu1ptnh9vjgl","content":"<p>随着时间的推移，前端的工程日益庞大，越来越复杂的依赖包需要包管理器来维护。相比搭建没有优势bower仓储，更好的方式是在局域网搭建NPM仓储，维护项目中package.json中的各个插件的版本即可维护项目依赖。</p>\n<p><a href=\"%5Bhttps://github.com/verdaccio/verdaccio%5D(https://github.com/verdaccio/verdaccio)\">verdaccio</a>是一个部署简易的可以实现github仓储私有化的npm组件，fork于<code>sinopia</code>项目，由于<code>sinopia</code>项目现在不太维护，存在一些bug，不建议使用。</p>\n<p>使用verdaccio的优势</p>\n<ul>\n<li>配置简单，开箱即用；</li>\n<li>不需要数据库,verdaccio内置一个数据库了；</li>\n<li>当源为verdaccio时, verdaccio不存在要安装的包时,会自动去设置的远程npm把包缓存到本地；</li>\n</ul>\n<h2><span id=\"1-安装verdaccio\">1. 安装verdaccio</span></h2>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i verdaccio -g</span><br></pre></td></tr></table></figure>\n<h2><span id=\"2-启动verdaccio\">2. 启动verdaccio</span></h2>\n<ul>\n<li>默认开启方式</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">verdaccio</span><br></pre></td></tr></table></figure>\n<p>启动成功截图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-ec7bd2397fb9d6bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>其中<code>config.yaml</code>是配置文件，相关配置文件说明如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storage: ./storage  //npm包存放的路径</span><br><span class=\"line\"></span><br><span class=\"line\">auth:</span><br><span class=\"line\">  htpasswd:</span><br><span class=\"line\">    file: ./htpasswd   //保存用户的账号密码等信息</span><br><span class=\"line\">    # Maximum amount of users allowed to register, defaults to \"+inf\".</span><br><span class=\"line\">    # You can set this to -1 to disable registration.</span><br><span class=\"line\">    max_users: -1  //默认为1000，改为-1，禁止注册</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> a list of other known repositories we can talk to</span><br><span class=\"line\">uplinks:</span><br><span class=\"line\">  npmjs:</span><br><span class=\"line\">    url: http://registry.npm.taobao.org/  //默认为npm的官网，由于国情，改为淘宝源</span><br><span class=\"line\"></span><br><span class=\"line\">packages:  //配置权限管理</span><br><span class=\"line\">  '@*/*':</span><br><span class=\"line\">    # scoped packages</span><br><span class=\"line\">    access: $all</span><br><span class=\"line\">    publish: $authenticated</span><br><span class=\"line\"></span><br><span class=\"line\">  '*':</span><br><span class=\"line\">    # allow all users (including non-authenticated users) to read and</span><br><span class=\"line\">    # publish all packages</span><br><span class=\"line\">    #</span><br><span class=\"line\">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class=\"line\">    # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\"</span><br><span class=\"line\">    access: $all  // 所有人都能下载</span><br><span class=\"line\"></span><br><span class=\"line\">    # allow all known users to publish packages</span><br><span class=\"line\">    # (anyone can register by default, remember?)</span><br><span class=\"line\">    publish: $authenticated // 所有人都有发布包的权限，若想指定默认发布改成对应人的名字</span><br><span class=\"line\"></span><br><span class=\"line\">    # if package is not available locally, proxy requests to 'npmjs' registry</span><br><span class=\"line\">    proxy: npmjs  // 若安装的报在simopia没有，会去配置的npmjs地址去下载</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> log settings</span><br><span class=\"line\">logs:</span><br><span class=\"line\">  - &#123;type: stdout, format: pretty, level: http&#125;</span><br><span class=\"line\"><span class=\"meta\">  #</span>- &#123;type: file, path: verdaccio.log, level: info&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> you can specify listen address (or simply a port)</span><br><span class=\"line\">listen: 0.0.0.0:4873  // 默认没有，只能在本机访问，添加后可以通过外网访问。</span><br></pre></td></tr></table></figure>\n<p>若在服务端部署，需要以守护进程的方式，推荐使用<code>pm2</code>去开启</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start `which verdaccio`</span><br></pre></td></tr></table></figure>\n<p>pm2启动成功截图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-dcf94831d7b96096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<hr>\n<h2><span id=\"如何使用\">如何使用</span></h2>\n<p>打开浏览器输入对应的暴露的地址，比如<code>192.168.0.1:4873</code>，</p>\n<p>截图如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-d6ae317646b0afc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>按照截图提示，注册一个用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm adduser --registry http://192.168.0.1:4873</span><br></pre></td></tr></table></figure>\n<p>安装提示输入账号，密码</p>\n<h2><span id=\"更改下载源\">更改下载源</span></h2>\n<p>在每一个客户端中需要更改下载源为verdaccio，这里推荐使用<code>nrm</code>，这是一个包下载源管理器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g nrm</span><br><span class=\"line\"></span><br><span class=\"line\">nrm add verdaccio http://x.x.x.x:4873/</span><br><span class=\"line\"></span><br><span class=\"line\">nrm use verdaccio</span><br></pre></td></tr></table></figure>\n<h2><span id=\"维护\">维护</span></h2>\n<p>如果需要发布一个包，需要先进行登录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm login</span><br></pre></td></tr></table></figure>\n<p>登录成功之后，在对应的包文件夹下，改好<code>package.json</code>版本号，再执行创建发布命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>随着时间的推移，前端的工程日益庞大，越来越复杂的依赖包需要包管理器来维护。相比搭建没有优势bower仓储，更好的方式是在局域网搭建NPM仓储，维护项目中package.json中的各个插件的版本即可维护项目依赖。</p>\n<p><a href=\"%5Bhttps://github.com/verdaccio/verdaccio%5D(https://github.com/verdaccio/verdaccio)\">verdaccio</a>是一个部署简易的可以实现github仓储私有化的npm组件，fork于<code>sinopia</code>项目，由于<code>sinopia</code>项目现在不太维护，存在一些bug，不建议使用。</p>\n<p>使用verdaccio的优势</p>\n<ul>\n<li>配置简单，开箱即用；</li>\n<li>不需要数据库,verdaccio内置一个数据库了；</li>\n<li>当源为verdaccio时, verdaccio不存在要安装的包时,会自动去设置的远程npm把包缓存到本地；</li>\n</ul>\n<h2>1. 安装verdaccio</h2>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i verdaccio -g</span><br></pre></td></tr></table></figure>\n<h2>2. 启动verdaccio</h2>\n<ul>\n<li>默认开启方式</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">verdaccio</span><br></pre></td></tr></table></figure>\n<p>启动成功截图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-ec7bd2397fb9d6bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>其中<code>config.yaml</code>是配置文件，相关配置文件说明如下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">storage: ./storage  //npm包存放的路径</span><br><span class=\"line\"></span><br><span class=\"line\">auth:</span><br><span class=\"line\">  htpasswd:</span><br><span class=\"line\">    file: ./htpasswd   //保存用户的账号密码等信息</span><br><span class=\"line\">    # Maximum amount of users allowed to register, defaults to \"+inf\".</span><br><span class=\"line\">    # You can set this to -1 to disable registration.</span><br><span class=\"line\">    max_users: -1  //默认为1000，改为-1，禁止注册</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> a list of other known repositories we can talk to</span><br><span class=\"line\">uplinks:</span><br><span class=\"line\">  npmjs:</span><br><span class=\"line\">    url: http://registry.npm.taobao.org/  //默认为npm的官网，由于国情，改为淘宝源</span><br><span class=\"line\"></span><br><span class=\"line\">packages:  //配置权限管理</span><br><span class=\"line\">  '@*/*':</span><br><span class=\"line\">    # scoped packages</span><br><span class=\"line\">    access: $all</span><br><span class=\"line\">    publish: $authenticated</span><br><span class=\"line\"></span><br><span class=\"line\">  '*':</span><br><span class=\"line\">    # allow all users (including non-authenticated users) to read and</span><br><span class=\"line\">    # publish all packages</span><br><span class=\"line\">    #</span><br><span class=\"line\">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class=\"line\">    # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\"</span><br><span class=\"line\">    access: $all  // 所有人都能下载</span><br><span class=\"line\"></span><br><span class=\"line\">    # allow all known users to publish packages</span><br><span class=\"line\">    # (anyone can register by default, remember?)</span><br><span class=\"line\">    publish: $authenticated // 所有人都有发布包的权限，若想指定默认发布改成对应人的名字</span><br><span class=\"line\"></span><br><span class=\"line\">    # if package is not available locally, proxy requests to 'npmjs' registry</span><br><span class=\"line\">    proxy: npmjs  // 若安装的报在simopia没有，会去配置的npmjs地址去下载</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> log settings</span><br><span class=\"line\">logs:</span><br><span class=\"line\">  - &#123;type: stdout, format: pretty, level: http&#125;</span><br><span class=\"line\"><span class=\"meta\">  #</span>- &#123;type: file, path: verdaccio.log, level: info&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> you can specify listen address (or simply a port)</span><br><span class=\"line\">listen: 0.0.0.0:4873  // 默认没有，只能在本机访问，添加后可以通过外网访问。</span><br></pre></td></tr></table></figure>\n<p>若在服务端部署，需要以守护进程的方式，推荐使用<code>pm2</code>去开启</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start `which verdaccio`</span><br></pre></td></tr></table></figure>\n<p>pm2启动成功截图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-dcf94831d7b96096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<hr>\n<h2>如何使用</h2>\n<p>打开浏览器输入对应的暴露的地址，比如<code>192.168.0.1:4873</code>，</p>\n<p>截图如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/6655013-d6ae317646b0afc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>按照截图提示，注册一个用户</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm adduser --registry http://192.168.0.1:4873</span><br></pre></td></tr></table></figure>\n<p>安装提示输入账号，密码</p>\n<h2>更改下载源</h2>\n<p>在每一个客户端中需要更改下载源为verdaccio，这里推荐使用<code>nrm</code>，这是一个包下载源管理器。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g nrm</span><br><span class=\"line\"></span><br><span class=\"line\">nrm add verdaccio http://x.x.x.x:4873/</span><br><span class=\"line\"></span><br><span class=\"line\">nrm use verdaccio</span><br></pre></td></tr></table></figure>\n<h2>维护</h2>\n<p>如果需要发布一个包，需要先进行登录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm login</span><br></pre></td></tr></table></figure>\n<p>登录成功之后，在对应的包文件夹下，改好<code>package.json</code>版本号，再执行创建发布命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure>\n"},{"title":"nginx入门","catalog":true,"date":"2019-06-19T05:34:23.000Z","subtitle":null,"header-img":null,"_content":"\n1. 环境\n\n   CENTOS>=7.0,位数 X64 CENTOS 7.2\n\n2. 关闭 iptables\n\n   iptables 命令是 Linux 上常用的防火墙软件\n\n   | 功能           | 命令                                |\n   | :------------- | :---------------------------------- |\n   | 停止防火墙     | systemctl stop firewalld.service    |\n   | 永久关闭防火墙 | systemctl disable firewalld.service |\n\n3. 安装依赖\n\n   ```shell\n   yum  -y install gcc gcc-c++ autoconf pcre pcre-devel make automake\n   yum  -y install wget httpd-tools vim\n   ```\n\n4. 开始安装 nginx\n\n   新建一个文件\n\n   ```shell\n   vi /etc/yum.repos.d/nginx.repo\n   ```\n\n   内容输入如下：\n\n   ```shell\n   [nginx]\n   name=nginx repo\n   baseurl=http://nginx.org/packages/centos/7/$basearch/\n   gpgcheck=0\n   enabled=1\n   ```\n\n   其中 centos/7 根据自己运行环境配置 系统名/版本号\n\n   下载 nginx\n\n   ```shell\n   yum install nginx -y\n   nginx -v\n   nginx -V\n   ```\n\n---\n\n## nginx 常用操作\n\n1. 查看配置文件和目录\n\n   ```shell\n   rpm -ql nginx\n   ```\n\n   相关文件说明：\n\n   | 类型     | 路径                                                                                                                              | 用途                                           |\n   | :------- | :-------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------- |\n   | 配置文件 | /etc/logrotate.d/nginx                                                                                                            | 用于 logrotate 服务的日志切割                  |\n   | 配置文件 | /etc/nginx /etc/nginx/nginx.conf /etc/nginx/conf.d /etc/nginx/conf.d/default.conf                                                 | 主配置文件                                     |\n   | 配置文件 | /etc/nginx/fastcgi_params /etc/nginx/scgi_params /etc/nginx/uwsgi_params                                                          | cgi 配置,fastcgi 配置                          |\n   | 配置文件 | /etc/nginx/koi-utf /etc/nginx/koi-win /etc/nginx/win-utf                                                                          | 编码转换映射转化文件                           |\n   | 配置文件 | /etc/nginx/mime.types                                                                                                             | 设置 http 协议的 Content-Type 与扩展名对应关系 |\n   | 配置文件 | /usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug | 用于配置系统守护进程管理器管理方式             |\n   | 配置文件 | /etc/nginx/modules /usr/lib64/nginx/modules                                                                                       | nginx 模块目录                                 |\n   | 命令     | /usr/share/doc/nginx-1.14.0 /usr/share/doc/nginx-1.14.0/COPYRIGHT                                                                 | nginx 的手册和帮助文件                         |\n   | 目录     | /var/cache/nginx                                                                                                                  | nginx 的缓存目录                               |\n   | 目录     | /var/log/nginx                                                                                                                    | nginx 的日志目录                               |\n\n2. 启动和重新加载以及关闭\n\n   ```shell\n   systemctl restart nginx.service\n   systemctl reload nginx.service\n   systemctl stop nginx.service\n\n   nginx -s reload\n   ```\n\n   如果在启动的时候可能会遇到下列问题：\n\n   1. 端口被占用；\n\n   ```shell\n   Starting nginx: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] still could not bind\n\n   ```\n\n   可以先查看进程，再杀死对应进程\n\n   ```shell\n   netstat -ntpl\n\n   kill 进程号\n   ```\n\n3. 配置 nginx\n\n> /etc/nginx/nginx.conf\n\n查看日志命令 tailf -f log 目录\n\n```shell\n  user  nginx;   设置nginx服务的系统使用用户\n  worker_processes  1;  工作进程数,一般和CPU数量相同\n\n  error_log  /var/log/nginx/error.log warn;   nginx的错误日志\n  pid        /var/run/nginx.pid;   nginx服务启动时的pid\n\n  events {\n      worker_connections  1024;每个进程允许的最大连接数 10000\n  }\n\n  http {\n      include       /etc/nginx/mime.types;//文件后缀和类型类型的对应关系\n      default_type  application/octet-stream;//默认content-type\n\n      log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';  //日志记录格式\n\n      access_log  /var/log/nginx/access.log  main;//默认访问日志 日志格式与log_format main 对应\n\n      sendfile        on;//启用sendfile\n      #tcp_nopush     on;//懒发送 客户端请求数据不会每次都时时相应 让数据塞满一次性发送给客户端（多用于下载、断点 续传）\n      #tcp_nodelay on; // 默认开启 与nopush互斥 提高实时请求响应效率\n\n      keepalive_timeout  65;//超时时间是65秒\n\n      #gzip  on;gzip压缩\n\n      include /etc/nginx/conf.d/*.conf;//包含的子配置文件\n  }\n```\n\n> /etc/default.conf\n\n```shell\n  server {\n      listen       80;\n      # 用域名方式访问的地址\n      server_name  localhost;\n\n      #charset koi8-r; //编码\n      #access_log  /var/log/nginx/host.access.log  main;  //访问日志文件和名称\n\n      # 代理http协议请求\n      location /api {\n          proxy_pass http://localhost:3000;\n      }\n\n      # 代理ws协议请求\n      location /ws {\n        proxy_pass http://localhost:3000;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection ‘Upgrade‘;\n      }\n\n\n\n        # 代理/api/路径的请求 并去掉/api/路径进行转发\n        location ~ /api/ {\n            rewrite /api/(.*)$ /$1 break;\n            proxy_pass  http://www.baidu.com;\n        }\n\n        location ~ / {\n            root /data/www-data/bolton/;\n            try_files $uri $uri/ /index.html;\n            index index.html;\n        }\n\n\n\n\n\n\n\n      # 转发请求静态资源（js、css）规则\n      location ~ .*\\.(html|js|css)$ {\n          # CORS\n          add_header Access-Control-Allow-Origin *;\n          add_header Access-Control-Allow-Methods GET,POST,DELETE;\n          add_header Access-Control-Allow-Headers Content-Type;\n          # 默认带上客户端cookie\n          add_header Access-Control-Allow-Credentials true;\n          # 缓存1h\n          expires 1h;\n          # 开启gzip\n          gzip on;\n          # gzip压缩HTTP版本号 一般是1.1\n          gzip_http_version 1.1;\n          # gzip压缩等级 越大压缩率越高 1-9\n          gzip_comp_level 2;\n          # 默认不指定不会缓存css资源 需要指定text/css类型\n          gzip_types application/javascript text/css;\n          # 资源目录\n          root /data/html;\n      }\n\n      # 设置图片请求规则\n      location ~ .*\\.(gif|png|jpg|webp)$ {\n          expires 1h;\n          gzip on;\n          gzip_http_version 1.1;\n          gzip_comp_level 3;\n          gzip_types image/jpeg image/png image/gif image/webp;\n          ## 防盗链\n          ## valid_referers 合法的域名 *.baidu.com\n          ## <meta name=\"referrer\" content=\"never\">\n          valid_referers none blocked xx.xxx.xxx.xx;\n          if ($invalid_referer) {\n              return 403;\n          }\n          # 资源目录\n          root /data/html;\n      }\n\n      location ~ ^/download {\n          # 默认先查找当前目录下的后缀为.gz文件 有直接返回给客户端 不需要再压缩\n          # linux下运行gzip 文件名会生成压缩gz文件\n          # url最直接访问该文件路径就会自动启动下载该资源\n          gzip_static on;\n          tcp_nopush on;\n          root /data/download;\n      }\n\n      location / {\n          root   /usr/share/nginx/html;  //静态文件根目录\n          index  index.html index.htm;  //首页的索引文件\n      }\n\n      #error_page  404              /404.html;  //指定错误页面\n\n      # redirect server error pages to the static page /50x.html\n      # 把后台错误重定向到静态的50x.html页面\n      error_page   500 502 503 504  /50x.html;\n      location = /50x.html {\n          root   /usr/share/nginx/html;\n      }\n\n      # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n      # 把PHP脚本9000端口上监听的FastCGI服务\n      #location ~ \\.php$ {\n      #    root           html;\n      #    fastcgi_pass   127.0.0.1:9000;\n      #    fastcgi_index  index.php;\n      #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n      #    include        fastcgi_params;\n      #}\n\n      # 不允许访问.htaccess文件 只允许指定的ip访问\n      location ~ /\\.ht {\n          allow 127.0.0.1\n          deny  all;\n      }\n  }\n```\n\n> 实现负载均衡\n\n1. 解决高并发、海量数据问题\n2. 配置类型\n\n   1. 轮询（默认） 每个请求按照时间顺序逐一分配不同的后端服务器；\n   2. ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定放一个后端服务器，可以解决 session 的问题；\n   3. weight（加权轮询）指定轮询策略，weight 和访问比率成正比，用于后端服务器性能不均的情况；\n   4. least_conn 最小连接数，哪个连接少就分给谁。\n\n   集群状态：\n\n| 状态         | 描述                                  |\n| :----------- | :------------------------------------ |\n| down         | 不参与负载均衡                        |\n| backup       | 备份的服务器                          |\n| max_fails    | 允许请求失败的次数                    |\n| fail_timeout | 经过 max_fails 失败后，服务暂停的时间 |\n| max_conts    | 限制最大的接收的连接数                |\n\n```shell\n    upstream test1 {\n        ip_hsah;\n        server http://localhost:3000 weight=2;\n        server http://localhost:4000 weight=1;\n        server http://localhost:5000 down;\n    }\n\n    server {\n        # 访问负载均衡构造的集群\n        location / {\n            # 和upstrem的name对应\n            proxy_pass http://test1;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test1.com;\n        location / {\n            proxy_pass http://localhost:3000;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test2.com;\n        location / {\n            proxy_pass http://localhost:4000;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test3.com;\n        location / {\n            proxy_pass http://localhost:5000;\n        }\n    }\n\n```\n\n此时访问`www.test.com`通过代理到访问`www.test1.com`，而访问 test1 的请求被负载均衡按照策略访问 test1 或者 test2\n","source":"_posts/nginx入门.md","raw":"---\ntitle: nginx入门\ncatalog: true\ndate: 2019-06-19 13:34:23\nsubtitle:\nheader-img:\ntags: nginx\n---\n\n1. 环境\n\n   CENTOS>=7.0,位数 X64 CENTOS 7.2\n\n2. 关闭 iptables\n\n   iptables 命令是 Linux 上常用的防火墙软件\n\n   | 功能           | 命令                                |\n   | :------------- | :---------------------------------- |\n   | 停止防火墙     | systemctl stop firewalld.service    |\n   | 永久关闭防火墙 | systemctl disable firewalld.service |\n\n3. 安装依赖\n\n   ```shell\n   yum  -y install gcc gcc-c++ autoconf pcre pcre-devel make automake\n   yum  -y install wget httpd-tools vim\n   ```\n\n4. 开始安装 nginx\n\n   新建一个文件\n\n   ```shell\n   vi /etc/yum.repos.d/nginx.repo\n   ```\n\n   内容输入如下：\n\n   ```shell\n   [nginx]\n   name=nginx repo\n   baseurl=http://nginx.org/packages/centos/7/$basearch/\n   gpgcheck=0\n   enabled=1\n   ```\n\n   其中 centos/7 根据自己运行环境配置 系统名/版本号\n\n   下载 nginx\n\n   ```shell\n   yum install nginx -y\n   nginx -v\n   nginx -V\n   ```\n\n---\n\n## nginx 常用操作\n\n1. 查看配置文件和目录\n\n   ```shell\n   rpm -ql nginx\n   ```\n\n   相关文件说明：\n\n   | 类型     | 路径                                                                                                                              | 用途                                           |\n   | :------- | :-------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------- |\n   | 配置文件 | /etc/logrotate.d/nginx                                                                                                            | 用于 logrotate 服务的日志切割                  |\n   | 配置文件 | /etc/nginx /etc/nginx/nginx.conf /etc/nginx/conf.d /etc/nginx/conf.d/default.conf                                                 | 主配置文件                                     |\n   | 配置文件 | /etc/nginx/fastcgi_params /etc/nginx/scgi_params /etc/nginx/uwsgi_params                                                          | cgi 配置,fastcgi 配置                          |\n   | 配置文件 | /etc/nginx/koi-utf /etc/nginx/koi-win /etc/nginx/win-utf                                                                          | 编码转换映射转化文件                           |\n   | 配置文件 | /etc/nginx/mime.types                                                                                                             | 设置 http 协议的 Content-Type 与扩展名对应关系 |\n   | 配置文件 | /usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug | 用于配置系统守护进程管理器管理方式             |\n   | 配置文件 | /etc/nginx/modules /usr/lib64/nginx/modules                                                                                       | nginx 模块目录                                 |\n   | 命令     | /usr/share/doc/nginx-1.14.0 /usr/share/doc/nginx-1.14.0/COPYRIGHT                                                                 | nginx 的手册和帮助文件                         |\n   | 目录     | /var/cache/nginx                                                                                                                  | nginx 的缓存目录                               |\n   | 目录     | /var/log/nginx                                                                                                                    | nginx 的日志目录                               |\n\n2. 启动和重新加载以及关闭\n\n   ```shell\n   systemctl restart nginx.service\n   systemctl reload nginx.service\n   systemctl stop nginx.service\n\n   nginx -s reload\n   ```\n\n   如果在启动的时候可能会遇到下列问题：\n\n   1. 端口被占用；\n\n   ```shell\n   Starting nginx: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)\n   nginx: [emerg] still could not bind\n\n   ```\n\n   可以先查看进程，再杀死对应进程\n\n   ```shell\n   netstat -ntpl\n\n   kill 进程号\n   ```\n\n3. 配置 nginx\n\n> /etc/nginx/nginx.conf\n\n查看日志命令 tailf -f log 目录\n\n```shell\n  user  nginx;   设置nginx服务的系统使用用户\n  worker_processes  1;  工作进程数,一般和CPU数量相同\n\n  error_log  /var/log/nginx/error.log warn;   nginx的错误日志\n  pid        /var/run/nginx.pid;   nginx服务启动时的pid\n\n  events {\n      worker_connections  1024;每个进程允许的最大连接数 10000\n  }\n\n  http {\n      include       /etc/nginx/mime.types;//文件后缀和类型类型的对应关系\n      default_type  application/octet-stream;//默认content-type\n\n      log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';  //日志记录格式\n\n      access_log  /var/log/nginx/access.log  main;//默认访问日志 日志格式与log_format main 对应\n\n      sendfile        on;//启用sendfile\n      #tcp_nopush     on;//懒发送 客户端请求数据不会每次都时时相应 让数据塞满一次性发送给客户端（多用于下载、断点 续传）\n      #tcp_nodelay on; // 默认开启 与nopush互斥 提高实时请求响应效率\n\n      keepalive_timeout  65;//超时时间是65秒\n\n      #gzip  on;gzip压缩\n\n      include /etc/nginx/conf.d/*.conf;//包含的子配置文件\n  }\n```\n\n> /etc/default.conf\n\n```shell\n  server {\n      listen       80;\n      # 用域名方式访问的地址\n      server_name  localhost;\n\n      #charset koi8-r; //编码\n      #access_log  /var/log/nginx/host.access.log  main;  //访问日志文件和名称\n\n      # 代理http协议请求\n      location /api {\n          proxy_pass http://localhost:3000;\n      }\n\n      # 代理ws协议请求\n      location /ws {\n        proxy_pass http://localhost:3000;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection ‘Upgrade‘;\n      }\n\n\n\n        # 代理/api/路径的请求 并去掉/api/路径进行转发\n        location ~ /api/ {\n            rewrite /api/(.*)$ /$1 break;\n            proxy_pass  http://www.baidu.com;\n        }\n\n        location ~ / {\n            root /data/www-data/bolton/;\n            try_files $uri $uri/ /index.html;\n            index index.html;\n        }\n\n\n\n\n\n\n\n      # 转发请求静态资源（js、css）规则\n      location ~ .*\\.(html|js|css)$ {\n          # CORS\n          add_header Access-Control-Allow-Origin *;\n          add_header Access-Control-Allow-Methods GET,POST,DELETE;\n          add_header Access-Control-Allow-Headers Content-Type;\n          # 默认带上客户端cookie\n          add_header Access-Control-Allow-Credentials true;\n          # 缓存1h\n          expires 1h;\n          # 开启gzip\n          gzip on;\n          # gzip压缩HTTP版本号 一般是1.1\n          gzip_http_version 1.1;\n          # gzip压缩等级 越大压缩率越高 1-9\n          gzip_comp_level 2;\n          # 默认不指定不会缓存css资源 需要指定text/css类型\n          gzip_types application/javascript text/css;\n          # 资源目录\n          root /data/html;\n      }\n\n      # 设置图片请求规则\n      location ~ .*\\.(gif|png|jpg|webp)$ {\n          expires 1h;\n          gzip on;\n          gzip_http_version 1.1;\n          gzip_comp_level 3;\n          gzip_types image/jpeg image/png image/gif image/webp;\n          ## 防盗链\n          ## valid_referers 合法的域名 *.baidu.com\n          ## <meta name=\"referrer\" content=\"never\">\n          valid_referers none blocked xx.xxx.xxx.xx;\n          if ($invalid_referer) {\n              return 403;\n          }\n          # 资源目录\n          root /data/html;\n      }\n\n      location ~ ^/download {\n          # 默认先查找当前目录下的后缀为.gz文件 有直接返回给客户端 不需要再压缩\n          # linux下运行gzip 文件名会生成压缩gz文件\n          # url最直接访问该文件路径就会自动启动下载该资源\n          gzip_static on;\n          tcp_nopush on;\n          root /data/download;\n      }\n\n      location / {\n          root   /usr/share/nginx/html;  //静态文件根目录\n          index  index.html index.htm;  //首页的索引文件\n      }\n\n      #error_page  404              /404.html;  //指定错误页面\n\n      # redirect server error pages to the static page /50x.html\n      # 把后台错误重定向到静态的50x.html页面\n      error_page   500 502 503 504  /50x.html;\n      location = /50x.html {\n          root   /usr/share/nginx/html;\n      }\n\n      # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n      # 把PHP脚本9000端口上监听的FastCGI服务\n      #location ~ \\.php$ {\n      #    root           html;\n      #    fastcgi_pass   127.0.0.1:9000;\n      #    fastcgi_index  index.php;\n      #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n      #    include        fastcgi_params;\n      #}\n\n      # 不允许访问.htaccess文件 只允许指定的ip访问\n      location ~ /\\.ht {\n          allow 127.0.0.1\n          deny  all;\n      }\n  }\n```\n\n> 实现负载均衡\n\n1. 解决高并发、海量数据问题\n2. 配置类型\n\n   1. 轮询（默认） 每个请求按照时间顺序逐一分配不同的后端服务器；\n   2. ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定放一个后端服务器，可以解决 session 的问题；\n   3. weight（加权轮询）指定轮询策略，weight 和访问比率成正比，用于后端服务器性能不均的情况；\n   4. least_conn 最小连接数，哪个连接少就分给谁。\n\n   集群状态：\n\n| 状态         | 描述                                  |\n| :----------- | :------------------------------------ |\n| down         | 不参与负载均衡                        |\n| backup       | 备份的服务器                          |\n| max_fails    | 允许请求失败的次数                    |\n| fail_timeout | 经过 max_fails 失败后，服务暂停的时间 |\n| max_conts    | 限制最大的接收的连接数                |\n\n```shell\n    upstream test1 {\n        ip_hsah;\n        server http://localhost:3000 weight=2;\n        server http://localhost:4000 weight=1;\n        server http://localhost:5000 down;\n    }\n\n    server {\n        # 访问负载均衡构造的集群\n        location / {\n            # 和upstrem的name对应\n            proxy_pass http://test1;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test1.com;\n        location / {\n            proxy_pass http://localhost:3000;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test2.com;\n        location / {\n            proxy_pass http://localhost:4000;\n        }\n    }\n    server {\n        listen 80;\n        server_name www.test3.com;\n        location / {\n            proxy_pass http://localhost:5000;\n        }\n    }\n\n```\n\n此时访问`www.test.com`通过代理到访问`www.test1.com`，而访问 test1 的请求被负载均衡按照策略访问 test1 或者 test2\n","slug":"nginx入门","published":1,"updated":"2019-11-29T01:46:17.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556983g0024gu1pmgj9ffyt","content":"<ol>\n<li>\n<p>环境</p>\n<p>CENTOS&gt;=7.0,位数 X64 CENTOS 7.2</p>\n</li>\n<li>\n<p>关闭 iptables</p>\n<p>iptables 命令是 Linux 上常用的防火墙软件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">功能</th>\n<th style=\"text-align:left\">命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">停止防火墙</td>\n<td style=\"text-align:left\">systemctl stop firewalld.service</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">永久关闭防火墙</td>\n<td style=\"text-align:left\">systemctl disable firewalld.service</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>安装依赖</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum  -y install gcc gcc-c++ autoconf pcre pcre-devel make automake</span><br><span class=\"line\">yum  -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>开始安装 nginx</p>\n<p>新建一个文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure>\n<p>内容输入如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[nginx]</span><br><span class=\"line\">name=nginx repo</span><br><span class=\"line\">baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">enabled=1</span><br></pre></td></tr></table></figure>\n<p>其中 centos/7 根据自己运行环境配置 系统名/版本号</p>\n<p>下载 nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install nginx -y</span><br><span class=\"line\">nginx -v</span><br><span class=\"line\">nginx -V</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2><span id=\"nginx-常用操作\">nginx 常用操作</span></h2>\n<ol>\n<li>\n<p>查看配置文件和目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ql nginx</span><br></pre></td></tr></table></figure>\n<p>相关文件说明：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">路径</th>\n<th style=\"text-align:left\">用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/logrotate.d/nginx</td>\n<td style=\"text-align:left\">用于 logrotate 服务的日志切割</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx /etc/nginx/nginx.conf /etc/nginx/conf.d /etc/nginx/conf.d/default.conf</td>\n<td style=\"text-align:left\">主配置文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/fastcgi_params /etc/nginx/scgi_params /etc/nginx/uwsgi_params</td>\n<td style=\"text-align:left\">cgi 配置,fastcgi 配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/koi-utf /etc/nginx/koi-win /etc/nginx/win-utf</td>\n<td style=\"text-align:left\">编码转换映射转化文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/mime.types</td>\n<td style=\"text-align:left\">设置 http 协议的 Content-Type 与扩展名对应关系</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug</td>\n<td style=\"text-align:left\">用于配置系统守护进程管理器管理方式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/modules /usr/lib64/nginx/modules</td>\n<td style=\"text-align:left\">nginx 模块目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">命令</td>\n<td style=\"text-align:left\">/usr/share/doc/nginx-1.14.0 /usr/share/doc/nginx-1.14.0/COPYRIGHT</td>\n<td style=\"text-align:left\">nginx 的手册和帮助文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目录</td>\n<td style=\"text-align:left\">/var/cache/nginx</td>\n<td style=\"text-align:left\">nginx 的缓存目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目录</td>\n<td style=\"text-align:left\">/var/log/nginx</td>\n<td style=\"text-align:left\">nginx 的日志目录</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>启动和重新加载以及关闭</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx.service</span><br><span class=\"line\">systemctl reload nginx.service</span><br><span class=\"line\">systemctl stop nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>如果在启动的时候可能会遇到下列问题：</p>\n<ol>\n<li>端口被占用；</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting nginx: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\"></span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] still could not bind</span><br></pre></td></tr></table></figure>\n<p>可以先查看进程，再杀死对应进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntpl</span><br><span class=\"line\"></span><br><span class=\"line\">kill 进程号</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>配置 nginx</p>\n</li>\n</ol>\n<blockquote>\n<p>/etc/nginx/nginx.conf</p>\n</blockquote>\n<p>查看日志命令 tailf -f log 目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user  nginx;   设置nginx服务的系统使用用户</span><br><span class=\"line\">worker_processes  1;  工作进程数,一般和CPU数量相同</span><br><span class=\"line\"></span><br><span class=\"line\">error_log  /var/log/nginx/error.log warn;   nginx的错误日志</span><br><span class=\"line\">pid        /var/run/nginx.pid;   nginx服务启动时的pid</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;每个进程允许的最大连接数 10000</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       /etc/nginx/mime.types;//文件后缀和类型类型的对应关系</span><br><span class=\"line\">    default_type  application/octet-stream;//默认content-type</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '</span><br><span class=\"line\">                    '$status $body_bytes_sent \"$http_referer\" '</span><br><span class=\"line\">                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';  //日志记录格式</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;//默认访问日志 日志格式与log_format main 对应</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;//启用sendfile</span><br><span class=\"line\">    #tcp_nopush     on;//懒发送 客户端请求数据不会每次都时时相应 让数据塞满一次性发送给客户端（多用于下载、断点 续传）</span><br><span class=\"line\">    #tcp_nodelay on; // 默认开启 与nopush互斥 提高实时请求响应效率</span><br><span class=\"line\"></span><br><span class=\"line\">    keepalive_timeout  65;//超时时间是65秒</span><br><span class=\"line\"></span><br><span class=\"line\">    #gzip  on;gzip压缩</span><br><span class=\"line\"></span><br><span class=\"line\">    include /etc/nginx/conf.d/*.conf;//包含的子配置文件</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>/etc/default.conf</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    # 用域名方式访问的地址</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    #charset koi8-r; //编码</span><br><span class=\"line\">    #access_log  /var/log/nginx/host.access.log  main;  //访问日志文件和名称</span><br><span class=\"line\"></span><br><span class=\"line\">    # 代理http协议请求</span><br><span class=\"line\">    location /api &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:3000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 代理ws协议请求</span><br><span class=\"line\">    location /ws &#123;</span><br><span class=\"line\">      proxy_pass http://localhost:3000;</span><br><span class=\"line\">      proxy_set_header Upgrade $http_upgrade;</span><br><span class=\"line\">      proxy_set_header Connection ‘Upgrade‘;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      # 代理/api/路径的请求 并去掉/api/路径进行转发</span><br><span class=\"line\">      location ~ /api/ &#123;</span><br><span class=\"line\">          rewrite /api/(.*)$ /$1 break;</span><br><span class=\"line\">          proxy_pass  http://www.baidu.com;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      location ~ / &#123;</span><br><span class=\"line\">          root /data/www-data/bolton/;</span><br><span class=\"line\">          try_files $uri $uri/ /index.html;</span><br><span class=\"line\">          index index.html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    # 转发请求静态资源（js、css）规则</span><br><span class=\"line\">    location ~ .*\\.(html|js|css)$ &#123;</span><br><span class=\"line\">        # CORS</span><br><span class=\"line\">        add_header Access-Control-Allow-Origin *;</span><br><span class=\"line\">        add_header Access-Control-Allow-Methods GET,POST,DELETE;</span><br><span class=\"line\">        add_header Access-Control-Allow-Headers Content-Type;</span><br><span class=\"line\">        # 默认带上客户端cookie</span><br><span class=\"line\">        add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">        # 缓存1h</span><br><span class=\"line\">        expires 1h;</span><br><span class=\"line\">        # 开启gzip</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        # gzip压缩HTTP版本号 一般是1.1</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        # gzip压缩等级 越大压缩率越高 1-9</span><br><span class=\"line\">        gzip_comp_level 2;</span><br><span class=\"line\">        # 默认不指定不会缓存css资源 需要指定text/css类型</span><br><span class=\"line\">        gzip_types application/javascript text/css;</span><br><span class=\"line\">        # 资源目录</span><br><span class=\"line\">        root /data/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置图片请求规则</span><br><span class=\"line\">    location ~ .*\\.(gif|png|jpg|webp)$ &#123;</span><br><span class=\"line\">        expires 1h;</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        gzip_comp_level 3;</span><br><span class=\"line\">        gzip_types image/jpeg image/png image/gif image/webp;</span><br><span class=\"line\">        ## 防盗链</span><br><span class=\"line\">        ## valid_referers 合法的域名 *.baidu.com</span><br><span class=\"line\">        ## &lt;meta name=\"referrer\" content=\"never\"&gt;</span><br><span class=\"line\">        valid_referers none blocked xx.xxx.xxx.xx;</span><br><span class=\"line\">        if ($invalid_referer) &#123;</span><br><span class=\"line\">            return 403;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        # 资源目录</span><br><span class=\"line\">        root /data/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ ^/download &#123;</span><br><span class=\"line\">        # 默认先查找当前目录下的后缀为.gz文件 有直接返回给客户端 不需要再压缩</span><br><span class=\"line\">        # linux下运行gzip 文件名会生成压缩gz文件</span><br><span class=\"line\">        # url最直接访问该文件路径就会自动启动下载该资源</span><br><span class=\"line\">        gzip_static on;</span><br><span class=\"line\">        tcp_nopush on;</span><br><span class=\"line\">        root /data/download;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   /usr/share/nginx/html;  //静态文件根目录</span><br><span class=\"line\">        index  index.html index.htm;  //首页的索引文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #error_page  404              /404.html;  //指定错误页面</span><br><span class=\"line\"></span><br><span class=\"line\">    # redirect server error pages to the static page /50x.html</span><br><span class=\"line\">    # 把后台错误重定向到静态的50x.html页面</span><br><span class=\"line\">    error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">    location = /50x.html &#123;</span><br><span class=\"line\">        root   /usr/share/nginx/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">    # 把PHP脚本9000端口上监听的FastCGI服务</span><br><span class=\"line\">    #location ~ \\.php$ &#123;</span><br><span class=\"line\">    #    root           html;</span><br><span class=\"line\">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">    #    fastcgi_index  index.php;</span><br><span class=\"line\">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class=\"line\">    #    include        fastcgi_params;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 不允许访问.htaccess文件 只允许指定的ip访问</span><br><span class=\"line\">    location ~ /\\.ht &#123;</span><br><span class=\"line\">        allow 127.0.0.1</span><br><span class=\"line\">        deny  all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>实现负载均衡</p>\n</blockquote>\n<ol>\n<li>\n<p>解决高并发、海量数据问题</p>\n</li>\n<li>\n<p>配置类型</p>\n<ol>\n<li>轮询（默认） 每个请求按照时间顺序逐一分配不同的后端服务器；</li>\n<li>ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定放一个后端服务器，可以解决 session 的问题；</li>\n<li>weight（加权轮询）指定轮询策略，weight 和访问比率成正比，用于后端服务器性能不均的情况；</li>\n<li>least_conn 最小连接数，哪个连接少就分给谁。</li>\n</ol>\n<p>集群状态：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">down</td>\n<td style=\"text-align:left\">不参与负载均衡</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">backup</td>\n<td style=\"text-align:left\">备份的服务器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">max_fails</td>\n<td style=\"text-align:left\">允许请求失败的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fail_timeout</td>\n<td style=\"text-align:left\">经过 max_fails 失败后，服务暂停的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">max_conts</td>\n<td style=\"text-align:left\">限制最大的接收的连接数</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream test1 &#123;</span><br><span class=\"line\">    ip_hsah;</span><br><span class=\"line\">    server http://localhost:3000 weight=2;</span><br><span class=\"line\">    server http://localhost:4000 weight=1;</span><br><span class=\"line\">    server http://localhost:5000 down;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    # 访问负载均衡构造的集群</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        # 和upstrem的name对应</span><br><span class=\"line\">        proxy_pass http://test1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test1.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:3000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test2.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:4000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test3.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:5000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时访问<code>www.test.com</code>通过代理到访问<code>www.test1.com</code>，而访问 test1 的请求被负载均衡按照策略访问 test1 或者 test2</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>\n<p>环境</p>\n<p>CENTOS&gt;=7.0,位数 X64 CENTOS 7.2</p>\n</li>\n<li>\n<p>关闭 iptables</p>\n<p>iptables 命令是 Linux 上常用的防火墙软件</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">功能</th>\n<th style=\"text-align:left\">命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">停止防火墙</td>\n<td style=\"text-align:left\">systemctl stop firewalld.service</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">永久关闭防火墙</td>\n<td style=\"text-align:left\">systemctl disable firewalld.service</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>安装依赖</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum  -y install gcc gcc-c++ autoconf pcre pcre-devel make automake</span><br><span class=\"line\">yum  -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>开始安装 nginx</p>\n<p>新建一个文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure>\n<p>内容输入如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[nginx]</span><br><span class=\"line\">name=nginx repo</span><br><span class=\"line\">baseurl=http://nginx.org/packages/centos/7/$basearch/</span><br><span class=\"line\">gpgcheck=0</span><br><span class=\"line\">enabled=1</span><br></pre></td></tr></table></figure>\n<p>其中 centos/7 根据自己运行环境配置 系统名/版本号</p>\n<p>下载 nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install nginx -y</span><br><span class=\"line\">nginx -v</span><br><span class=\"line\">nginx -V</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2>nginx 常用操作</h2>\n<ol>\n<li>\n<p>查看配置文件和目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ql nginx</span><br></pre></td></tr></table></figure>\n<p>相关文件说明：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">路径</th>\n<th style=\"text-align:left\">用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/logrotate.d/nginx</td>\n<td style=\"text-align:left\">用于 logrotate 服务的日志切割</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx /etc/nginx/nginx.conf /etc/nginx/conf.d /etc/nginx/conf.d/default.conf</td>\n<td style=\"text-align:left\">主配置文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/fastcgi_params /etc/nginx/scgi_params /etc/nginx/uwsgi_params</td>\n<td style=\"text-align:left\">cgi 配置,fastcgi 配置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/koi-utf /etc/nginx/koi-win /etc/nginx/win-utf</td>\n<td style=\"text-align:left\">编码转换映射转化文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/mime.types</td>\n<td style=\"text-align:left\">设置 http 协议的 Content-Type 与扩展名对应关系</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/usr/lib/systemd/system/nginx-debug.service /usr/lib/systemd/system/nginx.service /etc/sysconfig/nginx /etc/sysconfig/nginx-debug</td>\n<td style=\"text-align:left\">用于配置系统守护进程管理器管理方式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">配置文件</td>\n<td style=\"text-align:left\">/etc/nginx/modules /usr/lib64/nginx/modules</td>\n<td style=\"text-align:left\">nginx 模块目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">命令</td>\n<td style=\"text-align:left\">/usr/share/doc/nginx-1.14.0 /usr/share/doc/nginx-1.14.0/COPYRIGHT</td>\n<td style=\"text-align:left\">nginx 的手册和帮助文件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目录</td>\n<td style=\"text-align:left\">/var/cache/nginx</td>\n<td style=\"text-align:left\">nginx 的缓存目录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目录</td>\n<td style=\"text-align:left\">/var/log/nginx</td>\n<td style=\"text-align:left\">nginx 的日志目录</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>启动和重新加载以及关闭</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart nginx.service</span><br><span class=\"line\">systemctl reload nginx.service</span><br><span class=\"line\">systemctl stop nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>如果在启动的时候可能会遇到下列问题：</p>\n<ol>\n<li>端口被占用；</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting nginx: nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\"></span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class=\"line\">nginx: [emerg] still could not bind</span><br></pre></td></tr></table></figure>\n<p>可以先查看进程，再杀死对应进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ntpl</span><br><span class=\"line\"></span><br><span class=\"line\">kill 进程号</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>配置 nginx</p>\n</li>\n</ol>\n<blockquote>\n<p>/etc/nginx/nginx.conf</p>\n</blockquote>\n<p>查看日志命令 tailf -f log 目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user  nginx;   设置nginx服务的系统使用用户</span><br><span class=\"line\">worker_processes  1;  工作进程数,一般和CPU数量相同</span><br><span class=\"line\"></span><br><span class=\"line\">error_log  /var/log/nginx/error.log warn;   nginx的错误日志</span><br><span class=\"line\">pid        /var/run/nginx.pid;   nginx服务启动时的pid</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  1024;每个进程允许的最大连接数 10000</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       /etc/nginx/mime.types;//文件后缀和类型类型的对应关系</span><br><span class=\"line\">    default_type  application/octet-stream;//默认content-type</span><br><span class=\"line\"></span><br><span class=\"line\">    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '</span><br><span class=\"line\">                    '$status $body_bytes_sent \"$http_referer\" '</span><br><span class=\"line\">                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';  //日志记录格式</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;//默认访问日志 日志格式与log_format main 对应</span><br><span class=\"line\"></span><br><span class=\"line\">    sendfile        on;//启用sendfile</span><br><span class=\"line\">    #tcp_nopush     on;//懒发送 客户端请求数据不会每次都时时相应 让数据塞满一次性发送给客户端（多用于下载、断点 续传）</span><br><span class=\"line\">    #tcp_nodelay on; // 默认开启 与nopush互斥 提高实时请求响应效率</span><br><span class=\"line\"></span><br><span class=\"line\">    keepalive_timeout  65;//超时时间是65秒</span><br><span class=\"line\"></span><br><span class=\"line\">    #gzip  on;gzip压缩</span><br><span class=\"line\"></span><br><span class=\"line\">    include /etc/nginx/conf.d/*.conf;//包含的子配置文件</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>/etc/default.conf</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    # 用域名方式访问的地址</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">    #charset koi8-r; //编码</span><br><span class=\"line\">    #access_log  /var/log/nginx/host.access.log  main;  //访问日志文件和名称</span><br><span class=\"line\"></span><br><span class=\"line\">    # 代理http协议请求</span><br><span class=\"line\">    location /api &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:3000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 代理ws协议请求</span><br><span class=\"line\">    location /ws &#123;</span><br><span class=\"line\">      proxy_pass http://localhost:3000;</span><br><span class=\"line\">      proxy_set_header Upgrade $http_upgrade;</span><br><span class=\"line\">      proxy_set_header Connection ‘Upgrade‘;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      # 代理/api/路径的请求 并去掉/api/路径进行转发</span><br><span class=\"line\">      location ~ /api/ &#123;</span><br><span class=\"line\">          rewrite /api/(.*)$ /$1 break;</span><br><span class=\"line\">          proxy_pass  http://www.baidu.com;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      location ~ / &#123;</span><br><span class=\"line\">          root /data/www-data/bolton/;</span><br><span class=\"line\">          try_files $uri $uri/ /index.html;</span><br><span class=\"line\">          index index.html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    # 转发请求静态资源（js、css）规则</span><br><span class=\"line\">    location ~ .*\\.(html|js|css)$ &#123;</span><br><span class=\"line\">        # CORS</span><br><span class=\"line\">        add_header Access-Control-Allow-Origin *;</span><br><span class=\"line\">        add_header Access-Control-Allow-Methods GET,POST,DELETE;</span><br><span class=\"line\">        add_header Access-Control-Allow-Headers Content-Type;</span><br><span class=\"line\">        # 默认带上客户端cookie</span><br><span class=\"line\">        add_header Access-Control-Allow-Credentials true;</span><br><span class=\"line\">        # 缓存1h</span><br><span class=\"line\">        expires 1h;</span><br><span class=\"line\">        # 开启gzip</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        # gzip压缩HTTP版本号 一般是1.1</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        # gzip压缩等级 越大压缩率越高 1-9</span><br><span class=\"line\">        gzip_comp_level 2;</span><br><span class=\"line\">        # 默认不指定不会缓存css资源 需要指定text/css类型</span><br><span class=\"line\">        gzip_types application/javascript text/css;</span><br><span class=\"line\">        # 资源目录</span><br><span class=\"line\">        root /data/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 设置图片请求规则</span><br><span class=\"line\">    location ~ .*\\.(gif|png|jpg|webp)$ &#123;</span><br><span class=\"line\">        expires 1h;</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        gzip_comp_level 3;</span><br><span class=\"line\">        gzip_types image/jpeg image/png image/gif image/webp;</span><br><span class=\"line\">        ## 防盗链</span><br><span class=\"line\">        ## valid_referers 合法的域名 *.baidu.com</span><br><span class=\"line\">        ## &lt;meta name=\"referrer\" content=\"never\"&gt;</span><br><span class=\"line\">        valid_referers none blocked xx.xxx.xxx.xx;</span><br><span class=\"line\">        if ($invalid_referer) &#123;</span><br><span class=\"line\">            return 403;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        # 资源目录</span><br><span class=\"line\">        root /data/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ ^/download &#123;</span><br><span class=\"line\">        # 默认先查找当前目录下的后缀为.gz文件 有直接返回给客户端 不需要再压缩</span><br><span class=\"line\">        # linux下运行gzip 文件名会生成压缩gz文件</span><br><span class=\"line\">        # url最直接访问该文件路径就会自动启动下载该资源</span><br><span class=\"line\">        gzip_static on;</span><br><span class=\"line\">        tcp_nopush on;</span><br><span class=\"line\">        root /data/download;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   /usr/share/nginx/html;  //静态文件根目录</span><br><span class=\"line\">        index  index.html index.htm;  //首页的索引文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    #error_page  404              /404.html;  //指定错误页面</span><br><span class=\"line\"></span><br><span class=\"line\">    # redirect server error pages to the static page /50x.html</span><br><span class=\"line\">    # 把后台错误重定向到静态的50x.html页面</span><br><span class=\"line\">    error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">    location = /50x.html &#123;</span><br><span class=\"line\">        root   /usr/share/nginx/html;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">    # 把PHP脚本9000端口上监听的FastCGI服务</span><br><span class=\"line\">    #location ~ \\.php$ &#123;</span><br><span class=\"line\">    #    root           html;</span><br><span class=\"line\">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class=\"line\">    #    fastcgi_index  index.php;</span><br><span class=\"line\">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class=\"line\">    #    include        fastcgi_params;</span><br><span class=\"line\">    #&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 不允许访问.htaccess文件 只允许指定的ip访问</span><br><span class=\"line\">    location ~ /\\.ht &#123;</span><br><span class=\"line\">        allow 127.0.0.1</span><br><span class=\"line\">        deny  all;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>实现负载均衡</p>\n</blockquote>\n<ol>\n<li>\n<p>解决高并发、海量数据问题</p>\n</li>\n<li>\n<p>配置类型</p>\n<ol>\n<li>轮询（默认） 每个请求按照时间顺序逐一分配不同的后端服务器；</li>\n<li>ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定放一个后端服务器，可以解决 session 的问题；</li>\n<li>weight（加权轮询）指定轮询策略，weight 和访问比率成正比，用于后端服务器性能不均的情况；</li>\n<li>least_conn 最小连接数，哪个连接少就分给谁。</li>\n</ol>\n<p>集群状态：</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">down</td>\n<td style=\"text-align:left\">不参与负载均衡</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">backup</td>\n<td style=\"text-align:left\">备份的服务器</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">max_fails</td>\n<td style=\"text-align:left\">允许请求失败的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fail_timeout</td>\n<td style=\"text-align:left\">经过 max_fails 失败后，服务暂停的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">max_conts</td>\n<td style=\"text-align:left\">限制最大的接收的连接数</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream test1 &#123;</span><br><span class=\"line\">    ip_hsah;</span><br><span class=\"line\">    server http://localhost:3000 weight=2;</span><br><span class=\"line\">    server http://localhost:4000 weight=1;</span><br><span class=\"line\">    server http://localhost:5000 down;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    # 访问负载均衡构造的集群</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        # 和upstrem的name对应</span><br><span class=\"line\">        proxy_pass http://test1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test1.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:3000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test2.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:4000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name www.test3.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://localhost:5000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时访问<code>www.test.com</code>通过代理到访问<code>www.test1.com</code>，而访问 test1 的请求被负载均衡按照策略访问 test1 或者 test2</p>\n"},{"title":"前端基础面试题整理","catalog":true,"date":"2019-11-12T02:15:59.000Z","subtitle":null,"header-img":null,"_content":"\n## js 基础\n\n- 闭包\n- 作用域\n- 原型链\n- 变量提升\n- 函数参数值传递\n- this 指向问题\n- 函数提升以及优先级问题\n- new 操作符做了什么？\n\n```javascript\nfunction A(id) {\n  this.id = id;\n}\n\nA.prototype.showId = function() {\n  console.log(this.id);\n};\n\n// new内部实现\nfunction myNew() {\n  var o = new Object();\n  // 取得外部传入的构造器，默认第一个参数是构造函数\n  var Constructor = Array.prototype.shift.call(arguments);\n  // 实现继承，实例可以访问构造器的属性\n  o.__proto__ = Constructor.prototype;\n  // 调用构造器，并改变其 this 指向到实例\n  var ret = Constructor.call(o, arguments);\n  // 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象\n  return typeof ret === \"object\" && ret !== null ? ret : obj;\n}\n\nvar a = myNew(A, 10);\n```\n\n- 用 ES5 实现一个继承（有哪些方式）\n- 0.2+0.1 不等于 0.3 问题（浮点数精度）\n- 堆、栈、队列是什么？都有什么区别？有什么应用？\n- 深拷贝、浅拷贝问题（immutable 是怎么实现的？）\n- typed array 问题\n- es6 箭头函数问题\n- let var const 区别与原理\n\n1. var 存在变量提升，执行时已经完成声明与初始化，全局作用域|函数作用域；\n2. let const 不能重复定义，存在暂时性死区，没有变量提升，块作用域；\n3. var 在栈内存预分配空间，等执行时候再讲变量值存在空间里，let const 不会\n\n- 什么是 iterator？for of 用过吗？\n- call、apply、bind 区别，bind 怎么实现的？\n\n- promise 实现，Promise.all 实现， Promise.race，Promise.finally 实现\n\n```javascript\n_Promise.all = arr => {\n  let aResult = []; //用于存放每次执行后返回结果\n  return new _Promise(function(resolve, reject) {\n    let i = 0;\n    next(); // 开始逐次执行数组中的函数(重要)\n    function next() {\n      arr[i].then(function(res) {\n        aResult.push(res); // 存储每次得到的结果\n        i++;\n        if (i == arr.length) {\n          // 如果函数数组中的函数都执行完，便resolve\n          resolve(aResult);\n        } else {\n          next();\n        }\n      });\n    }\n  });\n};\n\nconst race = (_Promise.race = function(iterable) {\n  return new Promise(function(resolve, reject) {\n    for (const i in iterable) {\n      const v = iterable[i];\n      if (typeof v === \"object\" && typeof v.then === \"function\") {\n        v.then(resolve, reject);\n      } else {\n        resolve(v);\n      }\n    }\n  });\n});\n\n_Promise.finally = function(callback) {\n  const P = this.constructor; // 获取当前实例构造函数的引用\n  return this.then(\n    value => P.resolve(callback()).then(() => value),\n    reason =>\n      P.resolve(callback()).then(() => {\n        throw reason;\n      })\n  );\n};\n\nconst p1 = new Promise(function(resolve) {\n  setTimeout(resolve, 200, 1);\n});\nconst p2 = new Promise(function(resolve) {\n  setTimeout(resolve, 100, 2);\n});\nrace([p1, p2]).then(function(res) {\n  console.log(res);\n});\n```\n\n- caller、callee 了解吗？什么时候会用到？建议用吗？\n\n```javascript\nfunction factorial(x) {\n  return x <= 1 ? 1 : x * factorial(x - 1);\n}\n\n// callee\n// callee是arguments对象的一个属性，指向 arguments 对象的函数\n// 利用callee\nfunction factorial(x) {\n  return x <= 1 ? 1 : x * arguments.callee(x - 1);\n}\n\n// caller\n// 函数对象的一个属性，指向调用当前函数的函数。比如 A() 调用 B()， 则在B()中 B.caller 指向A()\n\n// 1 这个属性只有当函数在执行时才有用\n\n// 2 如果在JavaScript程序中，函数是由顶层调用的，则返回null\n\nfunction B() {\n  console.log(B.caller); // B\n}\n\n(function A() {\n  B(); // A\n})();\n```\n\n- async await 知识点（await 的作用，async 返回的是什么）\n\n很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。\n\n```javascript\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\n\n// 等价于\n\nasync function async1() {\n  console.log(\"async1 start\");\n  Promise.resolve(async2()).then(() => {\n    console.log(\"async1 end\");\n  });\n}\n```\n\n- Async/Await 如何通过同步的方式实现异步?\n\nAsync/Await 就是一个自执行的 generate 函数。利用 generate 函数的特性把异步的代码写成“同步”的形式，generate 函数本身实现思想来源于单向链表。\n\n- generator 又是什么？\n\n生成器 generator 函数执行时返回这个生成器的迭代对象，当这个迭代对象的 next 方法被调用时，遇到 yield 的位置停止，yield 后返回的值就是迭代器要返回的值。如果用的是 yield\\*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行），调用 next() （再启动）方法时，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值，例如：\n\n```javascript\nfunction* another() {\n  yield \"人月神话\";\n}\nfunction* gen() {\n  yield* another(); // 移交执行权\n  const a = yield \"hello\";\n  const b = yield a; // a='world' 是 next('world') 传参赋值给了上一个 yidle 'hello' 的左值\n  yield b; // b=！ 是 next('！') 传参赋值给了上一个 yidle a 的左值\n}\nconst g = gen();\ng.next(); // {value: \"人月神话\", done: false}\ng.next(); // {value: \"hello\", done: false}\ng.next(\"world\"); // {value: \"world\", done: false} 将 'world' 赋给上一条 yield 'hello' 的左值，即执行 a='world'，\ng.next(\"!\"); // {value: \"!\", done: false} 将 '!' 赋给上一条 yield a 的左值，即执行 b='!'，返回 b\ng.next(); // {value: undefined, done: false}\n```\n\n- v8 线程模型、event loop（async、promise、nextTick、setTimeout、- setImmediate 经典问题变着花样考）\n- 进程和线程是什么？有什么区别？\n- v8 垃圾回收机制\n- 输入 URL，浏览器的执行过程又是怎么样的？（浏览器解析方式、顺序，async、- defer 等）\n- 了解前端模块化吗？有几种规范？（commonjs 和 es module 都是怎么实现- 的？有啥区别？）\n\n- 按需加载实现\n\n- ['1', '2', '3'].map(parseInt) parseInt(100, 2) = 4\n- 防抖节流\n\n1. 防抖\n   > 高频事件 n 秒内执行一次，如果 n 秒内再次触发，重新计时\n\n```javascript\nfunction debonce(fn, time) {\n  let timeout = null;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(function() {\n      fn.apply(this, arguments);\n    }, time);\n  };\n}\n```\n\n2. 节流\n   > 高频事件 n 秒内执行一次\n\n```javascript\nfunction debonce(fn, time) {\n  let startTime = 0;\n  return function() {\n    let nowTime = Date.now();\n    if (nowTime - startTime >= time) {\n      fn.apply(this, arguments);\n      startTime = Date.now();\n    }\n  };\n}\n```\n\n- Set WeaksSet 和 Map WeakMap 各自区别\n\n  Set 无序类似数组的数据结构\n\n  WeakSet\n\n  1. 只能是对象引用；\n  2. 未使用会被 GC 收集\n\n  Map 字典结构，以`value:value`形式存储\n\n  WeakMap\n\n  1. 建的对象引用只能是对象引用；\n  2. 未使用的建对象会被 GC 收集\n\n- es5 和 es6 类的区别\n\n  1. class 会提升，但不会赋值，会进入暂时性死区（TDZ）；\n  2. class 内部默认启用严格模式；\n  3. class 的所有方法、属性不能枚举；\n  4. class 所有方法没有 prototype，也没有[[constructor]]，不能实例化；\n  5. 必须使用`new`来实例化；\n  6. class 无法重写类名；\n\n- es5 和 es6 的继承区别\n\n  1. es5 的继承是先实例化子类，再通过父类构造函数修饰子类实例，而 es6 的继承是通过`super`方法先实例化父类，再通过子类构造函数修饰父类实例；\n  2. es6 的子类可以通过`__proto__`找到父类，而 es5 中通过`__proto__`只能找到`Function.prototype`\n\n- 箭头函数和普通函数区别\n\n1. 箭头函数本身没有 this，需要通过原型向上级对象查找，即 this 对象是指向定义是所在作用域的 this 对象（因此无法使用 call、apply、bind 绑定 this 值），普通函数指向调用时的对象；\n2. 箭头函数没有 arguments，可以用 rest 参数代替；\n3. 箭头函数不能使用 new 命令，\n\n- 因为没有 this，无法调用 call；\n- 没有 prototype\n\n4. 箭头函数没有原型 prototype；\n\n---\n\n## 网络\n\n- http 1.0 1.1 2.0 协议特性与区别\n\n  **http 1.0**\n\n  1. 无状态\n\n  需要 cookie/session 做身份认证和登录\n\n  2. 无连接\n\n  a. 每次连接结束都会关闭连接，再重新创建连接 tcp 三次连接与四次挥手，效率很低；\n\n  b. 在上一个请求到达结束之前无法发送下一个请求；\n\n  **http 1.1**\n\n  1. 长连接 keep-alive\n  2. 管道机制 不必等待上一个请求返回就能发送下一个请求，返回的结果还是按照顺序，但是为了保持响应顺序，还是存在队头阻塞问题；\n  3. 缓存 cache-control；\n  4. 断点传输\n\n  **http 2.0**\n\n  1. 二进制分帧；\n  2. 多路复用 在共享 TCP 链接的基础上同时发送请求和响应；\n  3. 头部压缩；\n  4. 服务器推送；\n\n- 简单讲解一下 http2 的多路复用\n\nhttp1.0 一个请求建立一个链接，请求结束就关闭，依次往复，可开启'keep-alive'，让链接不关闭复用\n\nhttp1.1 默认允许一个连接发送多个请求，浏览器为了控制资源一般控制在 6 个左右，虽然建立多个连接，但需要等待前一个请求结束，服务器才会响应后面的请求；\n\nhttp2 采用二进制传输数据，更高效，有两个非常重要的概念，帧和流，帧是最小数据单位，帧会标识属于哪个流，可以在一个连接中发送并行发送多个请求，避免了 1.1 中队头阻塞的问题，极大提高性能。\n\n- TCP 三次握手和四次挥手的理解\n\n![示意图](https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png)\n\nTCP 三次握手：\n\n其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的 ACK 都会对这个 seq 进行加一来进行确认\n\n三次握手之所以是三次是保证 client 和 server 均让对方知道自己的接收和发送能力没问题而保证的最小次数，三次是最少的安全次数，两次不安全，四次浪费资源。\n\n四次挥手：\n\nTCP 是全双工信道，何为全双工就是客户端与服务端建立两条通道，\n\n通道 1:客户端的输出连接服务端的输入；\n\n通道 2:客户端的输入连接服务端的输出。\n\n两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：\n\n客户端：我要关闭输入通道了。 服务端：好的，你关闭吧，我这边也关闭这个通道。\n\n服务端：我也要关闭输入通道了。 客户端：好的你关闭吧，我也把这个通道关闭。\n\n- rpc 协议和 tcp 协议的区别\n\ntcp\n\n1. tcp 协议需要 DNS 寻址；\n2. tcp 协议是单工通信；\n\nrpc\n\n1. 二进制数据传输，更小的体积，更快编解码速率；\n2. 不一定是 DNS 寻址，可能是内部服务寻址；\n3. 单工/半双工/双工通信方式支持；\n\n---\n\n## 浏览器\n\n1. 说说浏览器和 Node 事件循环的区别\n\n微任务和宏任务在 Node 的执行顺序\n\nNode 10 及以前：\n\n执行完一个阶段（timers、I/O、poll 等）的任务\n就会去执行 nextTick 队列里面的内容\n然后再执行完微任务队列的内容\n\nNode 11 以后： 和浏览器的行为统一了，都是每执行完一个宏任务就会执行微任务队列。\n\n![Node的Event Loop](https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n```javascript\nfunction test() {\n  console.log(\"start\");\n  setTimeout(() => {\n    console.log(\"children2\");\n    Promise.resolve().then(() => {\n      console.log(\"children2-1\");\n    });\n  }, 0);\n  setTimeout(() => {\n    console.log(\"children3\");\n    Promise.resolve().then(() => {\n      console.log(\"children3-1\");\n    });\n  }, 0);\n  Promise.resolve().then(() => {\n    console.log(\"children1\");\n  });\n  console.log(\"end\");\n}\n\ntest();\n\n// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)\n// start\n// end\n// children1\n// children2\n// children3\n// children2-1\n// children3-1\n\n// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)\n// start\n// end\n// children1\n// children2\n// children2-1\n// children3\n// children3-1\n```\n\n2. 重绘与回流\n\n几何属性 样式变化会引起 重绘\n\n几何形状 位置变化引起 回流\n\n---\n\n### 前端内功\n\n1. 模块化理解；\n\n> 模块化是为了处理全局污染、隔离作用域、抽离公共代码等问题\n\n| 名称         | 特点                                                             |\n| ------------ | ---------------------------------------------------------------- |\n| `iife`       | 自执行 函数作用域                                                |\n| `amd`        | 浏览器端（requirejs） 依赖前置                                   |\n| `cmd`        | 浏览器端（seajs） 运行时加载依赖 后面也支持依赖前置              |\n| `commonjs`   | 浏览器、服务器通用 运行时加载 第一次运行加载，缓存值，值的浅拷贝 |\n| `es6 module` | 浏览器、服务器通用 静态编译，编译时输出接口 值的引用             |\n\n2. 工程化理解；\n3. 组件化理解;\n4. 性能优化；\n\n---\n\n### 框架\n\n1. React 中的 setState 何时是同步的，何时是异步的？\n\n在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理，生命周期函数等），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。\n\n**原因：** 在 React 的 setState 函数实现中，会根据一个变量`isBatchingUpdate`·判断是直接更新 this.state 还是放到队列中回头再说，而`isBatchingUpdates`默认是`false`，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。\n\n2. vue 父组件和子组件创建的生命周期顺序\n\n- 加载渲染过程 父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount->子 mounted->父 mounted\n\n- 子组件更新过程 父 beforeUpdate->子 beforeUpdate->子 updated->父 updated\n\n- 父组件更新过程 父 beforeUpdate->父 updated\n\n- 销毁过程 父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed\n\n---\n\n### CSS\n\n1. 介绍下 BFC 及其应用\n\nBFC 块级格式上下文， 是指一个独立的渲染区域或者说是一个隔离的独立容器。\n\n形成条件：\n\n1、浮动元素，float 除 none 以外的值；\n\n2、定位元素，position（absolute，fixed）；\n\n3、display 为以下其中之一的值 inline-block，table-cell，table-caption；\n\n4、overflow 除了 visible 以外的值（hidden，auto，scroll）；\n\n特点：\n\n1.内部的 Box 会在垂直方向上一个接一个的放置。\n\n2.垂直方向上的距离由 margin 决定，垂直外边距会重叠即两个盒子中间距离以 margin 最大的值决定；\n\n3.bfc 的区域不会与 float 的元素区域重叠。\n\n4.计算 bfc 的高度时，浮动元素也参与计算\n\n5.bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。\n\n参考：[CSS 中的 BFC 详解](https://www.cnblogs.com/chen-cong/p/7862832.html)\n","source":"_posts/前端基础面试题整理.md","raw":"---\ntitle: 前端基础面试题整理\ncatalog: true\ndate: 2019-11-12 10:15:59\nsubtitle:\nheader-img:\ntags: 前端\n---\n\n## js 基础\n\n- 闭包\n- 作用域\n- 原型链\n- 变量提升\n- 函数参数值传递\n- this 指向问题\n- 函数提升以及优先级问题\n- new 操作符做了什么？\n\n```javascript\nfunction A(id) {\n  this.id = id;\n}\n\nA.prototype.showId = function() {\n  console.log(this.id);\n};\n\n// new内部实现\nfunction myNew() {\n  var o = new Object();\n  // 取得外部传入的构造器，默认第一个参数是构造函数\n  var Constructor = Array.prototype.shift.call(arguments);\n  // 实现继承，实例可以访问构造器的属性\n  o.__proto__ = Constructor.prototype;\n  // 调用构造器，并改变其 this 指向到实例\n  var ret = Constructor.call(o, arguments);\n  // 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象\n  return typeof ret === \"object\" && ret !== null ? ret : obj;\n}\n\nvar a = myNew(A, 10);\n```\n\n- 用 ES5 实现一个继承（有哪些方式）\n- 0.2+0.1 不等于 0.3 问题（浮点数精度）\n- 堆、栈、队列是什么？都有什么区别？有什么应用？\n- 深拷贝、浅拷贝问题（immutable 是怎么实现的？）\n- typed array 问题\n- es6 箭头函数问题\n- let var const 区别与原理\n\n1. var 存在变量提升，执行时已经完成声明与初始化，全局作用域|函数作用域；\n2. let const 不能重复定义，存在暂时性死区，没有变量提升，块作用域；\n3. var 在栈内存预分配空间，等执行时候再讲变量值存在空间里，let const 不会\n\n- 什么是 iterator？for of 用过吗？\n- call、apply、bind 区别，bind 怎么实现的？\n\n- promise 实现，Promise.all 实现， Promise.race，Promise.finally 实现\n\n```javascript\n_Promise.all = arr => {\n  let aResult = []; //用于存放每次执行后返回结果\n  return new _Promise(function(resolve, reject) {\n    let i = 0;\n    next(); // 开始逐次执行数组中的函数(重要)\n    function next() {\n      arr[i].then(function(res) {\n        aResult.push(res); // 存储每次得到的结果\n        i++;\n        if (i == arr.length) {\n          // 如果函数数组中的函数都执行完，便resolve\n          resolve(aResult);\n        } else {\n          next();\n        }\n      });\n    }\n  });\n};\n\nconst race = (_Promise.race = function(iterable) {\n  return new Promise(function(resolve, reject) {\n    for (const i in iterable) {\n      const v = iterable[i];\n      if (typeof v === \"object\" && typeof v.then === \"function\") {\n        v.then(resolve, reject);\n      } else {\n        resolve(v);\n      }\n    }\n  });\n});\n\n_Promise.finally = function(callback) {\n  const P = this.constructor; // 获取当前实例构造函数的引用\n  return this.then(\n    value => P.resolve(callback()).then(() => value),\n    reason =>\n      P.resolve(callback()).then(() => {\n        throw reason;\n      })\n  );\n};\n\nconst p1 = new Promise(function(resolve) {\n  setTimeout(resolve, 200, 1);\n});\nconst p2 = new Promise(function(resolve) {\n  setTimeout(resolve, 100, 2);\n});\nrace([p1, p2]).then(function(res) {\n  console.log(res);\n});\n```\n\n- caller、callee 了解吗？什么时候会用到？建议用吗？\n\n```javascript\nfunction factorial(x) {\n  return x <= 1 ? 1 : x * factorial(x - 1);\n}\n\n// callee\n// callee是arguments对象的一个属性，指向 arguments 对象的函数\n// 利用callee\nfunction factorial(x) {\n  return x <= 1 ? 1 : x * arguments.callee(x - 1);\n}\n\n// caller\n// 函数对象的一个属性，指向调用当前函数的函数。比如 A() 调用 B()， 则在B()中 B.caller 指向A()\n\n// 1 这个属性只有当函数在执行时才有用\n\n// 2 如果在JavaScript程序中，函数是由顶层调用的，则返回null\n\nfunction B() {\n  console.log(B.caller); // B\n}\n\n(function A() {\n  B(); // A\n})();\n```\n\n- async await 知识点（await 的作用，async 返回的是什么）\n\n很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。\n\n```javascript\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\n\n// 等价于\n\nasync function async1() {\n  console.log(\"async1 start\");\n  Promise.resolve(async2()).then(() => {\n    console.log(\"async1 end\");\n  });\n}\n```\n\n- Async/Await 如何通过同步的方式实现异步?\n\nAsync/Await 就是一个自执行的 generate 函数。利用 generate 函数的特性把异步的代码写成“同步”的形式，generate 函数本身实现思想来源于单向链表。\n\n- generator 又是什么？\n\n生成器 generator 函数执行时返回这个生成器的迭代对象，当这个迭代对象的 next 方法被调用时，遇到 yield 的位置停止，yield 后返回的值就是迭代器要返回的值。如果用的是 yield\\*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行），调用 next() （再启动）方法时，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值，例如：\n\n```javascript\nfunction* another() {\n  yield \"人月神话\";\n}\nfunction* gen() {\n  yield* another(); // 移交执行权\n  const a = yield \"hello\";\n  const b = yield a; // a='world' 是 next('world') 传参赋值给了上一个 yidle 'hello' 的左值\n  yield b; // b=！ 是 next('！') 传参赋值给了上一个 yidle a 的左值\n}\nconst g = gen();\ng.next(); // {value: \"人月神话\", done: false}\ng.next(); // {value: \"hello\", done: false}\ng.next(\"world\"); // {value: \"world\", done: false} 将 'world' 赋给上一条 yield 'hello' 的左值，即执行 a='world'，\ng.next(\"!\"); // {value: \"!\", done: false} 将 '!' 赋给上一条 yield a 的左值，即执行 b='!'，返回 b\ng.next(); // {value: undefined, done: false}\n```\n\n- v8 线程模型、event loop（async、promise、nextTick、setTimeout、- setImmediate 经典问题变着花样考）\n- 进程和线程是什么？有什么区别？\n- v8 垃圾回收机制\n- 输入 URL，浏览器的执行过程又是怎么样的？（浏览器解析方式、顺序，async、- defer 等）\n- 了解前端模块化吗？有几种规范？（commonjs 和 es module 都是怎么实现- 的？有啥区别？）\n\n- 按需加载实现\n\n- ['1', '2', '3'].map(parseInt) parseInt(100, 2) = 4\n- 防抖节流\n\n1. 防抖\n   > 高频事件 n 秒内执行一次，如果 n 秒内再次触发，重新计时\n\n```javascript\nfunction debonce(fn, time) {\n  let timeout = null;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(function() {\n      fn.apply(this, arguments);\n    }, time);\n  };\n}\n```\n\n2. 节流\n   > 高频事件 n 秒内执行一次\n\n```javascript\nfunction debonce(fn, time) {\n  let startTime = 0;\n  return function() {\n    let nowTime = Date.now();\n    if (nowTime - startTime >= time) {\n      fn.apply(this, arguments);\n      startTime = Date.now();\n    }\n  };\n}\n```\n\n- Set WeaksSet 和 Map WeakMap 各自区别\n\n  Set 无序类似数组的数据结构\n\n  WeakSet\n\n  1. 只能是对象引用；\n  2. 未使用会被 GC 收集\n\n  Map 字典结构，以`value:value`形式存储\n\n  WeakMap\n\n  1. 建的对象引用只能是对象引用；\n  2. 未使用的建对象会被 GC 收集\n\n- es5 和 es6 类的区别\n\n  1. class 会提升，但不会赋值，会进入暂时性死区（TDZ）；\n  2. class 内部默认启用严格模式；\n  3. class 的所有方法、属性不能枚举；\n  4. class 所有方法没有 prototype，也没有[[constructor]]，不能实例化；\n  5. 必须使用`new`来实例化；\n  6. class 无法重写类名；\n\n- es5 和 es6 的继承区别\n\n  1. es5 的继承是先实例化子类，再通过父类构造函数修饰子类实例，而 es6 的继承是通过`super`方法先实例化父类，再通过子类构造函数修饰父类实例；\n  2. es6 的子类可以通过`__proto__`找到父类，而 es5 中通过`__proto__`只能找到`Function.prototype`\n\n- 箭头函数和普通函数区别\n\n1. 箭头函数本身没有 this，需要通过原型向上级对象查找，即 this 对象是指向定义是所在作用域的 this 对象（因此无法使用 call、apply、bind 绑定 this 值），普通函数指向调用时的对象；\n2. 箭头函数没有 arguments，可以用 rest 参数代替；\n3. 箭头函数不能使用 new 命令，\n\n- 因为没有 this，无法调用 call；\n- 没有 prototype\n\n4. 箭头函数没有原型 prototype；\n\n---\n\n## 网络\n\n- http 1.0 1.1 2.0 协议特性与区别\n\n  **http 1.0**\n\n  1. 无状态\n\n  需要 cookie/session 做身份认证和登录\n\n  2. 无连接\n\n  a. 每次连接结束都会关闭连接，再重新创建连接 tcp 三次连接与四次挥手，效率很低；\n\n  b. 在上一个请求到达结束之前无法发送下一个请求；\n\n  **http 1.1**\n\n  1. 长连接 keep-alive\n  2. 管道机制 不必等待上一个请求返回就能发送下一个请求，返回的结果还是按照顺序，但是为了保持响应顺序，还是存在队头阻塞问题；\n  3. 缓存 cache-control；\n  4. 断点传输\n\n  **http 2.0**\n\n  1. 二进制分帧；\n  2. 多路复用 在共享 TCP 链接的基础上同时发送请求和响应；\n  3. 头部压缩；\n  4. 服务器推送；\n\n- 简单讲解一下 http2 的多路复用\n\nhttp1.0 一个请求建立一个链接，请求结束就关闭，依次往复，可开启'keep-alive'，让链接不关闭复用\n\nhttp1.1 默认允许一个连接发送多个请求，浏览器为了控制资源一般控制在 6 个左右，虽然建立多个连接，但需要等待前一个请求结束，服务器才会响应后面的请求；\n\nhttp2 采用二进制传输数据，更高效，有两个非常重要的概念，帧和流，帧是最小数据单位，帧会标识属于哪个流，可以在一个连接中发送并行发送多个请求，避免了 1.1 中队头阻塞的问题，极大提高性能。\n\n- TCP 三次握手和四次挥手的理解\n\n![示意图](https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png)\n\nTCP 三次握手：\n\n其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的 ACK 都会对这个 seq 进行加一来进行确认\n\n三次握手之所以是三次是保证 client 和 server 均让对方知道自己的接收和发送能力没问题而保证的最小次数，三次是最少的安全次数，两次不安全，四次浪费资源。\n\n四次挥手：\n\nTCP 是全双工信道，何为全双工就是客户端与服务端建立两条通道，\n\n通道 1:客户端的输出连接服务端的输入；\n\n通道 2:客户端的输入连接服务端的输出。\n\n两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：\n\n客户端：我要关闭输入通道了。 服务端：好的，你关闭吧，我这边也关闭这个通道。\n\n服务端：我也要关闭输入通道了。 客户端：好的你关闭吧，我也把这个通道关闭。\n\n- rpc 协议和 tcp 协议的区别\n\ntcp\n\n1. tcp 协议需要 DNS 寻址；\n2. tcp 协议是单工通信；\n\nrpc\n\n1. 二进制数据传输，更小的体积，更快编解码速率；\n2. 不一定是 DNS 寻址，可能是内部服务寻址；\n3. 单工/半双工/双工通信方式支持；\n\n---\n\n## 浏览器\n\n1. 说说浏览器和 Node 事件循环的区别\n\n微任务和宏任务在 Node 的执行顺序\n\nNode 10 及以前：\n\n执行完一个阶段（timers、I/O、poll 等）的任务\n就会去执行 nextTick 队列里面的内容\n然后再执行完微任务队列的内容\n\nNode 11 以后： 和浏览器的行为统一了，都是每执行完一个宏任务就会执行微任务队列。\n\n![Node的Event Loop](https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n```javascript\nfunction test() {\n  console.log(\"start\");\n  setTimeout(() => {\n    console.log(\"children2\");\n    Promise.resolve().then(() => {\n      console.log(\"children2-1\");\n    });\n  }, 0);\n  setTimeout(() => {\n    console.log(\"children3\");\n    Promise.resolve().then(() => {\n      console.log(\"children3-1\");\n    });\n  }, 0);\n  Promise.resolve().then(() => {\n    console.log(\"children1\");\n  });\n  console.log(\"end\");\n}\n\ntest();\n\n// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)\n// start\n// end\n// children1\n// children2\n// children3\n// children2-1\n// children3-1\n\n// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)\n// start\n// end\n// children1\n// children2\n// children2-1\n// children3\n// children3-1\n```\n\n2. 重绘与回流\n\n几何属性 样式变化会引起 重绘\n\n几何形状 位置变化引起 回流\n\n---\n\n### 前端内功\n\n1. 模块化理解；\n\n> 模块化是为了处理全局污染、隔离作用域、抽离公共代码等问题\n\n| 名称         | 特点                                                             |\n| ------------ | ---------------------------------------------------------------- |\n| `iife`       | 自执行 函数作用域                                                |\n| `amd`        | 浏览器端（requirejs） 依赖前置                                   |\n| `cmd`        | 浏览器端（seajs） 运行时加载依赖 后面也支持依赖前置              |\n| `commonjs`   | 浏览器、服务器通用 运行时加载 第一次运行加载，缓存值，值的浅拷贝 |\n| `es6 module` | 浏览器、服务器通用 静态编译，编译时输出接口 值的引用             |\n\n2. 工程化理解；\n3. 组件化理解;\n4. 性能优化；\n\n---\n\n### 框架\n\n1. React 中的 setState 何时是同步的，何时是异步的？\n\n在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理，生命周期函数等），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。\n\n**原因：** 在 React 的 setState 函数实现中，会根据一个变量`isBatchingUpdate`·判断是直接更新 this.state 还是放到队列中回头再说，而`isBatchingUpdates`默认是`false`，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。\n\n2. vue 父组件和子组件创建的生命周期顺序\n\n- 加载渲染过程 父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount->子 mounted->父 mounted\n\n- 子组件更新过程 父 beforeUpdate->子 beforeUpdate->子 updated->父 updated\n\n- 父组件更新过程 父 beforeUpdate->父 updated\n\n- 销毁过程 父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed\n\n---\n\n### CSS\n\n1. 介绍下 BFC 及其应用\n\nBFC 块级格式上下文， 是指一个独立的渲染区域或者说是一个隔离的独立容器。\n\n形成条件：\n\n1、浮动元素，float 除 none 以外的值；\n\n2、定位元素，position（absolute，fixed）；\n\n3、display 为以下其中之一的值 inline-block，table-cell，table-caption；\n\n4、overflow 除了 visible 以外的值（hidden，auto，scroll）；\n\n特点：\n\n1.内部的 Box 会在垂直方向上一个接一个的放置。\n\n2.垂直方向上的距离由 margin 决定，垂直外边距会重叠即两个盒子中间距离以 margin 最大的值决定；\n\n3.bfc 的区域不会与 float 的元素区域重叠。\n\n4.计算 bfc 的高度时，浮动元素也参与计算\n\n5.bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。\n\n参考：[CSS 中的 BFC 详解](https://www.cnblogs.com/chen-cong/p/7862832.html)\n","slug":"前端基础面试题整理","published":1,"updated":"2020-01-02T08:02:50.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556983h0025gu1pb8b3ylxc","content":"<h2><span id=\"js-基础\">js 基础</span></h2>\n<ul>\n<li>闭包</li>\n<li>作用域</li>\n<li>原型链</li>\n<li>变量提升</li>\n<li>函数参数值传递</li>\n<li>this 指向问题</li>\n<li>函数提升以及优先级问题</li>\n<li>new 操作符做了什么？</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype.showId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.id);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// new内部实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myNew</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"comment\">// 取得外部传入的构造器，默认第一个参数是构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Constructor = <span class=\"built_in\">Array</span>.prototype.shift.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 实现继承，实例可以访问构造器的属性</span></span><br><span class=\"line\">  o.__proto__ = Constructor.prototype;</span><br><span class=\"line\">  <span class=\"comment\">// 调用构造器，并改变其 this 指向到实例</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ret = Constructor.call(o, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> ret === <span class=\"string\">\"object\"</span> &amp;&amp; ret !== <span class=\"literal\">null</span> ? ret : obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = myNew(A, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用 ES5 实现一个继承（有哪些方式）</li>\n<li>0.2+0.1 不等于 0.3 问题（浮点数精度）</li>\n<li>堆、栈、队列是什么？都有什么区别？有什么应用？</li>\n<li>深拷贝、浅拷贝问题（immutable 是怎么实现的？）</li>\n<li>typed array 问题</li>\n<li>es6 箭头函数问题</li>\n<li>let var const 区别与原理</li>\n</ul>\n<ol>\n<li>var 存在变量提升，执行时已经完成声明与初始化，全局作用域|函数作用域；</li>\n<li>let const 不能重复定义，存在暂时性死区，没有变量提升，块作用域；</li>\n<li>var 在栈内存预分配空间，等执行时候再讲变量值存在空间里，let const 不会</li>\n</ol>\n<ul>\n<li>\n<p>什么是 iterator？for of 用过吗？</p>\n</li>\n<li>\n<p>call、apply、bind 区别，bind 怎么实现的？</p>\n</li>\n<li>\n<p>promise 实现，Promise.all 实现， Promise.race，Promise.finally 实现</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_Promise.all = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> aResult = []; <span class=\"comment\">//用于存放每次执行后返回结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _Promise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    next(); <span class=\"comment\">// 开始逐次执行数组中的函数(重要)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      arr[i].then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">        aResult.push(res); <span class=\"comment\">// 存储每次得到的结果</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == arr.length) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果函数数组中的函数都执行完，便resolve</span></span><br><span class=\"line\">          resolve(aResult);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> race = (_Promise.race = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">in</span> iterable) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> v = iterable[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> v === <span class=\"string\">\"object\"</span> &amp;&amp; <span class=\"keyword\">typeof</span> v.then === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">        v.then(resolve, reject);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(v);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">_Promise.finally = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> P = <span class=\"keyword\">this</span>.constructor; <span class=\"comment\">// 获取当前实例构造函数的引用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(</span><br><span class=\"line\">    value =&gt; P.resolve(callback()).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value),</span><br><span class=\"line\">    reason =&gt;</span><br><span class=\"line\">      P.resolve(callback()).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">200</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">100</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">race([p1, p2]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>caller、callee 了解吗？什么时候会用到？建议用吗？</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt;= <span class=\"number\">1</span> ? <span class=\"number\">1</span> : x * factorial(x - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// callee</span></span><br><span class=\"line\"><span class=\"comment\">// callee是arguments对象的一个属性，指向 arguments 对象的函数</span></span><br><span class=\"line\"><span class=\"comment\">// 利用callee</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt;= <span class=\"number\">1</span> ? <span class=\"number\">1</span> : x * <span class=\"built_in\">arguments</span>.callee(x - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\"><span class=\"comment\">// 函数对象的一个属性，指向调用当前函数的函数。比如 A() 调用 B()， 则在B()中 B.caller 指向A()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1 这个属性只有当函数在执行时才有用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2 如果在JavaScript程序中，函数是由顶层调用的，则返回null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(B.caller); <span class=\"comment\">// B</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  B(); <span class=\"comment\">// A</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>async await 知识点（await 的作用，async 返回的是什么）</li>\n</ul>\n<p>很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"async1 start\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"async1 end\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"async1 start\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve(async2()).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"async1 end\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Async/Await 如何通过同步的方式实现异步?</li>\n</ul>\n<p>Async/Await 就是一个自执行的 generate 函数。利用 generate 函数的特性把异步的代码写成“同步”的形式，generate 函数本身实现思想来源于单向链表。</p>\n<ul>\n<li>generator 又是什么？</li>\n</ul>\n<p>生成器 generator 函数执行时返回这个生成器的迭代对象，当这个迭代对象的 next 方法被调用时，遇到 yield 的位置停止，yield 后返回的值就是迭代器要返回的值。如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行），调用 next() （再启动）方法时，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">another</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">\"人月神话\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>* another(); <span class=\"comment\">// 移交执行权</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">yield</span> <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = <span class=\"keyword\">yield</span> a; <span class=\"comment\">// a='world' 是 next('world') 传参赋值给了上一个 yidle 'hello' 的左值</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> b; <span class=\"comment\">// b=！ 是 next('！') 传参赋值给了上一个 yidle a 的左值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = gen();</span><br><span class=\"line\">g.next(); <span class=\"comment\">// &#123;value: \"人月神话\", done: false&#125;</span></span><br><span class=\"line\">g.next(); <span class=\"comment\">// &#123;value: \"hello\", done: false&#125;</span></span><br><span class=\"line\">g.next(<span class=\"string\">\"world\"</span>); <span class=\"comment\">// &#123;value: \"world\", done: false&#125; 将 'world' 赋给上一条 yield 'hello' 的左值，即执行 a='world'，</span></span><br><span class=\"line\">g.next(<span class=\"string\">\"!\"</span>); <span class=\"comment\">// &#123;value: \"!\", done: false&#125; 将 '!' 赋给上一条 yield a 的左值，即执行 b='!'，返回 b</span></span><br><span class=\"line\">g.next(); <span class=\"comment\">// &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>v8 线程模型、event loop（async、promise、nextTick、setTimeout、- setImmediate 经典问题变着花样考）</p>\n</li>\n<li>\n<p>进程和线程是什么？有什么区别？</p>\n</li>\n<li>\n<p>v8 垃圾回收机制</p>\n</li>\n<li>\n<p>输入 URL，浏览器的执行过程又是怎么样的？（浏览器解析方式、顺序，async、- defer 等）</p>\n</li>\n<li>\n<p>了解前端模块化吗？有几种规范？（commonjs 和 es module 都是怎么实现- 的？有啥区别？）</p>\n</li>\n<li>\n<p>按需加载实现</p>\n</li>\n<li>\n<p>[‘1’, ‘2’, ‘3’].map(parseInt) parseInt(100, 2) = 4</p>\n</li>\n<li>\n<p>防抖节流</p>\n</li>\n</ul>\n<ol>\n<li>防抖\n<blockquote>\n<p>高频事件 n 秒内执行一次，如果 n 秒内再次触发，重新计时</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debonce</span>(<span class=\"params\">fn, time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    clearTimeout(timeout);</span><br><span class=\"line\">    timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;, time);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>节流\n<blockquote>\n<p>高频事件 n 秒内执行一次</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debonce</span>(<span class=\"params\">fn, time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> startTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nowTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nowTime - startTime &gt;= time) &#123;</span><br><span class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">      startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>Set WeaksSet 和 Map WeakMap 各自区别</p>\n<p>Set 无序类似数组的数据结构</p>\n<p>WeakSet</p>\n<ol>\n<li>只能是对象引用；</li>\n<li>未使用会被 GC 收集</li>\n</ol>\n<p>Map 字典结构，以<code>value:value</code>形式存储</p>\n<p>WeakMap</p>\n<ol>\n<li>建的对象引用只能是对象引用；</li>\n<li>未使用的建对象会被 GC 收集</li>\n</ol>\n</li>\n<li>\n<p>es5 和 es6 类的区别</p>\n<ol>\n<li>class 会提升，但不会赋值，会进入暂时性死区（TDZ）；</li>\n<li>class 内部默认启用严格模式；</li>\n<li>class 的所有方法、属性不能枚举；</li>\n<li>class 所有方法没有 prototype，也没有[[constructor]]，不能实例化；</li>\n<li>必须使用<code>new</code>来实例化；</li>\n<li>class 无法重写类名；</li>\n</ol>\n</li>\n<li>\n<p>es5 和 es6 的继承区别</p>\n<ol>\n<li>es5 的继承是先实例化子类，再通过父类构造函数修饰子类实例，而 es6 的继承是通过<code>super</code>方法先实例化父类，再通过子类构造函数修饰父类实例；</li>\n<li>es6 的子类可以通过<code>__proto__</code>找到父类，而 es5 中通过<code>__proto__</code>只能找到<code>Function.prototype</code></li>\n</ol>\n</li>\n<li>\n<p>箭头函数和普通函数区别</p>\n</li>\n</ul>\n<ol>\n<li>箭头函数本身没有 this，需要通过原型向上级对象查找，即 this 对象是指向定义是所在作用域的 this 对象（因此无法使用 call、apply、bind 绑定 this 值），普通函数指向调用时的对象；</li>\n<li>箭头函数没有 arguments，可以用 rest 参数代替；</li>\n<li>箭头函数不能使用 new 命令，</li>\n</ol>\n<ul>\n<li>因为没有 this，无法调用 call；</li>\n<li>没有 prototype</li>\n</ul>\n<ol start=\"4\">\n<li>箭头函数没有原型 prototype；</li>\n</ol>\n<hr>\n<h2><span id=\"网络\">网络</span></h2>\n<ul>\n<li>\n<p>http 1.0 1.1 2.0 协议特性与区别</p>\n<p><strong>http 1.0</strong></p>\n<ol>\n<li>无状态</li>\n</ol>\n<p>需要 cookie/session 做身份认证和登录</p>\n<ol start=\"2\">\n<li>无连接</li>\n</ol>\n<p>a. 每次连接结束都会关闭连接，再重新创建连接 tcp 三次连接与四次挥手，效率很低；</p>\n<p>b. 在上一个请求到达结束之前无法发送下一个请求；</p>\n<p><strong>http 1.1</strong></p>\n<ol>\n<li>长连接 keep-alive</li>\n<li>管道机制 不必等待上一个请求返回就能发送下一个请求，返回的结果还是按照顺序，但是为了保持响应顺序，还是存在队头阻塞问题；</li>\n<li>缓存 cache-control；</li>\n<li>断点传输</li>\n</ol>\n<p><strong>http 2.0</strong></p>\n<ol>\n<li>二进制分帧；</li>\n<li>多路复用 在共享 TCP 链接的基础上同时发送请求和响应；</li>\n<li>头部压缩；</li>\n<li>服务器推送；</li>\n</ol>\n</li>\n<li>\n<p>简单讲解一下 http2 的多路复用</p>\n</li>\n</ul>\n<p>http1.0 一个请求建立一个链接，请求结束就关闭，依次往复，可开启’keep-alive’，让链接不关闭复用</p>\n<p>http1.1 默认允许一个连接发送多个请求，浏览器为了控制资源一般控制在 6 个左右，虽然建立多个连接，但需要等待前一个请求结束，服务器才会响应后面的请求；</p>\n<p>http2 采用二进制传输数据，更高效，有两个非常重要的概念，帧和流，帧是最小数据单位，帧会标识属于哪个流，可以在一个连接中发送并行发送多个请求，避免了 1.1 中队头阻塞的问题，极大提高性能。</p>\n<ul>\n<li>TCP 三次握手和四次挥手的理解</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png\" alt=\"示意图\"></p>\n<p>TCP 三次握手：</p>\n<p>其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的 ACK 都会对这个 seq 进行加一来进行确认</p>\n<p>三次握手之所以是三次是保证 client 和 server 均让对方知道自己的接收和发送能力没问题而保证的最小次数，三次是最少的安全次数，两次不安全，四次浪费资源。</p>\n<p>四次挥手：</p>\n<p>TCP 是全双工信道，何为全双工就是客户端与服务端建立两条通道，</p>\n<p>通道 1:客户端的输出连接服务端的输入；</p>\n<p>通道 2:客户端的输入连接服务端的输出。</p>\n<p>两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：</p>\n<p>客户端：我要关闭输入通道了。 服务端：好的，你关闭吧，我这边也关闭这个通道。</p>\n<p>服务端：我也要关闭输入通道了。 客户端：好的你关闭吧，我也把这个通道关闭。</p>\n<ul>\n<li>rpc 协议和 tcp 协议的区别</li>\n</ul>\n<p>tcp</p>\n<ol>\n<li>tcp 协议需要 DNS 寻址；</li>\n<li>tcp 协议是单工通信；</li>\n</ol>\n<p>rpc</p>\n<ol>\n<li>二进制数据传输，更小的体积，更快编解码速率；</li>\n<li>不一定是 DNS 寻址，可能是内部服务寻址；</li>\n<li>单工/半双工/双工通信方式支持；</li>\n</ol>\n<hr>\n<h2><span id=\"浏览器\">浏览器</span></h2>\n<ol>\n<li>说说浏览器和 Node 事件循环的区别</li>\n</ol>\n<p>微任务和宏任务在 Node 的执行顺序</p>\n<p>Node 10 及以前：</p>\n<p>执行完一个阶段（timers、I/O、poll 等）的任务<br>\n就会去执行 nextTick 队列里面的内容<br>\n然后再执行完微任务队列的内容</p>\n<p>Node 11 以后： 和浏览器的行为统一了，都是每执行完一个宏任务就会执行微任务队列。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"Node的Event Loop\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"start\"</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children2\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children2-1\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children3\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children3-1\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children1\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"end\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)</span></span><br><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\"><span class=\"comment\">// end</span></span><br><span class=\"line\"><span class=\"comment\">// children1</span></span><br><span class=\"line\"><span class=\"comment\">// children2</span></span><br><span class=\"line\"><span class=\"comment\">// children3</span></span><br><span class=\"line\"><span class=\"comment\">// children2-1</span></span><br><span class=\"line\"><span class=\"comment\">// children3-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)</span></span><br><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\"><span class=\"comment\">// end</span></span><br><span class=\"line\"><span class=\"comment\">// children1</span></span><br><span class=\"line\"><span class=\"comment\">// children2</span></span><br><span class=\"line\"><span class=\"comment\">// children2-1</span></span><br><span class=\"line\"><span class=\"comment\">// children3</span></span><br><span class=\"line\"><span class=\"comment\">// children3-1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>重绘与回流</li>\n</ol>\n<p>几何属性 样式变化会引起 重绘</p>\n<p>几何形状 位置变化引起 回流</p>\n<hr>\n<h3><span id=\"前端内功\">前端内功</span></h3>\n<ol>\n<li>模块化理解；</li>\n</ol>\n<blockquote>\n<p>模块化是为了处理全局污染、隔离作用域、抽离公共代码等问题</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>iife</code></td>\n<td>自执行 函数作用域</td>\n</tr>\n<tr>\n<td><code>amd</code></td>\n<td>浏览器端（requirejs） 依赖前置</td>\n</tr>\n<tr>\n<td><code>cmd</code></td>\n<td>浏览器端（seajs） 运行时加载依赖 后面也支持依赖前置</td>\n</tr>\n<tr>\n<td><code>commonjs</code></td>\n<td>浏览器、服务器通用 运行时加载 第一次运行加载，缓存值，值的浅拷贝</td>\n</tr>\n<tr>\n<td><code>es6 module</code></td>\n<td>浏览器、服务器通用 静态编译，编译时输出接口 值的引用</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"2\">\n<li>工程化理解；</li>\n<li>组件化理解;</li>\n<li>性能优化；</li>\n</ol>\n<hr>\n<h3><span id=\"框架\">框架</span></h3>\n<ol>\n<li>React 中的 setState 何时是同步的，何时是异步的？</li>\n</ol>\n<p>在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理，生命周期函数等），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。</p>\n<p><strong>原因：</strong> 在 React 的 setState 函数实现中，会根据一个变量<code>isBatchingUpdate</code>·判断是直接更新 this.state 还是放到队列中回头再说，而<code>isBatchingUpdates</code>默认是<code>false</code>，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p>\n<ol start=\"2\">\n<li>vue 父组件和子组件创建的生命周期顺序</li>\n</ol>\n<ul>\n<li>\n<p>加载渲染过程 父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p>\n</li>\n<li>\n<p>子组件更新过程 父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p>\n</li>\n<li>\n<p>父组件更新过程 父 beforeUpdate-&gt;父 updated</p>\n</li>\n<li>\n<p>销毁过程 父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p>\n</li>\n</ul>\n<hr>\n<h3><span id=\"css\">CSS</span></h3>\n<ol>\n<li>介绍下 BFC 及其应用</li>\n</ol>\n<p>BFC 块级格式上下文， 是指一个独立的渲染区域或者说是一个隔离的独立容器。</p>\n<p>形成条件：</p>\n<p>1、浮动元素，float 除 none 以外的值；</p>\n<p>2、定位元素，position（absolute，fixed）；</p>\n<p>3、display 为以下其中之一的值 inline-block，table-cell，table-caption；</p>\n<p>4、overflow 除了 visible 以外的值（hidden，auto，scroll）；</p>\n<p>特点：</p>\n<p>1.内部的 Box 会在垂直方向上一个接一个的放置。</p>\n<p>2.垂直方向上的距离由 margin 决定，垂直外边距会重叠即两个盒子中间距离以 margin 最大的值决定；</p>\n<p>3.bfc 的区域不会与 float 的元素区域重叠。</p>\n<p>4.计算 bfc 的高度时，浮动元素也参与计算</p>\n<p>5.bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。</p>\n<p>参考：<a href=\"https://www.cnblogs.com/chen-cong/p/7862832.html\" target=\"_blank\" rel=\"noopener\">CSS 中的 BFC 详解</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>js 基础</h2>\n<ul>\n<li>闭包</li>\n<li>作用域</li>\n<li>原型链</li>\n<li>变量提升</li>\n<li>函数参数值传递</li>\n<li>this 指向问题</li>\n<li>函数提升以及优先级问题</li>\n<li>new 操作符做了什么？</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype.showId = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.id);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// new内部实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myNew</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">  <span class=\"comment\">// 取得外部传入的构造器，默认第一个参数是构造函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Constructor = <span class=\"built_in\">Array</span>.prototype.shift.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 实现继承，实例可以访问构造器的属性</span></span><br><span class=\"line\">  o.__proto__ = Constructor.prototype;</span><br><span class=\"line\">  <span class=\"comment\">// 调用构造器，并改变其 this 指向到实例</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ret = Constructor.call(o, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> ret === <span class=\"string\">\"object\"</span> &amp;&amp; ret !== <span class=\"literal\">null</span> ? ret : obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = myNew(A, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>用 ES5 实现一个继承（有哪些方式）</li>\n<li>0.2+0.1 不等于 0.3 问题（浮点数精度）</li>\n<li>堆、栈、队列是什么？都有什么区别？有什么应用？</li>\n<li>深拷贝、浅拷贝问题（immutable 是怎么实现的？）</li>\n<li>typed array 问题</li>\n<li>es6 箭头函数问题</li>\n<li>let var const 区别与原理</li>\n</ul>\n<ol>\n<li>var 存在变量提升，执行时已经完成声明与初始化，全局作用域|函数作用域；</li>\n<li>let const 不能重复定义，存在暂时性死区，没有变量提升，块作用域；</li>\n<li>var 在栈内存预分配空间，等执行时候再讲变量值存在空间里，let const 不会</li>\n</ol>\n<ul>\n<li>\n<p>什么是 iterator？for of 用过吗？</p>\n</li>\n<li>\n<p>call、apply、bind 区别，bind 怎么实现的？</p>\n</li>\n<li>\n<p>promise 实现，Promise.all 实现， Promise.race，Promise.finally 实现</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_Promise.all = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> aResult = []; <span class=\"comment\">//用于存放每次执行后返回结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> _Promise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    next(); <span class=\"comment\">// 开始逐次执行数组中的函数(重要)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      arr[i].then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">        aResult.push(res); <span class=\"comment\">// 存储每次得到的结果</span></span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == arr.length) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果函数数组中的函数都执行完，便resolve</span></span><br><span class=\"line\">          resolve(aResult);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> race = (_Promise.race = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">iterable</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">in</span> iterable) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> v = iterable[i];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> v === <span class=\"string\">\"object\"</span> &amp;&amp; <span class=\"keyword\">typeof</span> v.then === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">        v.then(resolve, reject);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(v);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">_Promise.finally = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> P = <span class=\"keyword\">this</span>.constructor; <span class=\"comment\">// 获取当前实例构造函数的引用</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(</span><br><span class=\"line\">    value =&gt; P.resolve(callback()).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> value),</span><br><span class=\"line\">    reason =&gt;</span><br><span class=\"line\">      P.resolve(callback()).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">200</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">100</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">race([p1, p2]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>caller、callee 了解吗？什么时候会用到？建议用吗？</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt;= <span class=\"number\">1</span> ? <span class=\"number\">1</span> : x * factorial(x - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// callee</span></span><br><span class=\"line\"><span class=\"comment\">// callee是arguments对象的一个属性，指向 arguments 对象的函数</span></span><br><span class=\"line\"><span class=\"comment\">// 利用callee</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt;= <span class=\"number\">1</span> ? <span class=\"number\">1</span> : x * <span class=\"built_in\">arguments</span>.callee(x - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// caller</span></span><br><span class=\"line\"><span class=\"comment\">// 函数对象的一个属性，指向调用当前函数的函数。比如 A() 调用 B()， 则在B()中 B.caller 指向A()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1 这个属性只有当函数在执行时才有用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2 如果在JavaScript程序中，函数是由顶层调用的，则返回null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">B</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(B.caller); <span class=\"comment\">// B</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  B(); <span class=\"comment\">// A</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>async await 知识点（await 的作用，async 返回的是什么）</li>\n</ul>\n<p>很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"async1 start\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"async1 end\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"async1 start\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve(async2()).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"async1 end\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Async/Await 如何通过同步的方式实现异步?</li>\n</ul>\n<p>Async/Await 就是一个自执行的 generate 函数。利用 generate 函数的特性把异步的代码写成“同步”的形式，generate 函数本身实现思想来源于单向链表。</p>\n<ul>\n<li>generator 又是什么？</li>\n</ul>\n<p>生成器 generator 函数执行时返回这个生成器的迭代对象，当这个迭代对象的 next 方法被调用时，遇到 yield 的位置停止，yield 后返回的值就是迭代器要返回的值。如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行），调用 next() （再启动）方法时，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">another</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">\"人月神话\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>* another(); <span class=\"comment\">// 移交执行权</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">yield</span> <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = <span class=\"keyword\">yield</span> a; <span class=\"comment\">// a='world' 是 next('world') 传参赋值给了上一个 yidle 'hello' 的左值</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> b; <span class=\"comment\">// b=！ 是 next('！') 传参赋值给了上一个 yidle a 的左值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = gen();</span><br><span class=\"line\">g.next(); <span class=\"comment\">// &#123;value: \"人月神话\", done: false&#125;</span></span><br><span class=\"line\">g.next(); <span class=\"comment\">// &#123;value: \"hello\", done: false&#125;</span></span><br><span class=\"line\">g.next(<span class=\"string\">\"world\"</span>); <span class=\"comment\">// &#123;value: \"world\", done: false&#125; 将 'world' 赋给上一条 yield 'hello' 的左值，即执行 a='world'，</span></span><br><span class=\"line\">g.next(<span class=\"string\">\"!\"</span>); <span class=\"comment\">// &#123;value: \"!\", done: false&#125; 将 '!' 赋给上一条 yield a 的左值，即执行 b='!'，返回 b</span></span><br><span class=\"line\">g.next(); <span class=\"comment\">// &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>v8 线程模型、event loop（async、promise、nextTick、setTimeout、- setImmediate 经典问题变着花样考）</p>\n</li>\n<li>\n<p>进程和线程是什么？有什么区别？</p>\n</li>\n<li>\n<p>v8 垃圾回收机制</p>\n</li>\n<li>\n<p>输入 URL，浏览器的执行过程又是怎么样的？（浏览器解析方式、顺序，async、- defer 等）</p>\n</li>\n<li>\n<p>了解前端模块化吗？有几种规范？（commonjs 和 es module 都是怎么实现- 的？有啥区别？）</p>\n</li>\n<li>\n<p>按需加载实现</p>\n</li>\n<li>\n<p>[‘1’, ‘2’, ‘3’].map(parseInt) parseInt(100, 2) = 4</p>\n</li>\n<li>\n<p>防抖节流</p>\n</li>\n</ul>\n<ol>\n<li>防抖\n<blockquote>\n<p>高频事件 n 秒内执行一次，如果 n 秒内再次触发，重新计时</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debonce</span>(<span class=\"params\">fn, time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    clearTimeout(timeout);</span><br><span class=\"line\">    timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;, time);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>节流\n<blockquote>\n<p>高频事件 n 秒内执行一次</p>\n</blockquote>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debonce</span>(<span class=\"params\">fn, time</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> startTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> nowTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nowTime - startTime &gt;= time) &#123;</span><br><span class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">      startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>Set WeaksSet 和 Map WeakMap 各自区别</p>\n<p>Set 无序类似数组的数据结构</p>\n<p>WeakSet</p>\n<ol>\n<li>只能是对象引用；</li>\n<li>未使用会被 GC 收集</li>\n</ol>\n<p>Map 字典结构，以<code>value:value</code>形式存储</p>\n<p>WeakMap</p>\n<ol>\n<li>建的对象引用只能是对象引用；</li>\n<li>未使用的建对象会被 GC 收集</li>\n</ol>\n</li>\n<li>\n<p>es5 和 es6 类的区别</p>\n<ol>\n<li>class 会提升，但不会赋值，会进入暂时性死区（TDZ）；</li>\n<li>class 内部默认启用严格模式；</li>\n<li>class 的所有方法、属性不能枚举；</li>\n<li>class 所有方法没有 prototype，也没有[[constructor]]，不能实例化；</li>\n<li>必须使用<code>new</code>来实例化；</li>\n<li>class 无法重写类名；</li>\n</ol>\n</li>\n<li>\n<p>es5 和 es6 的继承区别</p>\n<ol>\n<li>es5 的继承是先实例化子类，再通过父类构造函数修饰子类实例，而 es6 的继承是通过<code>super</code>方法先实例化父类，再通过子类构造函数修饰父类实例；</li>\n<li>es6 的子类可以通过<code>__proto__</code>找到父类，而 es5 中通过<code>__proto__</code>只能找到<code>Function.prototype</code></li>\n</ol>\n</li>\n<li>\n<p>箭头函数和普通函数区别</p>\n</li>\n</ul>\n<ol>\n<li>箭头函数本身没有 this，需要通过原型向上级对象查找，即 this 对象是指向定义是所在作用域的 this 对象（因此无法使用 call、apply、bind 绑定 this 值），普通函数指向调用时的对象；</li>\n<li>箭头函数没有 arguments，可以用 rest 参数代替；</li>\n<li>箭头函数不能使用 new 命令，</li>\n</ol>\n<ul>\n<li>因为没有 this，无法调用 call；</li>\n<li>没有 prototype</li>\n</ul>\n<ol start=\"4\">\n<li>箭头函数没有原型 prototype；</li>\n</ol>\n<hr>\n<h2>网络</h2>\n<ul>\n<li>\n<p>http 1.0 1.1 2.0 协议特性与区别</p>\n<p><strong>http 1.0</strong></p>\n<ol>\n<li>无状态</li>\n</ol>\n<p>需要 cookie/session 做身份认证和登录</p>\n<ol start=\"2\">\n<li>无连接</li>\n</ol>\n<p>a. 每次连接结束都会关闭连接，再重新创建连接 tcp 三次连接与四次挥手，效率很低；</p>\n<p>b. 在上一个请求到达结束之前无法发送下一个请求；</p>\n<p><strong>http 1.1</strong></p>\n<ol>\n<li>长连接 keep-alive</li>\n<li>管道机制 不必等待上一个请求返回就能发送下一个请求，返回的结果还是按照顺序，但是为了保持响应顺序，还是存在队头阻塞问题；</li>\n<li>缓存 cache-control；</li>\n<li>断点传输</li>\n</ol>\n<p><strong>http 2.0</strong></p>\n<ol>\n<li>二进制分帧；</li>\n<li>多路复用 在共享 TCP 链接的基础上同时发送请求和响应；</li>\n<li>头部压缩；</li>\n<li>服务器推送；</li>\n</ol>\n</li>\n<li>\n<p>简单讲解一下 http2 的多路复用</p>\n</li>\n</ul>\n<p>http1.0 一个请求建立一个链接，请求结束就关闭，依次往复，可开启’keep-alive’，让链接不关闭复用</p>\n<p>http1.1 默认允许一个连接发送多个请求，浏览器为了控制资源一般控制在 6 个左右，虽然建立多个连接，但需要等待前一个请求结束，服务器才会响应后面的请求；</p>\n<p>http2 采用二进制传输数据，更高效，有两个非常重要的概念，帧和流，帧是最小数据单位，帧会标识属于哪个流，可以在一个连接中发送并行发送多个请求，避免了 1.1 中队头阻塞的问题，极大提高性能。</p>\n<ul>\n<li>TCP 三次握手和四次挥手的理解</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/34148615/53062591-3d846300-34fc-11e9-8d0f-4063d9ff3398.png\" alt=\"示意图\"></p>\n<p>TCP 三次握手：</p>\n<p>其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的 ACK 都会对这个 seq 进行加一来进行确认</p>\n<p>三次握手之所以是三次是保证 client 和 server 均让对方知道自己的接收和发送能力没问题而保证的最小次数，三次是最少的安全次数，两次不安全，四次浪费资源。</p>\n<p>四次挥手：</p>\n<p>TCP 是全双工信道，何为全双工就是客户端与服务端建立两条通道，</p>\n<p>通道 1:客户端的输出连接服务端的输入；</p>\n<p>通道 2:客户端的输入连接服务端的输出。</p>\n<p>两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：</p>\n<p>客户端：我要关闭输入通道了。 服务端：好的，你关闭吧，我这边也关闭这个通道。</p>\n<p>服务端：我也要关闭输入通道了。 客户端：好的你关闭吧，我也把这个通道关闭。</p>\n<ul>\n<li>rpc 协议和 tcp 协议的区别</li>\n</ul>\n<p>tcp</p>\n<ol>\n<li>tcp 协议需要 DNS 寻址；</li>\n<li>tcp 协议是单工通信；</li>\n</ol>\n<p>rpc</p>\n<ol>\n<li>二进制数据传输，更小的体积，更快编解码速率；</li>\n<li>不一定是 DNS 寻址，可能是内部服务寻址；</li>\n<li>单工/半双工/双工通信方式支持；</li>\n</ol>\n<hr>\n<h2>浏览器</h2>\n<ol>\n<li>说说浏览器和 Node 事件循环的区别</li>\n</ol>\n<p>微任务和宏任务在 Node 的执行顺序</p>\n<p>Node 10 及以前：</p>\n<p>执行完一个阶段（timers、I/O、poll 等）的任务<br>\n就会去执行 nextTick 队列里面的内容<br>\n然后再执行完微任务队列的内容</p>\n<p>Node 11 以后： 和浏览器的行为统一了，都是每执行完一个宏任务就会执行微任务队列。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"Node的Event Loop\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"start\"</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children2\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children2-1\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children3\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children3-1\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"children1\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"end\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上代码在node11以下版本的执行结果(先执行所有的宏任务，再执行微任务)</span></span><br><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\"><span class=\"comment\">// end</span></span><br><span class=\"line\"><span class=\"comment\">// children1</span></span><br><span class=\"line\"><span class=\"comment\">// children2</span></span><br><span class=\"line\"><span class=\"comment\">// children3</span></span><br><span class=\"line\"><span class=\"comment\">// children2-1</span></span><br><span class=\"line\"><span class=\"comment\">// children3-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以上代码在node11及浏览器的执行结果(顺序执行宏任务和微任务)</span></span><br><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\"><span class=\"comment\">// end</span></span><br><span class=\"line\"><span class=\"comment\">// children1</span></span><br><span class=\"line\"><span class=\"comment\">// children2</span></span><br><span class=\"line\"><span class=\"comment\">// children2-1</span></span><br><span class=\"line\"><span class=\"comment\">// children3</span></span><br><span class=\"line\"><span class=\"comment\">// children3-1</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>重绘与回流</li>\n</ol>\n<p>几何属性 样式变化会引起 重绘</p>\n<p>几何形状 位置变化引起 回流</p>\n<hr>\n<h3>前端内功</h3>\n<ol>\n<li>模块化理解；</li>\n</ol>\n<blockquote>\n<p>模块化是为了处理全局污染、隔离作用域、抽离公共代码等问题</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>iife</code></td>\n<td>自执行 函数作用域</td>\n</tr>\n<tr>\n<td><code>amd</code></td>\n<td>浏览器端（requirejs） 依赖前置</td>\n</tr>\n<tr>\n<td><code>cmd</code></td>\n<td>浏览器端（seajs） 运行时加载依赖 后面也支持依赖前置</td>\n</tr>\n<tr>\n<td><code>commonjs</code></td>\n<td>浏览器、服务器通用 运行时加载 第一次运行加载，缓存值，值的浅拷贝</td>\n</tr>\n<tr>\n<td><code>es6 module</code></td>\n<td>浏览器、服务器通用 静态编译，编译时输出接口 值的引用</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"2\">\n<li>工程化理解；</li>\n<li>组件化理解;</li>\n<li>性能优化；</li>\n</ol>\n<hr>\n<h3>框架</h3>\n<ol>\n<li>React 中的 setState 何时是同步的，何时是异步的？</li>\n</ol>\n<p>在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理，生命周期函数等），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。</p>\n<p><strong>原因：</strong> 在 React 的 setState 函数实现中，会根据一个变量<code>isBatchingUpdate</code>·判断是直接更新 this.state 还是放到队列中回头再说，而<code>isBatchingUpdates</code>默认是<code>false</code>，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p>\n<ol start=\"2\">\n<li>vue 父组件和子组件创建的生命周期顺序</li>\n</ol>\n<ul>\n<li>\n<p>加载渲染过程 父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p>\n</li>\n<li>\n<p>子组件更新过程 父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p>\n</li>\n<li>\n<p>父组件更新过程 父 beforeUpdate-&gt;父 updated</p>\n</li>\n<li>\n<p>销毁过程 父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p>\n</li>\n</ul>\n<hr>\n<h3>CSS</h3>\n<ol>\n<li>介绍下 BFC 及其应用</li>\n</ol>\n<p>BFC 块级格式上下文， 是指一个独立的渲染区域或者说是一个隔离的独立容器。</p>\n<p>形成条件：</p>\n<p>1、浮动元素，float 除 none 以外的值；</p>\n<p>2、定位元素，position（absolute，fixed）；</p>\n<p>3、display 为以下其中之一的值 inline-block，table-cell，table-caption；</p>\n<p>4、overflow 除了 visible 以外的值（hidden，auto，scroll）；</p>\n<p>特点：</p>\n<p>1.内部的 Box 会在垂直方向上一个接一个的放置。</p>\n<p>2.垂直方向上的距离由 margin 决定，垂直外边距会重叠即两个盒子中间距离以 margin 最大的值决定；</p>\n<p>3.bfc 的区域不会与 float 的元素区域重叠。</p>\n<p>4.计算 bfc 的高度时，浮动元素也参与计算</p>\n<p>5.bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。</p>\n<p>参考：<a href=\"https://www.cnblogs.com/chen-cong/p/7862832.html\" target=\"_blank\" rel=\"noopener\">CSS 中的 BFC 详解</a></p>\n"},{"title":"基于sentry的异常捕获平台","catalog":true,"date":"2019-11-05T06:53:56.000Z","subtitle":null,"header-img":null,"_content":"\n## sentry 介绍\n\nsentry 是一个开源的实时错误追踪系统，可以帮助开发者实时监控和统计异常信息。比如客户端和 h5 的 crash 的信息，有了 sentry 以后我们就可以第一时间来处理和解决系统的问题，就不需要过度地依赖用户反馈来定位问题了。sentry 主要包括服务端和客户端 SDK,对于系统集成这一块，sentry 提供了主流语言和框架的支持，包括 java、android、ios、javascript 等都提供官方了 SDK,同时 sentry 提供了一些比较流行的服务的集成插件，比如 jira、github、gitlab、pagerduty、dingding 等。\n\n## sentry 架构\n\nsentry 的架构分位客户端和服务端，而且 sentry 官方提供不同语言和框架的集成 SDK。我们选择相应的 SDK 后就可以将错误信息实时上报到 sentry 的服务端。而 sentry 的服务端分为 web、cron、worker 这几个部分，主要工作流程为，应用程序或者客户端发生错误后将错误信息上报给 web 模块，web 模块处理后放入消息队列(rocketmq)或 redis 内存队列，worker 从队列中消费数据进行处理并存储 postgresql 中，如果配置相应报警规则根据配置报警工具进行报警。下图为 sentry 工作示意图：\n\n<img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2019/png/484053/1571292721535-807923a9-6f5a-4059-bfe5-b00c206dbe5e.png\" data-raw-src=\"https://cdn.nlark.com/yuque/0/2019/png/484053/1571292721535-807923a9-6f5a-4059-bfe5-b00c206dbe5e.png\" class=\"image lake-drag-image\" alt=\"image.png\" title=\"image.png\" style=\"visibility: visible; width: 746px; height: 283px;\">\n\n## sentry 安装\n\nSentry 本身是基于 Django 开发的，而且也依赖到其他的如 Postgresql、 Redis 等组件，所以一般有两种途径进行安装：通过 Docker 或用 Python 搭建。官网下分别有以下的两个介绍：\nDocker 安装 https://docs.sentry.io/server/installation/docker/\nPython 安装 https://docs.sentry.io/server/installation/python/\n我们采用的是 docker 安装方式，如果是采用 docker 安装的方式，那么还有一种更加便捷的方式，那么就是采用 docker-compose 了，具体安装步骤如下：\n\n注意，通过 Docker 本地搭建 Sentry 的时候，需要 docker 版本为 1.10.0 以上，docker-compose 版本为 1.17.0 以上，同时要求最低有 3GB 的可用内存。\n\n1.  安装 docker、docker-compose\n\n这里采用 yum 安装，具体安装步骤如下：\n\n```shell\n#安装一些必要的系统工具\nyum install -y yum-utils device-mapper-persistent-data lvm2\n#添加软件源信息\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n#更新 yum 缓存\nyum makecache fast\n#安装 Docker-ce\nyum -y install docker-ce\n#启动 Docker 后台服务\nsystemctl start docker\n#下载docket-compose\ncurl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n#修改权限\nchmod +x /usr/local/bin/docker-compose\n```\n\n2. 安装 sentry\n\n其实 sentry 社区了提供一个基于 docker-composed 的开源项目，通过它我们可以一键部署 sentry。首先我克隆该项目：\n\n```shell\ngit clone https://github.com/getsentry/onpremise.git\ncd onpremise\n-rw-r--r-- 1 root root  2017 Oct 15 22:27 config.yml\n-rw-r--r-- 1 root root  1427 Oct 16 16:27 docker-compose.yml\n-rw-r--r-- 1 root root    43 Oct 15 18:05 Dockerfile\n-rwxr-xr-x 1 root root  2766 Oct 15 18:05 install.sh\n-rw-r--r-- 1 root root 11356 Oct 15 18:05 LICENSE\n-rw-r--r-- 1 root root   548 Oct 15 18:05 Makefile\n-rw-r--r-- 1 root root  2167 Oct 15 18:05 README.md\n-rw-r--r-- 1 root root    42 Oct 16 17:24 requirements.txt\n-rw-r--r-- 1 root root 11493 Oct 15 18:05 sentry.conf.py\n-rwxr-xr-x 1 root root  1020 Oct 15 18:05 test.sh\n```\n\n如果并没有特殊要求或者额外的组件配置的话，可以直接运行 ./install.sh 将 sentry 及其依赖都通过 docker 安装。由于我们 redis 和 postgresql 是采用阿里云托管的，所以我们不能采用这种方式进行安装。具体步骤如下：\n\n2.1 创建环境变量文件\n\n```shell\n#新建环境变量文件.env,根据.env.example拷贝一份即可\ncp .env.example .env\n```\n\n2.2 修改 docker-compose.xml 文件\n\n删除 redis、postgresql 等镜像依赖，并配置容器的时区，具体配置内容如下：\n\n```shell\nversion: '3.4'\n\nx-defaults: &defaults\n  restart: unless-stopped\n  build:\n    context: .\n#  depends_on:\n#    - redis\n#    - postgres\n#    - memcached\n#    - smtp\n  env_file: .env\n# 时区配置\n  environment:\n    - TZ=Asia/Shanghai\n#    SENTRY_MEMCACHED_HOST: memcached\n#    SENTRY_REDIS_HOST: redis\n#    SENTRY_POSTGRES_HOST: postgres\n#    SENTRY_EMAIL_HOST: smtp\n  volumes:\n    - sentry-data:/var/lib/sentry/files\n    # 时区配置\n    - /etc/localtime:/etc/localtime:ro\n    - /etc/timezone:/etc/timezone:ro\n\nservices:\n#  smtp:\n#    restart: unless-stopped\n#    image: tianon/exim4\n\n\"docker-compose.yml\" [readonly] 72L, 1432C                                                                                                         1,1           Top\n#  memcached:\n#    restart: unless-stopped\n#    image: memcached:1.5-alpine\n\n#  redis:\n#    restart: unless-stopped\n#    image: redis:3.2-alpine\n\n#  postgres:\n#    restart: unless-stopped\n#    image: postgres:9.5\n#    volumes:\n#      - sentry-postgres:/var/lib/postgresql/data\n\n  web:\n    <<: *defaults\n    #web端口号，默认为9000\n    ports:\n      - '9000:9000'\n\n  cron:\n    <<: *defaults\n    command: run cron\n\n# work为了保证高可用，起了两个节点\n  worker1:\n    <<: *defaults\n    command: run worker\n\n  worker2:\n    <<: *defaults\n    command: run worker\n\nvolumes:\n    sentry-data:\n      external: true\n    sentry-postgres:\n      external: true\n```\n\n2.3 构建 docker-compose 镜像\n\n```shell\ndocker-compose build --pull\n```\n\n2.4 生成 sentry 密钥\n\nsentry 是用于 sentry 容器内部免密通信，并把这个值配置到 .env 的 SENTRY_SECRET_KEY key 中\n\n```shell\ndocker-compose run --rm web config generate-secret-key\n```\n\n2.5 配置 redis 和 postgresql 连接信息\n\n在.env 文件中添加以下配置：\n\n```shell\n#秘钥，由于容器内部免密通信\nSENTRY_SECRET_KEY=\n#pg host\nSENTRY_POSTGRES_HOST=\n#pg port\nSENTRY_POSTGRES_PORT=\n#pg 数据库名称\nSENTRY_DB_NAME=\n#pg 用户\nSENTRY_DB_USER=\n#pg 用户密码\nSENTRY_DB_PASSWORD=\n#redis host\nSENTRY_REDIS_HOST=\n#redis passowrd\nSENTRY_REDIS_PASSWORD=\n#redis 端口号\nSENTRY_REDIS_PORT=\n#redis 数据名\nSENTRY_REDIS_DB=\n```\n\n注意：这里 postgresql 官方建议采用 9.5 和 9.6，由于阿里云没有这两个版本，所以我们采用 10 的版本。目前运行没有发现任何问题。redis 需要 3.2 以上版本，并且 sentry 不支持集群版的 redis。我们采用的 4.0 单机主从版。进行 Web 服务迁移\n\n2.6 进行 Web 服务迁移\n\n主要是初始化表结构和建用户等操作。具体操作执行以下命令：\n\n```shell\ndocker-compose run --rm web upgrade\n```\n\n注意：注意在这个过程中命令行会提示你是否创建超级用户，如果确定，则输入邮箱和密码。如果没有创建用户，可以在升级结束后可以手动创建一个用户，具体执行以下命令：\n\n```shell\ndocker-compose run --rm web createuser\n```\n\n2.7 运行 sentry\n\n```shell\n#启动容器\ndocker-compose up -d\n\n```\n\n3. 配置邮件信息\n\n当 sentry 采集到了异常信息就可以通过邮件的方式，发送给指定的处理人。而且这些配置信息是无法在 web console 中修改的，具体操作是在.env 环境变量文件，添加以下配置项：\n\n```shell\n#邮件的发送地址\nENTRY_SERVER_EMAIL=\n#smtp服务器主机地址\nSENTRY_EMAIL_HOST=\n#smtp 服务器用户\nSENTRY_EMAIL_USER=\n#smtp服务器密码\nSENTRY_EMAIL_PASSWORD=\n# smtp服务器端口,注意如果采用qq的企业邮箱，这里不是foxmail中配置的465，而是25（巨坑）。\nSENTRY_EMAIL_PORT=\n#是否使用TLS，默认为false\nSENTRY_EMAIL_USE_TLS=\n```\n\n重启 sentry 服务\n\n```shell\ndocker-compose build\ndocker-compose run --rm web upgrade\ndocker-compose up -d\n```\n\n4. 集成钉钉及时通讯工具\n\n我们公司使用钉钉作为内部通讯和工作辅助工作，平时工作中大家都可以通过 pc 端和 app 端第一时间查看到消息，并且报警对即时性要求比较高，所以集成钉钉很有必要，下面介绍一下 sentry 集成钉钉的步骤。\n\n1. 安装 sentry-dingding 插件，sentry 的强大和可扩展是它很受欢迎的原因。目前开源社区相关 sentry 的插件也是很丰富的,sentry 钉钉插件 github 地址：https://github.com/anshengme/sentry-dingding。\n   sentry 为了方便我们安装插件，提供了一个 requirements.txt 文件。我们只需要将我们现需要安装的插件配置进去，重新构建镜像就可以完成安装和集成。修改 requirements.txt：\n\n```shell\n#添加钉钉插件\nsentry-dingding~=0.0.3\n```\n\n2. 重启 sentry 服务\n\n```shell\ndocker-compose build\ndocker-compose run --rm web upgrade\ndocker-compose up -d\n```\n\n5. 集成 LDAP\n\n跟集成钉钉一样，sentry 社区也提供了集成插件，sentry ldap 插件地址：https://github.com/Banno/getsentry-ldap-auth。 1.安装 ldap 插件，这里跟安装钉钉插件有一定区别，钉钉是直接配置在 requirements.txt 中就可以了。而 ldap 插件如果采用这样的方式可能会报错，原因是 ldap 插件需要依赖 python-ldap 相关环节，所以我们需要在先安装这些依赖。具体安装步骤如下：\n\n1. 安装 sentry ldap 插件\n   修改 DokerFile 文件，在文件添加以下内容：\n\n```shell\n#切换成国内的源，提高下载速度。但是貌似没啥用，下载还是很慢，后面在看看是什么原因\nRUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list\nRUN apt-get clean\n#更新源，这一步很重要不能省略，否则后面会下载失败\nRUN apt-get update\n#安装python-ldap相关依赖\nRUN apt-get install -y libsasl2-dev python-dev libldap2-dev libssl-dev\n#安装sentry-ldap插件\nRUN pip install sentry-ldap-auth\n```\n\n2. 配置 ldap 插件\n   在 sentry.conf.py 文件添加以下配置项:\n\n```python\nimport ldap\nfrom django_auth_ldap.config import LDAPSearch, GroupOfUniqueNamesType\n#设置ldap服务器地址\nAUTH_LDAP_SERVER_URI = 'ldap://secad.poizon.com:3489'\n#ldap管理员账号\nAUTH_LDAP_BIND_DN = 'xxx'\n#ldap管理员密码\nAUTH_LDAP_BIND_PASSWORD = 'xxxxx'\n#ldap搜索路径，这里配置成技术部，需要注意如果有中文需要转成unicode的格式\nOU=unicode('OU=技术部,OU=识装,DC=sz,DC=du', 'utf8')\n\nAUTH_LDAP_USER_SEARCH = LDAPSearch(\n    OU,\n    ldap.SCOPE_SUBTREE,\n    '(mail=%(user)s)',\n)\n\nAUTH_LDAP_GROUP_SEARCH = LDAPSearch(\n    '',\n    ldap.SCOPE_SUBTREE,\n    '(objectClass=groupOfUniqueNames)'\n)\n\nAUTH_LDAP_GROUP_TYPE = GroupOfUniqueNamesType()\nAUTH_LDAP_REQUIRE_GROUP = None\nAUTH_LDAP_DENY_GROUP = None\n\nAUTH_LDAP_USER_ATTR_MAP = {\n    'name': 'cn',\n    'email': 'mail'\n}\n\nAUTH_LDAP_FIND_GROUP_PERMS = False\nAUTH_LDAP_CACHE_GROUPS = True\nAUTH_LDAP_GROUP_CACHE_TIMEOUT = 3600\n\n#如果ldap认证成功，默认给用户加入poizon组织中\nAUTH_LDAP_DEFAULT_SENTRY_ORGANIZATION = u'poizon'\n#默认的用户的角色是member\nAUTH_LDAP_SENTRY_ORGANIZATION_ROLE_TYPE = 'member'\n#开通相应的操作权限\nAUTH_LDAP_SENTRY_ORGANIZATION_GLOBAL_ACCESS = True\n#指定sentry的username字段名称\nAUTH_LDAP_SENTRY_USERNAME_FIELD = 'uid'\n#指定sentry的角色和ldap的角色的绑定关系，这里我们暂时不设置\nAUTH_LDAP_SENTRY_GROUP_ROLE_MAPPING = {}\n#扩展登录方式，采用Ldap的方式进行认证\nAUTHENTICATION_BACKENDS = AUTHENTICATION_BACKENDS + (\n    'sentry_ldap_auth.backend.SentryLdapBackend',\n)\n\n#LOG配置\nimport logging\nlogger = logging.getLogger('django_auth_ldap')\nlogger.addHandler(logging.StreamHandler())\nlogger.setLevel('DEBUG')\n```\n","source":"_posts/基于sentry的异常捕获平台.md","raw":"---\ntitle: 基于sentry的异常捕获平台\ncatalog: true\ndate: 2019-11-05 14:53:56\nsubtitle:\nheader-img:\ntags:\n---\n\n## sentry 介绍\n\nsentry 是一个开源的实时错误追踪系统，可以帮助开发者实时监控和统计异常信息。比如客户端和 h5 的 crash 的信息，有了 sentry 以后我们就可以第一时间来处理和解决系统的问题，就不需要过度地依赖用户反馈来定位问题了。sentry 主要包括服务端和客户端 SDK,对于系统集成这一块，sentry 提供了主流语言和框架的支持，包括 java、android、ios、javascript 等都提供官方了 SDK,同时 sentry 提供了一些比较流行的服务的集成插件，比如 jira、github、gitlab、pagerduty、dingding 等。\n\n## sentry 架构\n\nsentry 的架构分位客户端和服务端，而且 sentry 官方提供不同语言和框架的集成 SDK。我们选择相应的 SDK 后就可以将错误信息实时上报到 sentry 的服务端。而 sentry 的服务端分为 web、cron、worker 这几个部分，主要工作流程为，应用程序或者客户端发生错误后将错误信息上报给 web 模块，web 模块处理后放入消息队列(rocketmq)或 redis 内存队列，worker 从队列中消费数据进行处理并存储 postgresql 中，如果配置相应报警规则根据配置报警工具进行报警。下图为 sentry 工作示意图：\n\n<img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2019/png/484053/1571292721535-807923a9-6f5a-4059-bfe5-b00c206dbe5e.png\" data-raw-src=\"https://cdn.nlark.com/yuque/0/2019/png/484053/1571292721535-807923a9-6f5a-4059-bfe5-b00c206dbe5e.png\" class=\"image lake-drag-image\" alt=\"image.png\" title=\"image.png\" style=\"visibility: visible; width: 746px; height: 283px;\">\n\n## sentry 安装\n\nSentry 本身是基于 Django 开发的，而且也依赖到其他的如 Postgresql、 Redis 等组件，所以一般有两种途径进行安装：通过 Docker 或用 Python 搭建。官网下分别有以下的两个介绍：\nDocker 安装 https://docs.sentry.io/server/installation/docker/\nPython 安装 https://docs.sentry.io/server/installation/python/\n我们采用的是 docker 安装方式，如果是采用 docker 安装的方式，那么还有一种更加便捷的方式，那么就是采用 docker-compose 了，具体安装步骤如下：\n\n注意，通过 Docker 本地搭建 Sentry 的时候，需要 docker 版本为 1.10.0 以上，docker-compose 版本为 1.17.0 以上，同时要求最低有 3GB 的可用内存。\n\n1.  安装 docker、docker-compose\n\n这里采用 yum 安装，具体安装步骤如下：\n\n```shell\n#安装一些必要的系统工具\nyum install -y yum-utils device-mapper-persistent-data lvm2\n#添加软件源信息\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n#更新 yum 缓存\nyum makecache fast\n#安装 Docker-ce\nyum -y install docker-ce\n#启动 Docker 后台服务\nsystemctl start docker\n#下载docket-compose\ncurl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n#修改权限\nchmod +x /usr/local/bin/docker-compose\n```\n\n2. 安装 sentry\n\n其实 sentry 社区了提供一个基于 docker-composed 的开源项目，通过它我们可以一键部署 sentry。首先我克隆该项目：\n\n```shell\ngit clone https://github.com/getsentry/onpremise.git\ncd onpremise\n-rw-r--r-- 1 root root  2017 Oct 15 22:27 config.yml\n-rw-r--r-- 1 root root  1427 Oct 16 16:27 docker-compose.yml\n-rw-r--r-- 1 root root    43 Oct 15 18:05 Dockerfile\n-rwxr-xr-x 1 root root  2766 Oct 15 18:05 install.sh\n-rw-r--r-- 1 root root 11356 Oct 15 18:05 LICENSE\n-rw-r--r-- 1 root root   548 Oct 15 18:05 Makefile\n-rw-r--r-- 1 root root  2167 Oct 15 18:05 README.md\n-rw-r--r-- 1 root root    42 Oct 16 17:24 requirements.txt\n-rw-r--r-- 1 root root 11493 Oct 15 18:05 sentry.conf.py\n-rwxr-xr-x 1 root root  1020 Oct 15 18:05 test.sh\n```\n\n如果并没有特殊要求或者额外的组件配置的话，可以直接运行 ./install.sh 将 sentry 及其依赖都通过 docker 安装。由于我们 redis 和 postgresql 是采用阿里云托管的，所以我们不能采用这种方式进行安装。具体步骤如下：\n\n2.1 创建环境变量文件\n\n```shell\n#新建环境变量文件.env,根据.env.example拷贝一份即可\ncp .env.example .env\n```\n\n2.2 修改 docker-compose.xml 文件\n\n删除 redis、postgresql 等镜像依赖，并配置容器的时区，具体配置内容如下：\n\n```shell\nversion: '3.4'\n\nx-defaults: &defaults\n  restart: unless-stopped\n  build:\n    context: .\n#  depends_on:\n#    - redis\n#    - postgres\n#    - memcached\n#    - smtp\n  env_file: .env\n# 时区配置\n  environment:\n    - TZ=Asia/Shanghai\n#    SENTRY_MEMCACHED_HOST: memcached\n#    SENTRY_REDIS_HOST: redis\n#    SENTRY_POSTGRES_HOST: postgres\n#    SENTRY_EMAIL_HOST: smtp\n  volumes:\n    - sentry-data:/var/lib/sentry/files\n    # 时区配置\n    - /etc/localtime:/etc/localtime:ro\n    - /etc/timezone:/etc/timezone:ro\n\nservices:\n#  smtp:\n#    restart: unless-stopped\n#    image: tianon/exim4\n\n\"docker-compose.yml\" [readonly] 72L, 1432C                                                                                                         1,1           Top\n#  memcached:\n#    restart: unless-stopped\n#    image: memcached:1.5-alpine\n\n#  redis:\n#    restart: unless-stopped\n#    image: redis:3.2-alpine\n\n#  postgres:\n#    restart: unless-stopped\n#    image: postgres:9.5\n#    volumes:\n#      - sentry-postgres:/var/lib/postgresql/data\n\n  web:\n    <<: *defaults\n    #web端口号，默认为9000\n    ports:\n      - '9000:9000'\n\n  cron:\n    <<: *defaults\n    command: run cron\n\n# work为了保证高可用，起了两个节点\n  worker1:\n    <<: *defaults\n    command: run worker\n\n  worker2:\n    <<: *defaults\n    command: run worker\n\nvolumes:\n    sentry-data:\n      external: true\n    sentry-postgres:\n      external: true\n```\n\n2.3 构建 docker-compose 镜像\n\n```shell\ndocker-compose build --pull\n```\n\n2.4 生成 sentry 密钥\n\nsentry 是用于 sentry 容器内部免密通信，并把这个值配置到 .env 的 SENTRY_SECRET_KEY key 中\n\n```shell\ndocker-compose run --rm web config generate-secret-key\n```\n\n2.5 配置 redis 和 postgresql 连接信息\n\n在.env 文件中添加以下配置：\n\n```shell\n#秘钥，由于容器内部免密通信\nSENTRY_SECRET_KEY=\n#pg host\nSENTRY_POSTGRES_HOST=\n#pg port\nSENTRY_POSTGRES_PORT=\n#pg 数据库名称\nSENTRY_DB_NAME=\n#pg 用户\nSENTRY_DB_USER=\n#pg 用户密码\nSENTRY_DB_PASSWORD=\n#redis host\nSENTRY_REDIS_HOST=\n#redis passowrd\nSENTRY_REDIS_PASSWORD=\n#redis 端口号\nSENTRY_REDIS_PORT=\n#redis 数据名\nSENTRY_REDIS_DB=\n```\n\n注意：这里 postgresql 官方建议采用 9.5 和 9.6，由于阿里云没有这两个版本，所以我们采用 10 的版本。目前运行没有发现任何问题。redis 需要 3.2 以上版本，并且 sentry 不支持集群版的 redis。我们采用的 4.0 单机主从版。进行 Web 服务迁移\n\n2.6 进行 Web 服务迁移\n\n主要是初始化表结构和建用户等操作。具体操作执行以下命令：\n\n```shell\ndocker-compose run --rm web upgrade\n```\n\n注意：注意在这个过程中命令行会提示你是否创建超级用户，如果确定，则输入邮箱和密码。如果没有创建用户，可以在升级结束后可以手动创建一个用户，具体执行以下命令：\n\n```shell\ndocker-compose run --rm web createuser\n```\n\n2.7 运行 sentry\n\n```shell\n#启动容器\ndocker-compose up -d\n\n```\n\n3. 配置邮件信息\n\n当 sentry 采集到了异常信息就可以通过邮件的方式，发送给指定的处理人。而且这些配置信息是无法在 web console 中修改的，具体操作是在.env 环境变量文件，添加以下配置项：\n\n```shell\n#邮件的发送地址\nENTRY_SERVER_EMAIL=\n#smtp服务器主机地址\nSENTRY_EMAIL_HOST=\n#smtp 服务器用户\nSENTRY_EMAIL_USER=\n#smtp服务器密码\nSENTRY_EMAIL_PASSWORD=\n# smtp服务器端口,注意如果采用qq的企业邮箱，这里不是foxmail中配置的465，而是25（巨坑）。\nSENTRY_EMAIL_PORT=\n#是否使用TLS，默认为false\nSENTRY_EMAIL_USE_TLS=\n```\n\n重启 sentry 服务\n\n```shell\ndocker-compose build\ndocker-compose run --rm web upgrade\ndocker-compose up -d\n```\n\n4. 集成钉钉及时通讯工具\n\n我们公司使用钉钉作为内部通讯和工作辅助工作，平时工作中大家都可以通过 pc 端和 app 端第一时间查看到消息，并且报警对即时性要求比较高，所以集成钉钉很有必要，下面介绍一下 sentry 集成钉钉的步骤。\n\n1. 安装 sentry-dingding 插件，sentry 的强大和可扩展是它很受欢迎的原因。目前开源社区相关 sentry 的插件也是很丰富的,sentry 钉钉插件 github 地址：https://github.com/anshengme/sentry-dingding。\n   sentry 为了方便我们安装插件，提供了一个 requirements.txt 文件。我们只需要将我们现需要安装的插件配置进去，重新构建镜像就可以完成安装和集成。修改 requirements.txt：\n\n```shell\n#添加钉钉插件\nsentry-dingding~=0.0.3\n```\n\n2. 重启 sentry 服务\n\n```shell\ndocker-compose build\ndocker-compose run --rm web upgrade\ndocker-compose up -d\n```\n\n5. 集成 LDAP\n\n跟集成钉钉一样，sentry 社区也提供了集成插件，sentry ldap 插件地址：https://github.com/Banno/getsentry-ldap-auth。 1.安装 ldap 插件，这里跟安装钉钉插件有一定区别，钉钉是直接配置在 requirements.txt 中就可以了。而 ldap 插件如果采用这样的方式可能会报错，原因是 ldap 插件需要依赖 python-ldap 相关环节，所以我们需要在先安装这些依赖。具体安装步骤如下：\n\n1. 安装 sentry ldap 插件\n   修改 DokerFile 文件，在文件添加以下内容：\n\n```shell\n#切换成国内的源，提高下载速度。但是貌似没啥用，下载还是很慢，后面在看看是什么原因\nRUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list\nRUN apt-get clean\n#更新源，这一步很重要不能省略，否则后面会下载失败\nRUN apt-get update\n#安装python-ldap相关依赖\nRUN apt-get install -y libsasl2-dev python-dev libldap2-dev libssl-dev\n#安装sentry-ldap插件\nRUN pip install sentry-ldap-auth\n```\n\n2. 配置 ldap 插件\n   在 sentry.conf.py 文件添加以下配置项:\n\n```python\nimport ldap\nfrom django_auth_ldap.config import LDAPSearch, GroupOfUniqueNamesType\n#设置ldap服务器地址\nAUTH_LDAP_SERVER_URI = 'ldap://secad.poizon.com:3489'\n#ldap管理员账号\nAUTH_LDAP_BIND_DN = 'xxx'\n#ldap管理员密码\nAUTH_LDAP_BIND_PASSWORD = 'xxxxx'\n#ldap搜索路径，这里配置成技术部，需要注意如果有中文需要转成unicode的格式\nOU=unicode('OU=技术部,OU=识装,DC=sz,DC=du', 'utf8')\n\nAUTH_LDAP_USER_SEARCH = LDAPSearch(\n    OU,\n    ldap.SCOPE_SUBTREE,\n    '(mail=%(user)s)',\n)\n\nAUTH_LDAP_GROUP_SEARCH = LDAPSearch(\n    '',\n    ldap.SCOPE_SUBTREE,\n    '(objectClass=groupOfUniqueNames)'\n)\n\nAUTH_LDAP_GROUP_TYPE = GroupOfUniqueNamesType()\nAUTH_LDAP_REQUIRE_GROUP = None\nAUTH_LDAP_DENY_GROUP = None\n\nAUTH_LDAP_USER_ATTR_MAP = {\n    'name': 'cn',\n    'email': 'mail'\n}\n\nAUTH_LDAP_FIND_GROUP_PERMS = False\nAUTH_LDAP_CACHE_GROUPS = True\nAUTH_LDAP_GROUP_CACHE_TIMEOUT = 3600\n\n#如果ldap认证成功，默认给用户加入poizon组织中\nAUTH_LDAP_DEFAULT_SENTRY_ORGANIZATION = u'poizon'\n#默认的用户的角色是member\nAUTH_LDAP_SENTRY_ORGANIZATION_ROLE_TYPE = 'member'\n#开通相应的操作权限\nAUTH_LDAP_SENTRY_ORGANIZATION_GLOBAL_ACCESS = True\n#指定sentry的username字段名称\nAUTH_LDAP_SENTRY_USERNAME_FIELD = 'uid'\n#指定sentry的角色和ldap的角色的绑定关系，这里我们暂时不设置\nAUTH_LDAP_SENTRY_GROUP_ROLE_MAPPING = {}\n#扩展登录方式，采用Ldap的方式进行认证\nAUTHENTICATION_BACKENDS = AUTHENTICATION_BACKENDS + (\n    'sentry_ldap_auth.backend.SentryLdapBackend',\n)\n\n#LOG配置\nimport logging\nlogger = logging.getLogger('django_auth_ldap')\nlogger.addHandler(logging.StreamHandler())\nlogger.setLevel('DEBUG')\n```\n","slug":"基于sentry的异常捕获平台","published":1,"updated":"2019-12-24T01:36:23.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck556983i0027gu1p51w8ukht","content":"<h2><span id=\"sentry-介绍\">sentry 介绍</span></h2>\n<p>sentry 是一个开源的实时错误追踪系统，可以帮助开发者实时监控和统计异常信息。比如客户端和 h5 的 crash 的信息，有了 sentry 以后我们就可以第一时间来处理和解决系统的问题，就不需要过度地依赖用户反馈来定位问题了。sentry 主要包括服务端和客户端 SDK,对于系统集成这一块，sentry 提供了主流语言和框架的支持，包括 java、android、ios、javascript 等都提供官方了 SDK,同时 sentry 提供了一些比较流行的服务的集成插件，比如 jira、github、gitlab、pagerduty、dingding 等。</p>\n<h2><span id=\"sentry-架构\">sentry 架构</span></h2>\n<p>sentry 的架构分位客户端和服务端，而且 sentry 官方提供不同语言和框架的集成 SDK。我们选择相应的 SDK 后就可以将错误信息实时上报到 sentry 的服务端。而 sentry 的服务端分为 web、cron、worker 这几个部分，主要工作流程为，应用程序或者客户端发生错误后将错误信息上报给 web 模块，web 模块处理后放入消息队列(rocketmq)或 redis 内存队列，worker 从队列中消费数据进行处理并存储 postgresql 中，如果配置相应报警规则根据配置报警工具进行报警。下图为 sentry 工作示意图：</p>\n<img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2019/png/484053/1571292721535-807923a9-6f5a-4059-bfe5-b00c206dbe5e.png\" data-raw-src=\"https://cdn.nlark.com/yuque/0/2019/png/484053/1571292721535-807923a9-6f5a-4059-bfe5-b00c206dbe5e.png\" class=\"image lake-drag-image\" alt=\"image.png\" title=\"image.png\" style=\"visibility: visible; width: 746px; height: 283px;\">\n<h2><span id=\"sentry-安装\">sentry 安装</span></h2>\n<p>Sentry 本身是基于 Django 开发的，而且也依赖到其他的如 Postgresql、 Redis 等组件，所以一般有两种途径进行安装：通过 Docker 或用 Python 搭建。官网下分别有以下的两个介绍：<br>\nDocker 安装 <a href=\"https://docs.sentry.io/server/installation/docker/\" target=\"_blank\" rel=\"noopener\">https://docs.sentry.io/server/installation/docker/</a><br>\nPython 安装 <a href=\"https://docs.sentry.io/server/installation/python/\" target=\"_blank\" rel=\"noopener\">https://docs.sentry.io/server/installation/python/</a><br>\n我们采用的是 docker 安装方式，如果是采用 docker 安装的方式，那么还有一种更加便捷的方式，那么就是采用 docker-compose 了，具体安装步骤如下：</p>\n<p>注意，通过 Docker 本地搭建 Sentry 的时候，需要 docker 版本为 1.10.0 以上，docker-compose 版本为 1.17.0 以上，同时要求最低有 3GB 的可用内存。</p>\n<ol>\n<li>安装 docker、docker-compose</li>\n</ol>\n<p>这里采用 yum 安装，具体安装步骤如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>安装一些必要的系统工具</span><br><span class=\"line\">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"><span class=\"meta\">#</span>添加软件源信息</span><br><span class=\"line\">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\"><span class=\"meta\">#</span>更新 yum 缓存</span><br><span class=\"line\">yum makecache fast</span><br><span class=\"line\"><span class=\"meta\">#</span>安装 Docker-ce</span><br><span class=\"line\">yum -y install docker-ce</span><br><span class=\"line\"><span class=\"meta\">#</span>启动 Docker 后台服务</span><br><span class=\"line\">systemctl start docker</span><br><span class=\"line\"><span class=\"meta\">#</span>下载docket-compose</span><br><span class=\"line\">curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"meta\">#</span>修改权限</span><br><span class=\"line\">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>安装 sentry</li>\n</ol>\n<p>其实 sentry 社区了提供一个基于 docker-composed 的开源项目，通过它我们可以一键部署 sentry。首先我克隆该项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/getsentry/onpremise.git</span><br><span class=\"line\">cd onpremise</span><br><span class=\"line\">-rw-r--r-- 1 root root  2017 Oct 15 22:27 config.yml</span><br><span class=\"line\">-rw-r--r-- 1 root root  1427 Oct 16 16:27 docker-compose.yml</span><br><span class=\"line\">-rw-r--r-- 1 root root    43 Oct 15 18:05 Dockerfile</span><br><span class=\"line\">-rwxr-xr-x 1 root root  2766 Oct 15 18:05 install.sh</span><br><span class=\"line\">-rw-r--r-- 1 root root 11356 Oct 15 18:05 LICENSE</span><br><span class=\"line\">-rw-r--r-- 1 root root   548 Oct 15 18:05 Makefile</span><br><span class=\"line\">-rw-r--r-- 1 root root  2167 Oct 15 18:05 README.md</span><br><span class=\"line\">-rw-r--r-- 1 root root    42 Oct 16 17:24 requirements.txt</span><br><span class=\"line\">-rw-r--r-- 1 root root 11493 Oct 15 18:05 sentry.conf.py</span><br><span class=\"line\">-rwxr-xr-x 1 root root  1020 Oct 15 18:05 test.sh</span><br></pre></td></tr></table></figure>\n<p>如果并没有特殊要求或者额外的组件配置的话，可以直接运行 ./install.sh 将 sentry 及其依赖都通过 docker 安装。由于我们 redis 和 postgresql 是采用阿里云托管的，所以我们不能采用这种方式进行安装。具体步骤如下：</p>\n<p>2.1 创建环境变量文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>新建环境变量文件.env,根据.env.example拷贝一份即可</span><br><span class=\"line\">cp .env.example .env</span><br></pre></td></tr></table></figure>\n<p>2.2 修改 docker-compose.xml 文件</p>\n<p>删除 redis、postgresql 等镜像依赖，并配置容器的时区，具体配置内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: '3.4'</span><br><span class=\"line\"></span><br><span class=\"line\">x-defaults: &amp;defaults</span><br><span class=\"line\">  restart: unless-stopped</span><br><span class=\"line\">  build:</span><br><span class=\"line\">    context: .</span><br><span class=\"line\"><span class=\"meta\">#</span>  depends_on:</span><br><span class=\"line\"><span class=\"meta\">#</span>    - redis</span><br><span class=\"line\"><span class=\"meta\">#</span>    - postgres</span><br><span class=\"line\"><span class=\"meta\">#</span>    - memcached</span><br><span class=\"line\"><span class=\"meta\">#</span>    - smtp</span><br><span class=\"line\">  env_file: .env</span><br><span class=\"line\"><span class=\"meta\">#</span> 时区配置</span><br><span class=\"line\">  environment:</span><br><span class=\"line\">    - TZ=Asia/Shanghai</span><br><span class=\"line\"><span class=\"meta\">#</span>    SENTRY_MEMCACHED_HOST: memcached</span><br><span class=\"line\"><span class=\"meta\">#</span>    SENTRY_REDIS_HOST: redis</span><br><span class=\"line\"><span class=\"meta\">#</span>    SENTRY_POSTGRES_HOST: postgres</span><br><span class=\"line\"><span class=\"meta\">#</span>    SENTRY_EMAIL_HOST: smtp</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - sentry-data:/var/lib/sentry/files</span><br><span class=\"line\">    # 时区配置</span><br><span class=\"line\">    - /etc/localtime:/etc/localtime:ro</span><br><span class=\"line\">    - /etc/timezone:/etc/timezone:ro</span><br><span class=\"line\"></span><br><span class=\"line\">services:</span><br><span class=\"line\"><span class=\"meta\">#</span>  smtp:</span><br><span class=\"line\"><span class=\"meta\">#</span>    restart: unless-stopped</span><br><span class=\"line\"><span class=\"meta\">#</span>    image: tianon/exim4</span><br><span class=\"line\"></span><br><span class=\"line\">\"docker-compose.yml\" [readonly] 72L, 1432C                                                                                                         1,1           Top</span><br><span class=\"line\"><span class=\"meta\">#</span>  memcached:</span><br><span class=\"line\"><span class=\"meta\">#</span>    restart: unless-stopped</span><br><span class=\"line\"><span class=\"meta\">#</span>    image: memcached:1.5-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span>  redis:</span><br><span class=\"line\"><span class=\"meta\">#</span>    restart: unless-stopped</span><br><span class=\"line\"><span class=\"meta\">#</span>    image: redis:3.2-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span>  postgres:</span><br><span class=\"line\"><span class=\"meta\">#</span>    restart: unless-stopped</span><br><span class=\"line\"><span class=\"meta\">#</span>    image: postgres:9.5</span><br><span class=\"line\"><span class=\"meta\">#</span>    volumes:</span><br><span class=\"line\"><span class=\"meta\">#</span>      - sentry-postgres:/var/lib/postgresql/data</span><br><span class=\"line\"></span><br><span class=\"line\">  web:</span><br><span class=\"line\">    &lt;&lt;: *defaults</span><br><span class=\"line\">    #web端口号，默认为9000</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - '9000:9000'</span><br><span class=\"line\"></span><br><span class=\"line\">  cron:</span><br><span class=\"line\">    &lt;&lt;: *defaults</span><br><span class=\"line\">    command: run cron</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> work为了保证高可用，起了两个节点</span><br><span class=\"line\">  worker1:</span><br><span class=\"line\">    &lt;&lt;: *defaults</span><br><span class=\"line\">    command: run worker</span><br><span class=\"line\"></span><br><span class=\"line\">  worker2:</span><br><span class=\"line\">    &lt;&lt;: *defaults</span><br><span class=\"line\">    command: run worker</span><br><span class=\"line\"></span><br><span class=\"line\">volumes:</span><br><span class=\"line\">    sentry-data:</span><br><span class=\"line\">      external: true</span><br><span class=\"line\">    sentry-postgres:</span><br><span class=\"line\">      external: true</span><br></pre></td></tr></table></figure>\n<p>2.3 构建 docker-compose 镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose build --pull</span><br></pre></td></tr></table></figure>\n<p>2.4 生成 sentry 密钥</p>\n<p>sentry 是用于 sentry 容器内部免密通信，并把这个值配置到 .env 的 SENTRY_SECRET_KEY key 中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose run --rm web config generate-secret-key</span><br></pre></td></tr></table></figure>\n<p>2.5 配置 redis 和 postgresql 连接信息</p>\n<p>在.env 文件中添加以下配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>秘钥，由于容器内部免密通信</span><br><span class=\"line\">SENTRY_SECRET_KEY=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg host</span><br><span class=\"line\">SENTRY_POSTGRES_HOST=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg port</span><br><span class=\"line\">SENTRY_POSTGRES_PORT=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg 数据库名称</span><br><span class=\"line\">SENTRY_DB_NAME=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg 用户</span><br><span class=\"line\">SENTRY_DB_USER=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg 用户密码</span><br><span class=\"line\">SENTRY_DB_PASSWORD=</span><br><span class=\"line\"><span class=\"meta\">#</span>redis host</span><br><span class=\"line\">SENTRY_REDIS_HOST=</span><br><span class=\"line\"><span class=\"meta\">#</span>redis passowrd</span><br><span class=\"line\">SENTRY_REDIS_PASSWORD=</span><br><span class=\"line\"><span class=\"meta\">#</span>redis 端口号</span><br><span class=\"line\">SENTRY_REDIS_PORT=</span><br><span class=\"line\"><span class=\"meta\">#</span>redis 数据名</span><br><span class=\"line\">SENTRY_REDIS_DB=</span><br></pre></td></tr></table></figure>\n<p>注意：这里 postgresql 官方建议采用 9.5 和 9.6，由于阿里云没有这两个版本，所以我们采用 10 的版本。目前运行没有发现任何问题。redis 需要 3.2 以上版本，并且 sentry 不支持集群版的 redis。我们采用的 4.0 单机主从版。进行 Web 服务迁移</p>\n<p>2.6 进行 Web 服务迁移</p>\n<p>主要是初始化表结构和建用户等操作。具体操作执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose run --rm web upgrade</span><br></pre></td></tr></table></figure>\n<p>注意：注意在这个过程中命令行会提示你是否创建超级用户，如果确定，则输入邮箱和密码。如果没有创建用户，可以在升级结束后可以手动创建一个用户，具体执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose run --rm web createuser</span><br></pre></td></tr></table></figure>\n<p>2.7 运行 sentry</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>启动容器</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>配置邮件信息</li>\n</ol>\n<p>当 sentry 采集到了异常信息就可以通过邮件的方式，发送给指定的处理人。而且这些配置信息是无法在 web console 中修改的，具体操作是在.env 环境变量文件，添加以下配置项：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>邮件的发送地址</span><br><span class=\"line\">ENTRY_SERVER_EMAIL=</span><br><span class=\"line\"><span class=\"meta\">#</span>smtp服务器主机地址</span><br><span class=\"line\">SENTRY_EMAIL_HOST=</span><br><span class=\"line\"><span class=\"meta\">#</span>smtp 服务器用户</span><br><span class=\"line\">SENTRY_EMAIL_USER=</span><br><span class=\"line\"><span class=\"meta\">#</span>smtp服务器密码</span><br><span class=\"line\">SENTRY_EMAIL_PASSWORD=</span><br><span class=\"line\"><span class=\"meta\">#</span> smtp服务器端口,注意如果采用qq的企业邮箱，这里不是foxmail中配置的465，而是25（巨坑）。</span><br><span class=\"line\">SENTRY_EMAIL_PORT=</span><br><span class=\"line\"><span class=\"meta\">#</span>是否使用TLS，默认为false</span><br><span class=\"line\">SENTRY_EMAIL_USE_TLS=</span><br></pre></td></tr></table></figure>\n<p>重启 sentry 服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose build</span><br><span class=\"line\">docker-compose run --rm web upgrade</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>集成钉钉及时通讯工具</li>\n</ol>\n<p>我们公司使用钉钉作为内部通讯和工作辅助工作，平时工作中大家都可以通过 pc 端和 app 端第一时间查看到消息，并且报警对即时性要求比较高，所以集成钉钉很有必要，下面介绍一下 sentry 集成钉钉的步骤。</p>\n<ol>\n<li>安装 sentry-dingding 插件，sentry 的强大和可扩展是它很受欢迎的原因。目前开源社区相关 sentry 的插件也是很丰富的,sentry 钉钉插件 github 地址：<a href=\"https://github.com/anshengme/sentry-dingding%E3%80%82\" target=\"_blank\" rel=\"noopener\">https://github.com/anshengme/sentry-dingding。</a><br>\nsentry 为了方便我们安装插件，提供了一个 requirements.txt 文件。我们只需要将我们现需要安装的插件配置进去，重新构建镜像就可以完成安装和集成。修改 requirements.txt：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>添加钉钉插件</span><br><span class=\"line\">sentry-dingding~=0.0.3</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>重启 sentry 服务</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose build</span><br><span class=\"line\">docker-compose run --rm web upgrade</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>集成 LDAP</li>\n</ol>\n<p>跟集成钉钉一样，sentry 社区也提供了集成插件，sentry ldap 插件地址：<a href=\"https://github.com/Banno/getsentry-ldap-auth%E3%80%82\" target=\"_blank\" rel=\"noopener\">https://github.com/Banno/getsentry-ldap-auth。</a> 1.安装 ldap 插件，这里跟安装钉钉插件有一定区别，钉钉是直接配置在 requirements.txt 中就可以了。而 ldap 插件如果采用这样的方式可能会报错，原因是 ldap 插件需要依赖 python-ldap 相关环节，所以我们需要在先安装这些依赖。具体安装步骤如下：</p>\n<ol>\n<li>安装 sentry ldap 插件<br>\n修改 DokerFile 文件，在文件添加以下内容：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>切换成国内的源，提高下载速度。但是貌似没啥用，下载还是很慢，后面在看看是什么原因</span><br><span class=\"line\">RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class=\"line\">RUN apt-get clean</span><br><span class=\"line\"><span class=\"meta\">#</span>更新源，这一步很重要不能省略，否则后面会下载失败</span><br><span class=\"line\">RUN apt-get update</span><br><span class=\"line\"><span class=\"meta\">#</span>安装python-ldap相关依赖</span><br><span class=\"line\">RUN apt-get install -y libsasl2-dev python-dev libldap2-dev libssl-dev</span><br><span class=\"line\"><span class=\"meta\">#</span>安装sentry-ldap插件</span><br><span class=\"line\">RUN pip install sentry-ldap-auth</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>配置 ldap 插件<br>\n在 <a href=\"http://sentry.conf.py\" target=\"_blank\" rel=\"noopener\">sentry.conf.py</a> 文件添加以下配置项:</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ldap</span><br><span class=\"line\"><span class=\"keyword\">from</span> django_auth_ldap.config <span class=\"keyword\">import</span> LDAPSearch, GroupOfUniqueNamesType</span><br><span class=\"line\"><span class=\"comment\">#设置ldap服务器地址</span></span><br><span class=\"line\">AUTH_LDAP_SERVER_URI = <span class=\"string\">'ldap://secad.poizon.com:3489'</span></span><br><span class=\"line\"><span class=\"comment\">#ldap管理员账号</span></span><br><span class=\"line\">AUTH_LDAP_BIND_DN = <span class=\"string\">'xxx'</span></span><br><span class=\"line\"><span class=\"comment\">#ldap管理员密码</span></span><br><span class=\"line\">AUTH_LDAP_BIND_PASSWORD = <span class=\"string\">'xxxxx'</span></span><br><span class=\"line\"><span class=\"comment\">#ldap搜索路径，这里配置成技术部，需要注意如果有中文需要转成unicode的格式</span></span><br><span class=\"line\">OU=unicode(<span class=\"string\">'OU=技术部,OU=识装,DC=sz,DC=du'</span>, <span class=\"string\">'utf8'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_USER_SEARCH = LDAPSearch(</span><br><span class=\"line\">    OU,</span><br><span class=\"line\">    ldap.SCOPE_SUBTREE,</span><br><span class=\"line\">    <span class=\"string\">'(mail=%(user)s)'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_GROUP_SEARCH = LDAPSearch(</span><br><span class=\"line\">    <span class=\"string\">''</span>,</span><br><span class=\"line\">    ldap.SCOPE_SUBTREE,</span><br><span class=\"line\">    <span class=\"string\">'(objectClass=groupOfUniqueNames)'</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_GROUP_TYPE = GroupOfUniqueNamesType()</span><br><span class=\"line\">AUTH_LDAP_REQUIRE_GROUP = <span class=\"literal\">None</span></span><br><span class=\"line\">AUTH_LDAP_DENY_GROUP = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_USER_ATTR_MAP = &#123;</span><br><span class=\"line\">    <span class=\"string\">'name'</span>: <span class=\"string\">'cn'</span>,</span><br><span class=\"line\">    <span class=\"string\">'email'</span>: <span class=\"string\">'mail'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_FIND_GROUP_PERMS = <span class=\"literal\">False</span></span><br><span class=\"line\">AUTH_LDAP_CACHE_GROUPS = <span class=\"literal\">True</span></span><br><span class=\"line\">AUTH_LDAP_GROUP_CACHE_TIMEOUT = <span class=\"number\">3600</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果ldap认证成功，默认给用户加入poizon组织中</span></span><br><span class=\"line\">AUTH_LDAP_DEFAULT_SENTRY_ORGANIZATION = <span class=\"string\">u'poizon'</span></span><br><span class=\"line\"><span class=\"comment\">#默认的用户的角色是member</span></span><br><span class=\"line\">AUTH_LDAP_SENTRY_ORGANIZATION_ROLE_TYPE = <span class=\"string\">'member'</span></span><br><span class=\"line\"><span class=\"comment\">#开通相应的操作权限</span></span><br><span class=\"line\">AUTH_LDAP_SENTRY_ORGANIZATION_GLOBAL_ACCESS = <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\">#指定sentry的username字段名称</span></span><br><span class=\"line\">AUTH_LDAP_SENTRY_USERNAME_FIELD = <span class=\"string\">'uid'</span></span><br><span class=\"line\"><span class=\"comment\">#指定sentry的角色和ldap的角色的绑定关系，这里我们暂时不设置</span></span><br><span class=\"line\">AUTH_LDAP_SENTRY_GROUP_ROLE_MAPPING = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">#扩展登录方式，采用Ldap的方式进行认证</span></span><br><span class=\"line\">AUTHENTICATION_BACKENDS = AUTHENTICATION_BACKENDS + (</span><br><span class=\"line\">    <span class=\"string\">'sentry_ldap_auth.backend.SentryLdapBackend'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#LOG配置</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\">logger = logging.getLogger(<span class=\"string\">'django_auth_ldap'</span>)</span><br><span class=\"line\">logger.addHandler(logging.StreamHandler())</span><br><span class=\"line\">logger.setLevel(<span class=\"string\">'DEBUG'</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2>sentry 介绍</h2>\n<p>sentry 是一个开源的实时错误追踪系统，可以帮助开发者实时监控和统计异常信息。比如客户端和 h5 的 crash 的信息，有了 sentry 以后我们就可以第一时间来处理和解决系统的问题，就不需要过度地依赖用户反馈来定位问题了。sentry 主要包括服务端和客户端 SDK,对于系统集成这一块，sentry 提供了主流语言和框架的支持，包括 java、android、ios、javascript 等都提供官方了 SDK,同时 sentry 提供了一些比较流行的服务的集成插件，比如 jira、github、gitlab、pagerduty、dingding 等。</p>\n<h2>sentry 架构</h2>\n<p>sentry 的架构分位客户端和服务端，而且 sentry 官方提供不同语言和框架的集成 SDK。我们选择相应的 SDK 后就可以将错误信息实时上报到 sentry 的服务端。而 sentry 的服务端分为 web、cron、worker 这几个部分，主要工作流程为，应用程序或者客户端发生错误后将错误信息上报给 web 模块，web 模块处理后放入消息队列(rocketmq)或 redis 内存队列，worker 从队列中消费数据进行处理并存储 postgresql 中，如果配置相应报警规则根据配置报警工具进行报警。下图为 sentry 工作示意图：</p>\n<img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2019/png/484053/1571292721535-807923a9-6f5a-4059-bfe5-b00c206dbe5e.png\" data-raw-src=\"https://cdn.nlark.com/yuque/0/2019/png/484053/1571292721535-807923a9-6f5a-4059-bfe5-b00c206dbe5e.png\" class=\"image lake-drag-image\" alt=\"image.png\" title=\"image.png\" style=\"visibility: visible; width: 746px; height: 283px;\">\n<h2>sentry 安装</h2>\n<p>Sentry 本身是基于 Django 开发的，而且也依赖到其他的如 Postgresql、 Redis 等组件，所以一般有两种途径进行安装：通过 Docker 或用 Python 搭建。官网下分别有以下的两个介绍：<br>\nDocker 安装 <a href=\"https://docs.sentry.io/server/installation/docker/\" target=\"_blank\" rel=\"noopener\">https://docs.sentry.io/server/installation/docker/</a><br>\nPython 安装 <a href=\"https://docs.sentry.io/server/installation/python/\" target=\"_blank\" rel=\"noopener\">https://docs.sentry.io/server/installation/python/</a><br>\n我们采用的是 docker 安装方式，如果是采用 docker 安装的方式，那么还有一种更加便捷的方式，那么就是采用 docker-compose 了，具体安装步骤如下：</p>\n<p>注意，通过 Docker 本地搭建 Sentry 的时候，需要 docker 版本为 1.10.0 以上，docker-compose 版本为 1.17.0 以上，同时要求最低有 3GB 的可用内存。</p>\n<ol>\n<li>安装 docker、docker-compose</li>\n</ol>\n<p>这里采用 yum 安装，具体安装步骤如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>安装一些必要的系统工具</span><br><span class=\"line\">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"><span class=\"meta\">#</span>添加软件源信息</span><br><span class=\"line\">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\"><span class=\"meta\">#</span>更新 yum 缓存</span><br><span class=\"line\">yum makecache fast</span><br><span class=\"line\"><span class=\"meta\">#</span>安装 Docker-ce</span><br><span class=\"line\">yum -y install docker-ce</span><br><span class=\"line\"><span class=\"meta\">#</span>启动 Docker 后台服务</span><br><span class=\"line\">systemctl start docker</span><br><span class=\"line\"><span class=\"meta\">#</span>下载docket-compose</span><br><span class=\"line\">curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class=\"line\"><span class=\"meta\">#</span>修改权限</span><br><span class=\"line\">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>安装 sentry</li>\n</ol>\n<p>其实 sentry 社区了提供一个基于 docker-composed 的开源项目，通过它我们可以一键部署 sentry。首先我克隆该项目：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/getsentry/onpremise.git</span><br><span class=\"line\">cd onpremise</span><br><span class=\"line\">-rw-r--r-- 1 root root  2017 Oct 15 22:27 config.yml</span><br><span class=\"line\">-rw-r--r-- 1 root root  1427 Oct 16 16:27 docker-compose.yml</span><br><span class=\"line\">-rw-r--r-- 1 root root    43 Oct 15 18:05 Dockerfile</span><br><span class=\"line\">-rwxr-xr-x 1 root root  2766 Oct 15 18:05 install.sh</span><br><span class=\"line\">-rw-r--r-- 1 root root 11356 Oct 15 18:05 LICENSE</span><br><span class=\"line\">-rw-r--r-- 1 root root   548 Oct 15 18:05 Makefile</span><br><span class=\"line\">-rw-r--r-- 1 root root  2167 Oct 15 18:05 README.md</span><br><span class=\"line\">-rw-r--r-- 1 root root    42 Oct 16 17:24 requirements.txt</span><br><span class=\"line\">-rw-r--r-- 1 root root 11493 Oct 15 18:05 sentry.conf.py</span><br><span class=\"line\">-rwxr-xr-x 1 root root  1020 Oct 15 18:05 test.sh</span><br></pre></td></tr></table></figure>\n<p>如果并没有特殊要求或者额外的组件配置的话，可以直接运行 ./install.sh 将 sentry 及其依赖都通过 docker 安装。由于我们 redis 和 postgresql 是采用阿里云托管的，所以我们不能采用这种方式进行安装。具体步骤如下：</p>\n<p>2.1 创建环境变量文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>新建环境变量文件.env,根据.env.example拷贝一份即可</span><br><span class=\"line\">cp .env.example .env</span><br></pre></td></tr></table></figure>\n<p>2.2 修改 docker-compose.xml 文件</p>\n<p>删除 redis、postgresql 等镜像依赖，并配置容器的时区，具体配置内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: '3.4'</span><br><span class=\"line\"></span><br><span class=\"line\">x-defaults: &amp;defaults</span><br><span class=\"line\">  restart: unless-stopped</span><br><span class=\"line\">  build:</span><br><span class=\"line\">    context: .</span><br><span class=\"line\"><span class=\"meta\">#</span>  depends_on:</span><br><span class=\"line\"><span class=\"meta\">#</span>    - redis</span><br><span class=\"line\"><span class=\"meta\">#</span>    - postgres</span><br><span class=\"line\"><span class=\"meta\">#</span>    - memcached</span><br><span class=\"line\"><span class=\"meta\">#</span>    - smtp</span><br><span class=\"line\">  env_file: .env</span><br><span class=\"line\"><span class=\"meta\">#</span> 时区配置</span><br><span class=\"line\">  environment:</span><br><span class=\"line\">    - TZ=Asia/Shanghai</span><br><span class=\"line\"><span class=\"meta\">#</span>    SENTRY_MEMCACHED_HOST: memcached</span><br><span class=\"line\"><span class=\"meta\">#</span>    SENTRY_REDIS_HOST: redis</span><br><span class=\"line\"><span class=\"meta\">#</span>    SENTRY_POSTGRES_HOST: postgres</span><br><span class=\"line\"><span class=\"meta\">#</span>    SENTRY_EMAIL_HOST: smtp</span><br><span class=\"line\">  volumes:</span><br><span class=\"line\">    - sentry-data:/var/lib/sentry/files</span><br><span class=\"line\">    # 时区配置</span><br><span class=\"line\">    - /etc/localtime:/etc/localtime:ro</span><br><span class=\"line\">    - /etc/timezone:/etc/timezone:ro</span><br><span class=\"line\"></span><br><span class=\"line\">services:</span><br><span class=\"line\"><span class=\"meta\">#</span>  smtp:</span><br><span class=\"line\"><span class=\"meta\">#</span>    restart: unless-stopped</span><br><span class=\"line\"><span class=\"meta\">#</span>    image: tianon/exim4</span><br><span class=\"line\"></span><br><span class=\"line\">\"docker-compose.yml\" [readonly] 72L, 1432C                                                                                                         1,1           Top</span><br><span class=\"line\"><span class=\"meta\">#</span>  memcached:</span><br><span class=\"line\"><span class=\"meta\">#</span>    restart: unless-stopped</span><br><span class=\"line\"><span class=\"meta\">#</span>    image: memcached:1.5-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span>  redis:</span><br><span class=\"line\"><span class=\"meta\">#</span>    restart: unless-stopped</span><br><span class=\"line\"><span class=\"meta\">#</span>    image: redis:3.2-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span>  postgres:</span><br><span class=\"line\"><span class=\"meta\">#</span>    restart: unless-stopped</span><br><span class=\"line\"><span class=\"meta\">#</span>    image: postgres:9.5</span><br><span class=\"line\"><span class=\"meta\">#</span>    volumes:</span><br><span class=\"line\"><span class=\"meta\">#</span>      - sentry-postgres:/var/lib/postgresql/data</span><br><span class=\"line\"></span><br><span class=\"line\">  web:</span><br><span class=\"line\">    &lt;&lt;: *defaults</span><br><span class=\"line\">    #web端口号，默认为9000</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - '9000:9000'</span><br><span class=\"line\"></span><br><span class=\"line\">  cron:</span><br><span class=\"line\">    &lt;&lt;: *defaults</span><br><span class=\"line\">    command: run cron</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> work为了保证高可用，起了两个节点</span><br><span class=\"line\">  worker1:</span><br><span class=\"line\">    &lt;&lt;: *defaults</span><br><span class=\"line\">    command: run worker</span><br><span class=\"line\"></span><br><span class=\"line\">  worker2:</span><br><span class=\"line\">    &lt;&lt;: *defaults</span><br><span class=\"line\">    command: run worker</span><br><span class=\"line\"></span><br><span class=\"line\">volumes:</span><br><span class=\"line\">    sentry-data:</span><br><span class=\"line\">      external: true</span><br><span class=\"line\">    sentry-postgres:</span><br><span class=\"line\">      external: true</span><br></pre></td></tr></table></figure>\n<p>2.3 构建 docker-compose 镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose build --pull</span><br></pre></td></tr></table></figure>\n<p>2.4 生成 sentry 密钥</p>\n<p>sentry 是用于 sentry 容器内部免密通信，并把这个值配置到 .env 的 SENTRY_SECRET_KEY key 中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose run --rm web config generate-secret-key</span><br></pre></td></tr></table></figure>\n<p>2.5 配置 redis 和 postgresql 连接信息</p>\n<p>在.env 文件中添加以下配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>秘钥，由于容器内部免密通信</span><br><span class=\"line\">SENTRY_SECRET_KEY=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg host</span><br><span class=\"line\">SENTRY_POSTGRES_HOST=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg port</span><br><span class=\"line\">SENTRY_POSTGRES_PORT=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg 数据库名称</span><br><span class=\"line\">SENTRY_DB_NAME=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg 用户</span><br><span class=\"line\">SENTRY_DB_USER=</span><br><span class=\"line\"><span class=\"meta\">#</span>pg 用户密码</span><br><span class=\"line\">SENTRY_DB_PASSWORD=</span><br><span class=\"line\"><span class=\"meta\">#</span>redis host</span><br><span class=\"line\">SENTRY_REDIS_HOST=</span><br><span class=\"line\"><span class=\"meta\">#</span>redis passowrd</span><br><span class=\"line\">SENTRY_REDIS_PASSWORD=</span><br><span class=\"line\"><span class=\"meta\">#</span>redis 端口号</span><br><span class=\"line\">SENTRY_REDIS_PORT=</span><br><span class=\"line\"><span class=\"meta\">#</span>redis 数据名</span><br><span class=\"line\">SENTRY_REDIS_DB=</span><br></pre></td></tr></table></figure>\n<p>注意：这里 postgresql 官方建议采用 9.5 和 9.6，由于阿里云没有这两个版本，所以我们采用 10 的版本。目前运行没有发现任何问题。redis 需要 3.2 以上版本，并且 sentry 不支持集群版的 redis。我们采用的 4.0 单机主从版。进行 Web 服务迁移</p>\n<p>2.6 进行 Web 服务迁移</p>\n<p>主要是初始化表结构和建用户等操作。具体操作执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose run --rm web upgrade</span><br></pre></td></tr></table></figure>\n<p>注意：注意在这个过程中命令行会提示你是否创建超级用户，如果确定，则输入邮箱和密码。如果没有创建用户，可以在升级结束后可以手动创建一个用户，具体执行以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose run --rm web createuser</span><br></pre></td></tr></table></figure>\n<p>2.7 运行 sentry</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>启动容器</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>配置邮件信息</li>\n</ol>\n<p>当 sentry 采集到了异常信息就可以通过邮件的方式，发送给指定的处理人。而且这些配置信息是无法在 web console 中修改的，具体操作是在.env 环境变量文件，添加以下配置项：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>邮件的发送地址</span><br><span class=\"line\">ENTRY_SERVER_EMAIL=</span><br><span class=\"line\"><span class=\"meta\">#</span>smtp服务器主机地址</span><br><span class=\"line\">SENTRY_EMAIL_HOST=</span><br><span class=\"line\"><span class=\"meta\">#</span>smtp 服务器用户</span><br><span class=\"line\">SENTRY_EMAIL_USER=</span><br><span class=\"line\"><span class=\"meta\">#</span>smtp服务器密码</span><br><span class=\"line\">SENTRY_EMAIL_PASSWORD=</span><br><span class=\"line\"><span class=\"meta\">#</span> smtp服务器端口,注意如果采用qq的企业邮箱，这里不是foxmail中配置的465，而是25（巨坑）。</span><br><span class=\"line\">SENTRY_EMAIL_PORT=</span><br><span class=\"line\"><span class=\"meta\">#</span>是否使用TLS，默认为false</span><br><span class=\"line\">SENTRY_EMAIL_USE_TLS=</span><br></pre></td></tr></table></figure>\n<p>重启 sentry 服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose build</span><br><span class=\"line\">docker-compose run --rm web upgrade</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>集成钉钉及时通讯工具</li>\n</ol>\n<p>我们公司使用钉钉作为内部通讯和工作辅助工作，平时工作中大家都可以通过 pc 端和 app 端第一时间查看到消息，并且报警对即时性要求比较高，所以集成钉钉很有必要，下面介绍一下 sentry 集成钉钉的步骤。</p>\n<ol>\n<li>安装 sentry-dingding 插件，sentry 的强大和可扩展是它很受欢迎的原因。目前开源社区相关 sentry 的插件也是很丰富的,sentry 钉钉插件 github 地址：<a href=\"https://github.com/anshengme/sentry-dingding%E3%80%82\" target=\"_blank\" rel=\"noopener\">https://github.com/anshengme/sentry-dingding。</a><br>\nsentry 为了方便我们安装插件，提供了一个 requirements.txt 文件。我们只需要将我们现需要安装的插件配置进去，重新构建镜像就可以完成安装和集成。修改 requirements.txt：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>添加钉钉插件</span><br><span class=\"line\">sentry-dingding~=0.0.3</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>重启 sentry 服务</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose build</span><br><span class=\"line\">docker-compose run --rm web upgrade</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>集成 LDAP</li>\n</ol>\n<p>跟集成钉钉一样，sentry 社区也提供了集成插件，sentry ldap 插件地址：<a href=\"https://github.com/Banno/getsentry-ldap-auth%E3%80%82\" target=\"_blank\" rel=\"noopener\">https://github.com/Banno/getsentry-ldap-auth。</a> 1.安装 ldap 插件，这里跟安装钉钉插件有一定区别，钉钉是直接配置在 requirements.txt 中就可以了。而 ldap 插件如果采用这样的方式可能会报错，原因是 ldap 插件需要依赖 python-ldap 相关环节，所以我们需要在先安装这些依赖。具体安装步骤如下：</p>\n<ol>\n<li>安装 sentry ldap 插件<br>\n修改 DokerFile 文件，在文件添加以下内容：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>切换成国内的源，提高下载速度。但是貌似没啥用，下载还是很慢，后面在看看是什么原因</span><br><span class=\"line\">RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class=\"line\">RUN apt-get clean</span><br><span class=\"line\"><span class=\"meta\">#</span>更新源，这一步很重要不能省略，否则后面会下载失败</span><br><span class=\"line\">RUN apt-get update</span><br><span class=\"line\"><span class=\"meta\">#</span>安装python-ldap相关依赖</span><br><span class=\"line\">RUN apt-get install -y libsasl2-dev python-dev libldap2-dev libssl-dev</span><br><span class=\"line\"><span class=\"meta\">#</span>安装sentry-ldap插件</span><br><span class=\"line\">RUN pip install sentry-ldap-auth</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>配置 ldap 插件<br>\n在 <a href=\"http://sentry.conf.py\" target=\"_blank\" rel=\"noopener\">sentry.conf.py</a> 文件添加以下配置项:</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ldap</span><br><span class=\"line\"><span class=\"keyword\">from</span> django_auth_ldap.config <span class=\"keyword\">import</span> LDAPSearch, GroupOfUniqueNamesType</span><br><span class=\"line\"><span class=\"comment\">#设置ldap服务器地址</span></span><br><span class=\"line\">AUTH_LDAP_SERVER_URI = <span class=\"string\">'ldap://secad.poizon.com:3489'</span></span><br><span class=\"line\"><span class=\"comment\">#ldap管理员账号</span></span><br><span class=\"line\">AUTH_LDAP_BIND_DN = <span class=\"string\">'xxx'</span></span><br><span class=\"line\"><span class=\"comment\">#ldap管理员密码</span></span><br><span class=\"line\">AUTH_LDAP_BIND_PASSWORD = <span class=\"string\">'xxxxx'</span></span><br><span class=\"line\"><span class=\"comment\">#ldap搜索路径，这里配置成技术部，需要注意如果有中文需要转成unicode的格式</span></span><br><span class=\"line\">OU=unicode(<span class=\"string\">'OU=技术部,OU=识装,DC=sz,DC=du'</span>, <span class=\"string\">'utf8'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_USER_SEARCH = LDAPSearch(</span><br><span class=\"line\">    OU,</span><br><span class=\"line\">    ldap.SCOPE_SUBTREE,</span><br><span class=\"line\">    <span class=\"string\">'(mail=%(user)s)'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_GROUP_SEARCH = LDAPSearch(</span><br><span class=\"line\">    <span class=\"string\">''</span>,</span><br><span class=\"line\">    ldap.SCOPE_SUBTREE,</span><br><span class=\"line\">    <span class=\"string\">'(objectClass=groupOfUniqueNames)'</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_GROUP_TYPE = GroupOfUniqueNamesType()</span><br><span class=\"line\">AUTH_LDAP_REQUIRE_GROUP = <span class=\"literal\">None</span></span><br><span class=\"line\">AUTH_LDAP_DENY_GROUP = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_USER_ATTR_MAP = &#123;</span><br><span class=\"line\">    <span class=\"string\">'name'</span>: <span class=\"string\">'cn'</span>,</span><br><span class=\"line\">    <span class=\"string\">'email'</span>: <span class=\"string\">'mail'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AUTH_LDAP_FIND_GROUP_PERMS = <span class=\"literal\">False</span></span><br><span class=\"line\">AUTH_LDAP_CACHE_GROUPS = <span class=\"literal\">True</span></span><br><span class=\"line\">AUTH_LDAP_GROUP_CACHE_TIMEOUT = <span class=\"number\">3600</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果ldap认证成功，默认给用户加入poizon组织中</span></span><br><span class=\"line\">AUTH_LDAP_DEFAULT_SENTRY_ORGANIZATION = <span class=\"string\">u'poizon'</span></span><br><span class=\"line\"><span class=\"comment\">#默认的用户的角色是member</span></span><br><span class=\"line\">AUTH_LDAP_SENTRY_ORGANIZATION_ROLE_TYPE = <span class=\"string\">'member'</span></span><br><span class=\"line\"><span class=\"comment\">#开通相应的操作权限</span></span><br><span class=\"line\">AUTH_LDAP_SENTRY_ORGANIZATION_GLOBAL_ACCESS = <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\">#指定sentry的username字段名称</span></span><br><span class=\"line\">AUTH_LDAP_SENTRY_USERNAME_FIELD = <span class=\"string\">'uid'</span></span><br><span class=\"line\"><span class=\"comment\">#指定sentry的角色和ldap的角色的绑定关系，这里我们暂时不设置</span></span><br><span class=\"line\">AUTH_LDAP_SENTRY_GROUP_ROLE_MAPPING = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">#扩展登录方式，采用Ldap的方式进行认证</span></span><br><span class=\"line\">AUTHENTICATION_BACKENDS = AUTHENTICATION_BACKENDS + (</span><br><span class=\"line\">    <span class=\"string\">'sentry_ldap_auth.backend.SentryLdapBackend'</span>,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#LOG配置</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\">logger = logging.getLogger(<span class=\"string\">'django_auth_ldap'</span>)</span><br><span class=\"line\">logger.addHandler(logging.StreamHandler())</span><br><span class=\"line\">logger.setLevel(<span class=\"string\">'DEBUG'</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"js知识点总结","catalog":true,"date":"2018-07-21T02:24:38.000Z","subtitle":null,"header-img":null,"_content":"\n# js 知识点总结\n\n## 1. 解码和编码\n\n> 原因：因为链接里面会有中文或者特殊字符号无法跳转需要进行相关编码解码\n\n**编码**\n\n>\n\n    'encodeURI': 只对查询的参数做编码\n\n    'encodeURIComponent': 对整个url做编码，包括? & / #\n\n```javascript\na = 'www.baidu.com/test?name=\"zhangsan\"'\nencodeURI(a) => 'www.baidu.com/test?name=%22zhangsan%22'\nencodeURIComponent(a) => 'www.baidu.com%2Ftest%3Fname%3D%22zhangsan%22'\n```\n\n**解码**\n\n>\n\n    'decodeURI': 只对查询参数做解码\n    'decodeURIComponent': 对整个URL做解码\n\n---\n\n## 2. 序列化和反序列化\n\n>\n\n```\nJSON.stringify()        // 序列化\nJSON.parse()            // 反序列化\n```\n\n使用 ajax 需要设置请求头部信息\n\nheader: {'Content-Type': 'application/json; charset=utf-8;'}\n\n> JSON.stringify() 可以简单的用来迅速判断两个对象是否相等，但不严谨（比如：序列化失败）\n\n---\n\n## 3. 日期\n\n```\nnew Date().getTime()   // 单位  秒\n// 获取当前时间   （存在兼容性）\nnew Date().toLocaleDateString() // 2017/7/24\nnew Date().toLocaleTimeString() // 下午5:07:33\nnew Date().toLocaleString()     // 2017/7/24 下午5:07:33\n// 若要显示24进制 需要option选项\nnew Date().toLocaleTimeString(\"UTC\",{ hour12: false })  // 17:20:16\n```\n\n---\n\n## 4. 回流/重绘\n\n1. 回流：几何属性发生变化 比如：内容、结构、位置或尺寸发生变化，需要重新计算样式和渲染树；\n\n2. 重绘：元素发生的改变只影响了节点的一些样式（背景色、边框色、文字颜色等）\n\n> 回流比重绘要消耗更多的资源\n\n---\n\n## 5. 锚点定位 scrollIntoView （无兼容问题）\n\n可以用来做一些 tab 定位\n\n```\ndocument.getElementById('xx').scrollIntoView()\n```\n\n---\n\n## 6. typeof 和 instanceof\n\n> ### typeof\n\n会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,function；\n\n缺点：\n\n- 不适用于来判断数组，因为不管是数组还是对象，都会返回 object。\n- 判断不了 null null 也是对象\n\n>\n\n```\ntypeof [1]      // Object\n```\n\n> ### instanceof\n\n返回的是一个布尔值 只能用来判断对象和函数\n\n```\nvar a = {};\nalert(  a instanceof Object )     // true\nvar a  = [];\nalert(  a instanceof Array )    // true\n```\n\n最靠谱也是最方便的办法使用`Object.prototype.toString.call()`来判断\n\n```javascript\nfunction types(target) {}\n```\n\n---\n\n## 7. requestAnimationFrame （RAF） 动画 api 兼容 Ie 8/9\n\n```\nvar i = 0\n\nwindow.requestAnimFrame = (function(){\n  return  window.requestAnimationFrame       ||\n          window.webkitRequestAnimationFrame ||\n          window.mozRequestAnimationFrame    ||\n          function( callback ){\n            window.setTimeout(callback, 1000 / 60);\n          };\n})()\n\nrequestAnimFrame(animloop)\n\nfunction animloop () {\n    document.getElementById('test').style.top = i ++\n}\n\n```\n\n### 优点\n\n    1. 解决毫秒的不精确性；\n    2. 避免过渡渲染；\n    3. 浏览器可以优化并行的动画动作，将合并的动作放入一个渲染周期；\n    4. 过程可控；\n\n> 动画效率之争\n\n    css3动画高效的原因有以下三点：\n\n        1. 强制使用硬件加速（GPU）；\n        2. 使用与RAF类似的机制；\n        3. 优化DOM操作 避免内存消耗来减少卡顿；\n\n    同时因为采用GPU， 导致浏览器一直出于高负荷运转，移动端电量损耗和一定卡顿，\n    而且css不能完全被js控制\n    pc上兼容性\n\njs 动画库 （比如 Velocity.js 和 GSAP）\n\n---\n\n## 8. 跨域\n\n1. ### JSONP\n\n   > 通过 js 标签引入一个 js 文件 这个 js 文件载入成功之后会执行我们在 url 参数中指定的函数 并且会吧我们需要的 json 数据作为参数传入\n   >\n   > 例如：url?item=1&callback=filter\n   >\n   > == 原生 js 实现 jsonp 的话 定义好 callback 的函数名称,动态创建 js 标签 url 加上查询的参数写好 callback 的回调函数名称即可 ==\n\n2. ### 利用 iframe 并修改 document.domain 来跨子域\n\n   两个不同域的页面引入 iframe 标签 同时将两个页面的主域设置成相同的域名\n\n   ![页面1](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox669ialYSHxewnD1B4L5UibVqhMnFEfibLhA8vUQu2s9rltB2HZ6UTQ19iag/0?wx_fmt=png)\n   ![页面2](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6Kv2iaHanjIzQHDNeia2FsoHSz8AJPkxh0IqickdbPg0CPeFPhoQMpuv5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n3. ### window.name （可以配合 iframe）\n\n   同源窗口下 window.name 对所有页面都是共享的\n\n   每个页面对 window.name 都有读写权限\n\n   window.name 的值并不会因为新页面而重置\n\n4. widnow.postMessage （存在兼容性 IE7/8 不支持）\n\n   ！[页面 1](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6z8ibxywKPEusvEA2xS8ialrQ1Oxd0jw0V8C6f7Gicy6Obsyt5bicibxdx5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n   ！[页面 2](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6B9Fpsa9KmNAMibvfSqE8Qv2icpLzzFE6NfvEp8YxWW6JOMTacIzaQzxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n5. Nginx 反向代理\n\n## 9. selection\n\n> 获取鼠标划过文本的对象\n\n> `window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();`\n\n---\n\n## 10. 正则表达式\n\n> 常用规则\n\n- \\n 回车\n- \\t 制表符\n- \\r 换行符\n- \\s 空格\n- \\u4e00-\\u9fa5 中文\n- \\w 大小写字母\\_数字\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- {n, m} 至少出现 n 次 最多 m 次\n- {n,} 至少 n 次\n- - 任意次\n- - 至少一次\n- {n} 至少 n 次\n- () 分组符号\n- [\\s\\S] 任意字符\n- ^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。\n- 正则的最后位置 , 就代表结束的意思\n\n匹配中文: [\\u4e00-\\u9fa5]\n\n例如：\n\n```\nvar str = '2013-6-7';\nvar re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-\nvar re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-\nvar re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-\n\n--------------------------\nvar str = '2013-6-7';\nvar re = /(\\d+)(-)/g;\n\nstr = str.replace(re,function($0,$1,$2){\n\n    //replace()中如果有子项，\n    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,\n    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )\n    return $1 + '.';  //分别返回2013.   6.\n\n});\n\n```\n\n- [] 表示某个集合中的任意一个\n- [^a] 排除 a\n\n```\n// var re = /\\bclassname\\b/;\n\n// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会\n// 把classname当做一个字符串去匹配。\n\nvar re = new RegExp('\\\\b'+classname+'\\\\b');\n\n// 匹配的时候，classname前面必须是起始或者空格，后面也是。\n\n默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。\n```\n\n---\n\n## 11. Object\n\n    1. constructor\n\n        实例的constructor 永远指向 构造函数 的 prototype.constructor\n\n        理解成 实例是基于构造函数原型链生成的对象\n\n```\n\nfunction A(x){\n    this.x = x;\n}\nvar newA = new A(name);\n\n此时：\nnewA.constructor == A.prototype.constructor;\n\n```\n\n    2. hasOwnProperty\n\n        判断对象上某个属性是否属于自身 属于自身为true, 原型链上为false\n\n```\n    function a () {\n        this.show = 'x';\n    }\n    a.prototype.hide = function () {\n        console.log(111111);\n    }\n    var z = new a();\n    z.hasOwnProperty('show');          // true\n    z.hasOwnProperty('hide');          // false\n```\n\n    3. isPrototypeOf\n\n        判断一个对象是否是另一个对象的原型\n\n```\n    var monkey = {\n        hair : true,\n        breathes : function(){\n            alert('1')\n        }\n    }\n    function Human(name){\n        this.name = name;\n    }\n    // Human的原型链绑定monkey对象\n    Human.prototype = monkey;\n\n    var man = new Human('张三');\n    monkey.isPrototypeOf(man);      // true\n\n```\n\n    4. prototype和__proto__\n\n        prototype是一个函数的内置属性（每个函数都有一个prototype属性）\n\n        __proto__ 是一个实例对象的内置属性 实例化的对象在内部通过此属性寻找原型链\n\n```\nvar Person = function () {}\nvar zhangsan = new Person ()\n\nzhansan.__prop__ = Person.prototype\n\nnew 的过程拆分成以下三步\n\n1. var p = {}\n2. p.__proto__ = Person.prototype\n3. Person.call(p)\n```\n\n    5. Object.getPrototypeOf\n\n        获取 实例化对象 原型链 的相关属性\n\n```\nfunction Test () {\n\n}\n\ntest.prototype.showName = function () {\n    console.log(1)\n}\n\nlet obj = new Test ()\nObject.getPrototypeOf(obj) == obj.__proto__\n\n```\n\n    6. Object.keys\n\n        可以用来枚举可遍历的属性 返回一个数组\n\n    7. Object.create\n\n        在原型链上创建对象属性\n\n```\n    <!-- 属性创建在原型链上 -->\n    Object.create({\n        name: '张三'\n    })\n\n    <!-- 字面量方式创建的对象属性挂在自身 -->\n    let test = {\n        name: '张三'\n    }\n\n```\n\n    8. Object.isExtensible\n\n        判断对象是否可以新增属性\n\n    9. Object.preventExtension\n\n        锁住对象 使其不能新增属性 但是原来的属性可以修改删除\n\n    10. Object.seal\n\n        密封对象 不能增加新属性 也不能删除旧属性  但是能修改原来的属性\n\n    11. Object.isSealed\n\n        判断对象是否密封\n\n    12. Object.freeze\n\n        冻结对象 不能新增 不能修改 不能删除\n\n    13. Object.isFrozen\n\n        判断对象是否完全被冻结\n\n    14. Object.getOwnPropertyNames\n\n        获取自身属性名字 返回一个数组\n\n    15. Object.getOwnPropertyDescriptor\n\n        判断某个对象上某个属性的状态描述\n\n    16. Object.defineProperty\n\n\n\n\n    -----------\n\n## 12. 继承\n\n> **调用另一个对象的方法，以另一个对象替换当前对象的上下文**\n>\n> > 缺点\n> >\n> > > 只能继承父级本身属性，原型链的属性无法继承\n\n- **call**\n  > 第二个参数可以省略\n- **apply**\n  > 第二个参数必须是数组或者用 arguments 代替\n- **bind**\n  > bind 与 call 和 apply 的区别在于 bind 是一个函数 不会立即执行 必须在后面再加上一对括号去立即执行\n\n```\n例子1：\n\nfunction Add(a,b)\n{\n    this.add = function(a,b){\n        alert(a+b)\n    };\n    this.xx = 333;\n}\nfunction Sub()\n{\n    this.sub = '张三';\n\n    // call方法\n    Add.call(this); // call继承Add所有方法(不包含原型链上的方法)\n\n    // apply方法  参数不能指定的时候用[]或者arguments代替\n    Add.apply(this, [])\n    // 又可以写成\n    Add.apply(this, arguments)\n\n    // bind方法\n    Add.bind(this)();\n}\n\nx = new Sub();\nx.add(5,7)                  // 11\n\n=====================================\n\n例子2：\n\n若只想继承父级构造函数某一个具体方法\n需要先将父子对象都实例化后 调用父级的具体方法call\n\nfunction Add(a,b)\n{\n    this.add = function(a,b){\n        alert(a+b)\n    };\n    this.xx = 333;\n}\nfunction Sub()\n{\n    this.sub = '张三';\n}\n\nnewAdd = new Add(7,8);\nnewSub = new Sub();\n\n// Sub只继承了Add的add方法并执行相关方法\n\ncall方法：\nnewAdd.add.call(newSub, 10, 4);      // 14\n\napply方法：\nnewAdd.add.apply(newSub, [10, 4]);   // 14\n\nbind方法：\nnewAdd.add.bind(newSub, 10, 4)();   // 14\n\n```\n\n>\n\n> > **注意**\n> >\n> > > 若想要全部继承父级所有相关属性 得采用==原型链继承==的方式\n\n```\nfunction person(){\n    this.hair = 'black';\n    this.eye = 'black';\n    this.skin = 'yellow';\n    this.view = function(){\n        return this.hair + ',' + this.eye + ',' + this.skin;\n    }\n}\nfunction man(){\n    this.feature = ['beard','strong'];\n}\nman.prototype = new person();\n\n```\n\n---\n\n## 13. cookie sessionStorage localStorage\n\n    1. cookie\n        * 4k的限制；\n        * 服务端和客户端传递时都会带上cookie；\n        * 本质上是对字符串的读取 存储内容过多消耗内存空间 导致页面变卡顿；\n        * 不能被爬虫读取；\n        * 设置时间之前一直有效，到时间就清除；\n    2. sessionStorage\n        * 临时存储：引入“浏览器窗口”的概念，同源同窗口数据不会销毁，不同标签页中数据不能共享，关闭浏览器时候销毁；\n        * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n        * 性能更好，即本地读取数据比服务器获取快多了；\n        * 不能跨tab标签页传值；\n    3. localStorage\n        * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n        * 体积更大 5M；\n        * 持久存储在本地，直到手动清除；\n\n```\nlocalStorage.setItem('sss',1111);\nlocalStorage.getItem('sss');\nlocalStorage.removeItem('sss');\nlocalStorage.clear();\n```\n\n---\n\n## 14. 闭包\n\n    简单回答闭包就是 一个函数返回自身内部函数的调用\n\n    为什么使用？\n\n    因为js是链式的 一层一层向上级查找 所以外部函数无法访问内部函数;\n\n> > 优点\n>\n> - 可以读取函数内部的变量，外部无法访问到里面变量;\n> - 函数在执行完毕不会被销毁 而是一直存在内存中;\n\n> > 缺点\n>\n> - 不会被内存回收 容易出现性能问题\n\n```\nfunction foo(){\n    var a = 2;\n\n    function bar(){\n        console.log(a);\n    }\n\n    return bar;\n}\nvar newFoo = foo();\nnewFoo();               // a\n\n```\n\n---\n\n## 15. 深拷贝和浅拷贝\n\n- **浅拷贝**\n  > **复制对象的副本 指向同一内存区域 对副本的操作会影响父级对象**\n\n浅拷贝方式：\n\n1. 直接赋值；\n2. Object.assign();\n3. JSON 序列化；\n\n- **深拷贝**\n  > **复制对象的副本 指向不同的内存区域 与父级对象独立**\n\n```\n// 浅拷贝\nvar a = {\n    name : 'zhangsan'\n}\n\nvar b = a;\nb.name = 'lisi';\n\nconsole.log(a.name);    // \"lisi\"\nconsole.log(b.name);    // \"lisi\"\n\n// 深拷贝  (更完整的深拷贝还需要再详细优化)\nfunction deepCopy(p, c){\n    var c = c || {};\n    for(var i in p ){\n        // 数组和对象的时候再处理\n        if(typeof p[i] === 'object'){\n            c[i] = (p[i].constructor === Array) ? [] : {};\n            deepCopy(p[i], c[i]);\n        }else{\n            // 基本类型直接赋值\n            c[i] = p[i]\n        }\n    }\n    return c;\n}\n\nvar parent = {\n    number: [1, 2, 3],\n    obj: {\n        prop: 1\n    }\n}\n\nvar copyParent = deepCopy(parent);\ncopyParent.number.push(4)\ncopyParent.number                   // 1,2,3,4\nparent.number                       // 1,2,3\n```\n\n---\n\n## 16. 传值类型和引用类型\n\n- **传值类型（基本类型）**\n  > 值为基本类型时候为深拷贝\n  >\n  > > 基本类型就是 null，undefined，Boolean，string，number\n  > >\n  > > > ==独立不干扰==\n- **引用类型**\n  > 值为对象类型时候为浅拷贝\n  >\n  > > 值都是对对象的引用，即一个指向对象的指针\n  > >\n  > > > ==对副本的操作会影响父级对象==\n\n```\n// 传值类型\nvar  a = 1;\nfunction voo(data)\n{\n    data = 2;\n    console.log(data);   // 2\n}\nvoo(a);\nconsole.log(a);    // 1\n\n// 引用类型\nvar  a = {\n    name : \"张三\"\n};\nfunction voo(data)\n{\n    data.name = \"李四\";\n    console.log(data);   //  Object {name: \"李四\"}\n}\nvoo(a);\nconsole.log(a);         //  Object {name: \"李四\"}\n\n// 引用类型不会被基本类型覆盖\nvar  a = {\n    name : \"张三\"\n};\nfunction voo(data)\n{\n    data = 3；\n    console.log(data);   // 3\n}\nvoo(a);\nconsole.log(a);         //  Object {name: \"张三\"}\n\n// 为了解决引用类型的问题  引入深拷贝的概念  参考上面一个概念\n\n```\n\n---\n\n## 17. 函数作用域提升与预编译\n\n> 由于 js 没有其他强类型语言{}这类的块级作用域 只有函数作用域 函数的声明很随意导致各种问题出现\n>\n> > 变量预编译 > 函数预编译\n\n```\n// 第一条\n\na();\nvar a = c = function() {\n    console.log(2)\n};\na();\n\nfunction a() {\n    console.log(1)\n};\na();\n(function(b) {\n    b(), c()\n    var b = c = function a() {\n        console.log(3)\n    }\n    b();\n})(a);\nc();\n\n// 等价于：\nvar a;                      // 变量声明提升\nfunction a() {              // 函数声明提升\n    console.log(1)\n};\na();                        // 1\na = c = function() {\n    console.log(2)\n};\n\na();                        // 2\n\n(function(b) {\n    var b\n    b()                     // 2\n    c()                     // 本来以error\n    // 后来有人指正 原因就在于var b=c=xxx。\n    // c相当于没有加var 不会预编译，这里c直接查找到外部作用域的c\n    b = c = function a() {\n        console.log(3)\n    }\n    b();                    // 3\n})(a);\n\nc();                        // 3\n\n\n// 第二条\nfunction fn(){\n    function a(){console.log(1)}\n    return a;\n    function a(){console.log(2)}\n}\nfn()();                     //2 由于预编译 后面的a覆盖了前面的a\n\n// 第三条\nvar a=10;\nfunction fn(){\n    // 预编译a 赋值undefined，内部作用域存在a这个变量，\n    // 所以这里 !a 就是  !undefined，就是true，进入函数a=20;\n    if (!a) {\n        var a=20\n    }\n    console.log(a)          //  这里是20 ，\n}\nfn()\n\n// 第四条\n<script>\n    console.log(typeof a)   //undefined\n    var a='littlebear';\n    console.log(a)          //littlebear\n</script>\n<script>\n    console.log(typeof a)   //string  第二个<script>标签里的a但会往上查找。\n    var a=1;\n    console.log(a)//1\n</script>\n\n// 第五条\n<script>\n    console.log(typeof a)   //undefined\n    console.log(a)\n    // 报错，遇到<script>标签对时，会先对这一块进行预解析，\n    // 下面没预解析，所以找不到声明过的a，于是报错了\n</script>\n<script>\n    console.log(typeof a)   //undefined\n    var a=1;\n    console.log(a)          //1\n</script>\n\n// 第六条\n<script>\n    function fn(a,b){\n        console.log(a)      //容易上当 初始化a的时候已经赋值'容易上当'\n        var a=10;\n        console.log(a)      //10\n    }\n    fn('容易上当');\n</script>\n\n```\n\n---\n\n## 18. AMD 和 CMD 区别\n\n1. AMD 推崇依赖前置。 （requireJS）\n\n   CMD 推崇依赖就近， （seaJS）\n\n```\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a')\n    a.doSomething()         // 此处略去 100 行\n    var b = require('./b')  // 依赖可以就近书写\n    b.doSomething()         // ...\n\n})\n// AMD 默认推荐\ndefine(['./a', './b'], function(a, b) {\n    // 依赖必须一开始就写好\n    a.doSomething()    // 此处略去 100 行\n    b.doSomething()\n})\n```\n\n2.  对于依赖的模块，\n\n    AMD 是提前执行（预执行），\n\n    CMD 是延迟执行（懒执行）。\n\n> 不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n3.  AMD 的 API 默认是一个当多个用，\n\n    CMD 的 API 严格区分，推崇职责单一\n\n> 比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。\n\n---\n\n## 19. 常见服务器的状态码\n\n- 304\n\n  Not Modified\n\n  客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n\n- 400\n\n  Bad Request\n\n  表示该请求报文中存在语法错误，导致服务器无法理解该请求。\n\n- 403\n\n  Forbidden\n\n  该状态码表明对请求资源的访问被服务器拒绝了。\n\n- 500\n\n  Internal Server Error\n\n  该状态码表明服务器端在执行请求时发生了错误。\n\n- 502\n\n  上游网关错误\n\n- 301\n\n  永久重定向\n\n- 302\n\n  临时重定向 会出现 URL 劫持 体现在搜索引擎收录策略上 会改变原有请求方法\n\n- 307\n\n  临时重定向 与 302 区别 客户端应`保持请求方法`不变向新的地址发出请求\n\n---\n\n## 20. 事件冒泡和事件捕获\n\n    * 事件冒泡兼容写法\n\n    ```\n    if (event.cancelBubble) {\n        event.cancelBubble = true\n    } else {\n        event.stopPropagation()\n    }\n    ```\n    --------------------------\n\n## 21. 数组\n\n    1. push\n\n        向数组末尾添加指定元素\n\n    2. pop\n\n        移除数组末尾的一个元素 并返回移除的元素\n\n    3. shift\n\n        移除数组第一项 并返回该元素\n\n    4. unshift\n\n        给数组第一项加上一个元素 返回数组长度\n\n    5. join\n\n        数组按照指定的字符换转成字符串\n\n    6. sort\n\n        数组按照ASCII排序  所以要完全按照从小到大的顺序排序的话需要指定参数 1 -1 0\n\n    7. splice\n\n        从0开始\n\n    > 删除 ---------------------（**起始位置，截取个数**）\n\n    > 插入 ---------------------（**起始位置，截取个数为0，要插入的项**）\n\n    > 替换----------------------（**起始位置，截取个数为1，要插入的项**）\n\n    8. slice\n\n    9. concat\n\n    10. reverse\n\n    11. 遍历数组的方法\n\n        > forEach\n        > for in\n\n        两者区别 在于 for in 会遍历数组原型链的属性值\n\n        为了避免这样的情况 使用 hasOwnProperty 解决\n\n---\n\n## 22.正则\n\n- ()：小括号，叫做分组符。\n- \\s : 空格\n- \\S : 非空格\n- \\d : 数字\n- \\D : 非数字\n- \\w : 字符 ( 字母 ，数字，下划线\\_ )\n- \\W : 非字符\n- .（点）——任意字符\n- \\. : 真正的点\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- \\B : 非独立的部分\n- {n,m}：至少出现 n 次，最多 m 次\n- {n,} :至少 n 次\n- - :任意次 相当于{0,}\n- ？ ：零次或一次 相当于{0,1}\n- - ：一次或任意次相当于 {1,}\n- {n}： 正好 n 次\n- [] ： 表示某个集合中的任意一个 不能为空\n\n---\n\n> ### 字符串相关的正则方法\n\n- ### match()\n\n> 返回一个包含匹配内容的数组\n\n```\nvar str = 'abcdef';\n\nvar re = /B/i;\n\nstr.match(re) // [b]\n```\n\n例子 2：\n\n```\nurl = https://dimg.fws.qa.nt.ctripcorp.com/images/2d090m000000062hy59E5.jpg\"\nurl.match(/[^\\/]*$/) // 2d090m000000062hy59E5.jpg\nurl.match(/^[^\\/]*/) // https\n```\n\n- ### search()\n\n> 返回匹配到的第一个内容所在的位置\n\n```\nvar str = 'abcdef';\n\nvar re = /B/i;\n\nstr.search(re) // 1\n\n```\n\n- ### replace()\n\n> 查找符合正则的字符串并替换成==一个==对应的字符串。返回替换后的内容。\n\n```\nvar str = \"我爱北京天安门，天安门上太阳升。\";\nvar re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配\nvar str2 = str.replace(re,'*'); // 我爱**，*上太阳升。\n\n```\n\n并不能解决一个文字\\*的对应\n\n```\nvar str = \"我爱北京天安门，天安门上太阳升。\";\nvar re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配\nvar str2 = str.replace(re,function(str){\n            alert(str);\n            //用来测试：参数代表每次搜索到的符合正则的字符，\n            //所以第一次str指的是北京 第二次str是天安门 第三次str是天安门\n            var result = '';\n            for(var i=0;i<str.length;i++){\n                result += '*';\n            }\n            return result; //所以搜索到了几个字就返回几个*\n        });\nalert(str2)\n```\n\n    ```\n    var str = '2013-6-7';\n    var re = /(\\d+)(-)/g;\n\n    str = str.replace(re,function($0,$1,$2){\n            // replace()中如果有子项，\n            // 第一个参数 ：$0（匹配成功后的整体结果  2013-  6-）,\n            // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n            // 第三个参数 : $2(匹配成功的第二个分组，这里指的是-    - - )\n        return $1 + '.';  //分别返回2013.   6.\n    });\n\n    alert( str );   //2013.6.7\n    //整个过程就是利用子项把2013- 6- 分别替换成了2013. 6.  最终弹出2013.6.7\n    ```\n\n---\n\n### 正则两个方法\n\n- ### test()\n\n> 匹配到指定内容返回 true\n\n- ### ==exec()==\n\n> 返回第一匹配项信息的数组 若没有返回 null\n> 有两个属性 index input\n\n    ```\n    var text = 'mom and dad and baby'\n    var pattern = /mom( and dad( and baby)?)?/gi\n    var matches = pattern.exec(text)\n    mathes.index // 0\n    mathes.input // mom and dad and baby\n    mathes[0] // mom and dad and baby\n    mathes[1] //  and dad and baby\n    mathes[2] // and baby\n    ```\n\n## 23. 后退监听\n\n> history.back() history.forward() history.replace()触发 onpopstate 事件\n\n    ```\n    window.onpopstate = function () {\n        alert('2222')\n        history.pushState(null, null, document.URL)\n        return false\n    }\n    history.pushState(null, null, document.URL)\n    ```\n\n    onbeforeunload事件有坑 chrome51版本及以后不能自定义文字 并且 页面载入之后一定要有浏览器行为才能触发\n\n## 24. base64 图片及相关验证码\n\n> data:image/gif;base64, (base64 地址)\n\n    ```\n    if (result == null || result.length == 0) return\n    result = $.parseJSON(result)\n    var id = result['id']\n    var imgUrl = result['base64Buffer']\n    $('#js-code').attr('src', 'data:image/gif;base64,' + imgUrl)\n\n    ```\n\n## 26. from 包裹的元素 document 事件失效 必须给 from 加事件\n\n## 27. 进制转换\n\n> 十进制转十六进制\n\n    ```\n    var s = 255\n    s.toString(16) // ff\n    ```\n\n> 十六进制转十进制\n\n    ```\n    parseInt('0xFF')   // 255\n    ```\n\n## 28. label 绑定事件一定要让事件委托到触发里面的 input\n\n    所以事件委托的时候直接监听input\n\n## 29. 跨域 post 请求转为 options 类型\n\n## 30. Math\n\n    1. Math.floor 向下舍入；\n    2. Math.ceil  向上舍入;\n    3. Math.cos   余弦;\n    4. Math.round 四舍五入;\n    5. Math.sin   正弦；\n    6. Math.tan   正切；\n\n## 31. isNaN\n\n    首先需要知道 '' == 0   'abc' != 0   [] == 0  [1] != 0   null == 0  {} != 0  undefined != 0\n\n    ```\n    isNaN('')   // false\n    isNaN(' ')  // false\n    isNaN('abc') // true\n    isNaN(undefined) // true\n    isNaN([])   // false\n    isNaN({})   // true\n    isNaN(null) // false\n\n    ```\n\n## 32. Boolen\n\n    首先需要知道  0 == false    1 == true  '' == false   undefined != false != true    null != false != true\n\n    ```\n    Boolean('') // false\n    Boolean('ssss') // true\n    Boolean([])  // true\n    Boolean([1,2])  // true\n    Boolen({})      // true\n    Boolen(null)    // false\n    Boolen(undefined)   // false\n    ```\n\n## 33. 解决回调地狱 （多级回调）\n\n    1. Promise\n\n    2. aSync/await\n\n    3. generator\n\n## 34. 字符串\n\n    1. slice\n\n        在 不修改目标数组 的情况下返回截取的指定元素（ **起始位置，截止位置**）\n\n        从0开始 ==不包含最后一个数值==\n\n        负数情况下 将负数加上自身长度得到的数值作为参数\n\n    2. substr\n\n        subdtr接收的是 起始位置 和 所要返回的字符串长度\n\n        在负数情况下  将第一个参数与字符串长度相加后的数值作为第一个参数\n\n    3. substring\n\n        默认会将较小的参数作为第一个参数\n\n        在 不修改目标数组 的情况下返回截取的指定元素 （ **起始位置，截止位置**）\n\n        负数当做0处理\n\n```\nlet test = 'abcdef'\ntest.slice(0, -1)   // abcde\ntest.slice(2, -3)   => test.slice(2,3)  // c\n\ntest.substring(1, -2) => a\ntest.substring(2, -3) => ab\n```\n\n    4. split\n\n        字符串按照指定规则转换成数组\n\n## 35. let 与 var 区别\n\n    1. var存在变量提升， let不存在；\n    2. let不允许重复声明；\n    3. var挂载在window下，let挂载在块作用域下；\n\n## 36. 为什么 var 可以重复声明\n\n    因为js运行过程中，\n\n    引擎 负责整个代码编译和运行\n\n    编译器 负责词法分析、语法分析、代码生成等工作\n\n    编译器从左至右编译var a，如果a不存在则在作用域声明一个新的变量a，若存在a则忽略继续向下编译；\n\n    引擎遇到a = 2，按照作用域链向上查找 若存在变量a直接赋值，不存在则在作用域重新声明新的变量并赋值2\n\n## 37. CommonJS 中的 require/exports 和 ES6 的 import/export 有什么区别\n\n1.\n\n> CommomJS 模块 require 代码时候会立刻执行；\n\n> ES6 模块是动态引用，不会立刻执行，仅仅作为一个加载模块的对象引用；\n\n2.\n\n> CommonJs 模块输出的是一个值的拷贝， 输出后的对象会被缓存（即 如果发现一个模块被多次引用，会直接返回已经执行的部分）；\n\n```\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n```\n\n```\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n\n```\n\n> ES6 模块输出的是值的只读引用；\n\n- 接口输出的变量是只读的，重新赋值会报错；\n- export 通过接口输出的是同一个值，得到的都是同样的实例；\n- 如果需要 import 支持动态加载 提案建议引入 import() 返回一个 promise 对象；\n\n参考资料：\n\n1. [ES6 模块与 CommonJS 模块的差异 ](http://es6.ruanyifeng.com/#docs/module-loader)\n\n## 38. 浏览器缓存\n\n    浏览器缓存分为 强缓存 和 协商缓存\n\n    1. 客户端先根据资源的http header判断是否命中强缓存，如果命中直接从缓存中读取；\n\n    2. 强缓存未命中，客户端发出请求，服务端根据请求的request header验证资源是否命中协商缓存，这个过程成为http再验证。如果命中，服务器将请求返回，状态码304，但不返回资源，而是告诉客服端可以从缓存读取；\n\n    3. 当协商缓存也没有命中，直接服务端返回资源给客户端；\n\n\n    强缓存\n\n    1. Expires 代表缓存过期时间；\n\n    2. Cache-Control： max-age  代表缓存最大生命周期；\n\n    协商缓存\n\n    1. Last-Modified 代表资源最后更新时间；\n\n    2. If-Modified-Since 代表 判断两次请求之间是否有过修改 没有直接返回协商缓存；\n\n## 39. 处理 js 双精度问题\n\n    ```javascript\n        0.1 + 0.2 = 0.30000000000000004\n    ```\n\n由于计算机是做二进制运算\n\n0.1 => 0.0001 1001 1001 1001…（无限循环）\n\n0.2 => 0.0011 0011 0011 0011…（无限循环）\n\n双精度浮点数的小数部分最多支持 52 位\n\n处理方法：\n\n    1. toFixed  不够严谨；\n    2. 把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。\n\n    ```javascript\n    ;(0.1 * 10 + 0.2 * 10) / 10 == 0.3\n    ```\n\n1. [个人封装的处理双精度方法 第 7 点](https://github.com/Megan-TA/UtilsJS)\n\n2. [关于 js 浮点数计算精度不准确问题的解决办法](https://www.cnblogs.com/xinggood/p/6639022.html)\n\n## 40. postMessage\n\n1. window.postMessage() 可以安全进行跨域、跨页面通信；\n1. 页面加载完成后才能进行跨域通信；\n\n发起端可以是 open 一个新窗口 或者 创建一个 iframe 往新窗口里发送数据\n\n案例:\n\n    ```javascript\n\n<!-- 客户端两种方式 -->\n\n<!-- 当前页面地址 http://www.webhek.com -->\n<!-- open方式 -->\n\n//弹出一个新窗口\nvar domain = 'http://fanyi.youdao.com';\nvar myPopup = window.open(domain, 'myWindow');\n\n//周期性的发送消息\nsetInterval(function(){\nvar message = 'Hello! The time is: ' + (new Date().getTime());\nconsole.log('blog.local: sending message: ' + message);\n//send the message and target URI\nmyPopup.postMessage(message,domain);\n},6000);\n\n<!-- iframe方式 -->\n\n//捕获 iframe\nvar domain = \"http://fanyi.youdao.com\";\nvar iframe = document.getElementById('myIFrame').contentWindow;\n\n//发送消息\nsetInterval(function(){\nvar message = 'Hello! The time is: ' + (new Date().getTime());\nconsole.log('blog.local: sending message: ' + message);\n//send the message and target URI\niframe.postMessage(message,domain);\n},6000);\n\n<!-- 接收端 -->\n\n//监听消息反馈\nwindow.addEventListener('message',function(event) {\nif(event.origin !== 'http://www.webhek.com') return;\nconsole.log('received response: ',event.data);\n},false);\n\n    ```\n\n> 截图如下：\n\n![web骇客网站  接收端截图](https://wx4.sinaimg.cn/mw690/006ANKB8gy1fqhqrhftfmj30yu0objvr.jpg)\n![有道翻译网站 接收端截图](https://wx2.sinaimg.cn/mw690/006ANKB8gy1fqhqri8fjlj30zk0h4tbk.jpg)\n\n> 参考资料\n\n1. [用 HTML5 里的 window.postMessage 在两个网页间传递数据](http://www.webhek.com/post/window-postmessage-api.html)\n\n## 41. Service Worker\n\n> 背景\n\n为了解决 web 业务不断增加带来更多消耗资源、耗时等复杂运算带来性能问题，w3c 初期提出 Web Worker 的 API，目的为了解放主线程。原理是 将复杂 耗时的操作独立出来交给 Web Worker，完成后通过 postMessage 方法告诉主线程。\n\n缺点：临时存在，不能永久；为此提出 Service Worker，在 Web Worker 基础上增加持久缓存能力。\n\n在 Service Worker 之前有 APPCache 这个持久缓存的 API，不过存在更新机主不完善，二次更新，大小限制，回滚等问题，具体参考下方链接 1。\n\nService Worker 的特性如下：\n\n- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n\n- 一旦被 install，就永远存在，除非被 uninstall\n\n- 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\n\n- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n\n- 离线内容开发者可控\n\n- 能向客户端推送消息\n\n- 不能直接操作 DOM\n\n- 出于安全的考虑，必须在 HTTPS 环境下才能工作\n\n- 异步实现，内部大都是通过 Promise 实现\n\n- 只能运行在 HTTPS 协议下\n\n> 参考资料\n\n1. [为什么 app cache 没有得到大规模应用？它有哪些硬伤吗？](https://www.zhihu.com/question/29876535)\n2. [Service Worker 简介](https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction)\n3. [如何优雅的为 PWA 注册 Service Worker](https://zhuanlan.zhihu.com/p/28161855)\n\n## 42 加载更多/下拉刷新\n\n原理：\n\nscrollTop（滚动条滚动距离） + clientHeight（可见区域高度） == scrollHeight（元素实际高度）\n\n备注：\n\noffsetHeighgt = height + padding + border\n\nclientHeight = height + padding\n\n## 43. js 标签中`async`和`defer`的作用与区别\n\n作用：\n\n1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。\n\n2.async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。\n\n3.defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。\n\n区别：\n\ndefer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。\n在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。\n","source":"_posts/js知识点总结.md","raw":"---\ntitle: js知识点总结\ncatalog: true\ndate: 2018-07-21 10:24:38\nsubtitle:\nheader-img:\ntags: javascript\n---\n\n# js 知识点总结\n\n## 1. 解码和编码\n\n> 原因：因为链接里面会有中文或者特殊字符号无法跳转需要进行相关编码解码\n\n**编码**\n\n>\n\n    'encodeURI': 只对查询的参数做编码\n\n    'encodeURIComponent': 对整个url做编码，包括? & / #\n\n```javascript\na = 'www.baidu.com/test?name=\"zhangsan\"'\nencodeURI(a) => 'www.baidu.com/test?name=%22zhangsan%22'\nencodeURIComponent(a) => 'www.baidu.com%2Ftest%3Fname%3D%22zhangsan%22'\n```\n\n**解码**\n\n>\n\n    'decodeURI': 只对查询参数做解码\n    'decodeURIComponent': 对整个URL做解码\n\n---\n\n## 2. 序列化和反序列化\n\n>\n\n```\nJSON.stringify()        // 序列化\nJSON.parse()            // 反序列化\n```\n\n使用 ajax 需要设置请求头部信息\n\nheader: {'Content-Type': 'application/json; charset=utf-8;'}\n\n> JSON.stringify() 可以简单的用来迅速判断两个对象是否相等，但不严谨（比如：序列化失败）\n\n---\n\n## 3. 日期\n\n```\nnew Date().getTime()   // 单位  秒\n// 获取当前时间   （存在兼容性）\nnew Date().toLocaleDateString() // 2017/7/24\nnew Date().toLocaleTimeString() // 下午5:07:33\nnew Date().toLocaleString()     // 2017/7/24 下午5:07:33\n// 若要显示24进制 需要option选项\nnew Date().toLocaleTimeString(\"UTC\",{ hour12: false })  // 17:20:16\n```\n\n---\n\n## 4. 回流/重绘\n\n1. 回流：几何属性发生变化 比如：内容、结构、位置或尺寸发生变化，需要重新计算样式和渲染树；\n\n2. 重绘：元素发生的改变只影响了节点的一些样式（背景色、边框色、文字颜色等）\n\n> 回流比重绘要消耗更多的资源\n\n---\n\n## 5. 锚点定位 scrollIntoView （无兼容问题）\n\n可以用来做一些 tab 定位\n\n```\ndocument.getElementById('xx').scrollIntoView()\n```\n\n---\n\n## 6. typeof 和 instanceof\n\n> ### typeof\n\n会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,function；\n\n缺点：\n\n- 不适用于来判断数组，因为不管是数组还是对象，都会返回 object。\n- 判断不了 null null 也是对象\n\n>\n\n```\ntypeof [1]      // Object\n```\n\n> ### instanceof\n\n返回的是一个布尔值 只能用来判断对象和函数\n\n```\nvar a = {};\nalert(  a instanceof Object )     // true\nvar a  = [];\nalert(  a instanceof Array )    // true\n```\n\n最靠谱也是最方便的办法使用`Object.prototype.toString.call()`来判断\n\n```javascript\nfunction types(target) {}\n```\n\n---\n\n## 7. requestAnimationFrame （RAF） 动画 api 兼容 Ie 8/9\n\n```\nvar i = 0\n\nwindow.requestAnimFrame = (function(){\n  return  window.requestAnimationFrame       ||\n          window.webkitRequestAnimationFrame ||\n          window.mozRequestAnimationFrame    ||\n          function( callback ){\n            window.setTimeout(callback, 1000 / 60);\n          };\n})()\n\nrequestAnimFrame(animloop)\n\nfunction animloop () {\n    document.getElementById('test').style.top = i ++\n}\n\n```\n\n### 优点\n\n    1. 解决毫秒的不精确性；\n    2. 避免过渡渲染；\n    3. 浏览器可以优化并行的动画动作，将合并的动作放入一个渲染周期；\n    4. 过程可控；\n\n> 动画效率之争\n\n    css3动画高效的原因有以下三点：\n\n        1. 强制使用硬件加速（GPU）；\n        2. 使用与RAF类似的机制；\n        3. 优化DOM操作 避免内存消耗来减少卡顿；\n\n    同时因为采用GPU， 导致浏览器一直出于高负荷运转，移动端电量损耗和一定卡顿，\n    而且css不能完全被js控制\n    pc上兼容性\n\njs 动画库 （比如 Velocity.js 和 GSAP）\n\n---\n\n## 8. 跨域\n\n1. ### JSONP\n\n   > 通过 js 标签引入一个 js 文件 这个 js 文件载入成功之后会执行我们在 url 参数中指定的函数 并且会吧我们需要的 json 数据作为参数传入\n   >\n   > 例如：url?item=1&callback=filter\n   >\n   > == 原生 js 实现 jsonp 的话 定义好 callback 的函数名称,动态创建 js 标签 url 加上查询的参数写好 callback 的回调函数名称即可 ==\n\n2. ### 利用 iframe 并修改 document.domain 来跨子域\n\n   两个不同域的页面引入 iframe 标签 同时将两个页面的主域设置成相同的域名\n\n   ![页面1](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox669ialYSHxewnD1B4L5UibVqhMnFEfibLhA8vUQu2s9rltB2HZ6UTQ19iag/0?wx_fmt=png)\n   ![页面2](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6Kv2iaHanjIzQHDNeia2FsoHSz8AJPkxh0IqickdbPg0CPeFPhoQMpuv5w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n3. ### window.name （可以配合 iframe）\n\n   同源窗口下 window.name 对所有页面都是共享的\n\n   每个页面对 window.name 都有读写权限\n\n   window.name 的值并不会因为新页面而重置\n\n4. widnow.postMessage （存在兼容性 IE7/8 不支持）\n\n   ！[页面 1](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6z8ibxywKPEusvEA2xS8ialrQ1Oxd0jw0V8C6f7Gicy6Obsyt5bicibxdx5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n   ！[页面 2](http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6B9Fpsa9KmNAMibvfSqE8Qv2icpLzzFE6NfvEp8YxWW6JOMTacIzaQzxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n\n5. Nginx 反向代理\n\n## 9. selection\n\n> 获取鼠标划过文本的对象\n\n> `window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();`\n\n---\n\n## 10. 正则表达式\n\n> 常用规则\n\n- \\n 回车\n- \\t 制表符\n- \\r 换行符\n- \\s 空格\n- \\u4e00-\\u9fa5 中文\n- \\w 大小写字母\\_数字\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- {n, m} 至少出现 n 次 最多 m 次\n- {n,} 至少 n 次\n- - 任意次\n- - 至少一次\n- {n} 至少 n 次\n- () 分组符号\n- [\\s\\S] 任意字符\n- ^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。\n- 正则的最后位置 , 就代表结束的意思\n\n匹配中文: [\\u4e00-\\u9fa5]\n\n例如：\n\n```\nvar str = '2013-6-7';\nvar re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-\nvar re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-\nvar re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-\n\n--------------------------\nvar str = '2013-6-7';\nvar re = /(\\d+)(-)/g;\n\nstr = str.replace(re,function($0,$1,$2){\n\n    //replace()中如果有子项，\n    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,\n    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )\n    return $1 + '.';  //分别返回2013.   6.\n\n});\n\n```\n\n- [] 表示某个集合中的任意一个\n- [^a] 排除 a\n\n```\n// var re = /\\bclassname\\b/;\n\n// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会\n// 把classname当做一个字符串去匹配。\n\nvar re = new RegExp('\\\\b'+classname+'\\\\b');\n\n// 匹配的时候，classname前面必须是起始或者空格，后面也是。\n\n默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。\n```\n\n---\n\n## 11. Object\n\n    1. constructor\n\n        实例的constructor 永远指向 构造函数 的 prototype.constructor\n\n        理解成 实例是基于构造函数原型链生成的对象\n\n```\n\nfunction A(x){\n    this.x = x;\n}\nvar newA = new A(name);\n\n此时：\nnewA.constructor == A.prototype.constructor;\n\n```\n\n    2. hasOwnProperty\n\n        判断对象上某个属性是否属于自身 属于自身为true, 原型链上为false\n\n```\n    function a () {\n        this.show = 'x';\n    }\n    a.prototype.hide = function () {\n        console.log(111111);\n    }\n    var z = new a();\n    z.hasOwnProperty('show');          // true\n    z.hasOwnProperty('hide');          // false\n```\n\n    3. isPrototypeOf\n\n        判断一个对象是否是另一个对象的原型\n\n```\n    var monkey = {\n        hair : true,\n        breathes : function(){\n            alert('1')\n        }\n    }\n    function Human(name){\n        this.name = name;\n    }\n    // Human的原型链绑定monkey对象\n    Human.prototype = monkey;\n\n    var man = new Human('张三');\n    monkey.isPrototypeOf(man);      // true\n\n```\n\n    4. prototype和__proto__\n\n        prototype是一个函数的内置属性（每个函数都有一个prototype属性）\n\n        __proto__ 是一个实例对象的内置属性 实例化的对象在内部通过此属性寻找原型链\n\n```\nvar Person = function () {}\nvar zhangsan = new Person ()\n\nzhansan.__prop__ = Person.prototype\n\nnew 的过程拆分成以下三步\n\n1. var p = {}\n2. p.__proto__ = Person.prototype\n3. Person.call(p)\n```\n\n    5. Object.getPrototypeOf\n\n        获取 实例化对象 原型链 的相关属性\n\n```\nfunction Test () {\n\n}\n\ntest.prototype.showName = function () {\n    console.log(1)\n}\n\nlet obj = new Test ()\nObject.getPrototypeOf(obj) == obj.__proto__\n\n```\n\n    6. Object.keys\n\n        可以用来枚举可遍历的属性 返回一个数组\n\n    7. Object.create\n\n        在原型链上创建对象属性\n\n```\n    <!-- 属性创建在原型链上 -->\n    Object.create({\n        name: '张三'\n    })\n\n    <!-- 字面量方式创建的对象属性挂在自身 -->\n    let test = {\n        name: '张三'\n    }\n\n```\n\n    8. Object.isExtensible\n\n        判断对象是否可以新增属性\n\n    9. Object.preventExtension\n\n        锁住对象 使其不能新增属性 但是原来的属性可以修改删除\n\n    10. Object.seal\n\n        密封对象 不能增加新属性 也不能删除旧属性  但是能修改原来的属性\n\n    11. Object.isSealed\n\n        判断对象是否密封\n\n    12. Object.freeze\n\n        冻结对象 不能新增 不能修改 不能删除\n\n    13. Object.isFrozen\n\n        判断对象是否完全被冻结\n\n    14. Object.getOwnPropertyNames\n\n        获取自身属性名字 返回一个数组\n\n    15. Object.getOwnPropertyDescriptor\n\n        判断某个对象上某个属性的状态描述\n\n    16. Object.defineProperty\n\n\n\n\n    -----------\n\n## 12. 继承\n\n> **调用另一个对象的方法，以另一个对象替换当前对象的上下文**\n>\n> > 缺点\n> >\n> > > 只能继承父级本身属性，原型链的属性无法继承\n\n- **call**\n  > 第二个参数可以省略\n- **apply**\n  > 第二个参数必须是数组或者用 arguments 代替\n- **bind**\n  > bind 与 call 和 apply 的区别在于 bind 是一个函数 不会立即执行 必须在后面再加上一对括号去立即执行\n\n```\n例子1：\n\nfunction Add(a,b)\n{\n    this.add = function(a,b){\n        alert(a+b)\n    };\n    this.xx = 333;\n}\nfunction Sub()\n{\n    this.sub = '张三';\n\n    // call方法\n    Add.call(this); // call继承Add所有方法(不包含原型链上的方法)\n\n    // apply方法  参数不能指定的时候用[]或者arguments代替\n    Add.apply(this, [])\n    // 又可以写成\n    Add.apply(this, arguments)\n\n    // bind方法\n    Add.bind(this)();\n}\n\nx = new Sub();\nx.add(5,7)                  // 11\n\n=====================================\n\n例子2：\n\n若只想继承父级构造函数某一个具体方法\n需要先将父子对象都实例化后 调用父级的具体方法call\n\nfunction Add(a,b)\n{\n    this.add = function(a,b){\n        alert(a+b)\n    };\n    this.xx = 333;\n}\nfunction Sub()\n{\n    this.sub = '张三';\n}\n\nnewAdd = new Add(7,8);\nnewSub = new Sub();\n\n// Sub只继承了Add的add方法并执行相关方法\n\ncall方法：\nnewAdd.add.call(newSub, 10, 4);      // 14\n\napply方法：\nnewAdd.add.apply(newSub, [10, 4]);   // 14\n\nbind方法：\nnewAdd.add.bind(newSub, 10, 4)();   // 14\n\n```\n\n>\n\n> > **注意**\n> >\n> > > 若想要全部继承父级所有相关属性 得采用==原型链继承==的方式\n\n```\nfunction person(){\n    this.hair = 'black';\n    this.eye = 'black';\n    this.skin = 'yellow';\n    this.view = function(){\n        return this.hair + ',' + this.eye + ',' + this.skin;\n    }\n}\nfunction man(){\n    this.feature = ['beard','strong'];\n}\nman.prototype = new person();\n\n```\n\n---\n\n## 13. cookie sessionStorage localStorage\n\n    1. cookie\n        * 4k的限制；\n        * 服务端和客户端传递时都会带上cookie；\n        * 本质上是对字符串的读取 存储内容过多消耗内存空间 导致页面变卡顿；\n        * 不能被爬虫读取；\n        * 设置时间之前一直有效，到时间就清除；\n    2. sessionStorage\n        * 临时存储：引入“浏览器窗口”的概念，同源同窗口数据不会销毁，不同标签页中数据不能共享，关闭浏览器时候销毁；\n        * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n        * 性能更好，即本地读取数据比服务器获取快多了；\n        * 不能跨tab标签页传值；\n    3. localStorage\n        * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n        * 体积更大 5M；\n        * 持久存储在本地，直到手动清除；\n\n```\nlocalStorage.setItem('sss',1111);\nlocalStorage.getItem('sss');\nlocalStorage.removeItem('sss');\nlocalStorage.clear();\n```\n\n---\n\n## 14. 闭包\n\n    简单回答闭包就是 一个函数返回自身内部函数的调用\n\n    为什么使用？\n\n    因为js是链式的 一层一层向上级查找 所以外部函数无法访问内部函数;\n\n> > 优点\n>\n> - 可以读取函数内部的变量，外部无法访问到里面变量;\n> - 函数在执行完毕不会被销毁 而是一直存在内存中;\n\n> > 缺点\n>\n> - 不会被内存回收 容易出现性能问题\n\n```\nfunction foo(){\n    var a = 2;\n\n    function bar(){\n        console.log(a);\n    }\n\n    return bar;\n}\nvar newFoo = foo();\nnewFoo();               // a\n\n```\n\n---\n\n## 15. 深拷贝和浅拷贝\n\n- **浅拷贝**\n  > **复制对象的副本 指向同一内存区域 对副本的操作会影响父级对象**\n\n浅拷贝方式：\n\n1. 直接赋值；\n2. Object.assign();\n3. JSON 序列化；\n\n- **深拷贝**\n  > **复制对象的副本 指向不同的内存区域 与父级对象独立**\n\n```\n// 浅拷贝\nvar a = {\n    name : 'zhangsan'\n}\n\nvar b = a;\nb.name = 'lisi';\n\nconsole.log(a.name);    // \"lisi\"\nconsole.log(b.name);    // \"lisi\"\n\n// 深拷贝  (更完整的深拷贝还需要再详细优化)\nfunction deepCopy(p, c){\n    var c = c || {};\n    for(var i in p ){\n        // 数组和对象的时候再处理\n        if(typeof p[i] === 'object'){\n            c[i] = (p[i].constructor === Array) ? [] : {};\n            deepCopy(p[i], c[i]);\n        }else{\n            // 基本类型直接赋值\n            c[i] = p[i]\n        }\n    }\n    return c;\n}\n\nvar parent = {\n    number: [1, 2, 3],\n    obj: {\n        prop: 1\n    }\n}\n\nvar copyParent = deepCopy(parent);\ncopyParent.number.push(4)\ncopyParent.number                   // 1,2,3,4\nparent.number                       // 1,2,3\n```\n\n---\n\n## 16. 传值类型和引用类型\n\n- **传值类型（基本类型）**\n  > 值为基本类型时候为深拷贝\n  >\n  > > 基本类型就是 null，undefined，Boolean，string，number\n  > >\n  > > > ==独立不干扰==\n- **引用类型**\n  > 值为对象类型时候为浅拷贝\n  >\n  > > 值都是对对象的引用，即一个指向对象的指针\n  > >\n  > > > ==对副本的操作会影响父级对象==\n\n```\n// 传值类型\nvar  a = 1;\nfunction voo(data)\n{\n    data = 2;\n    console.log(data);   // 2\n}\nvoo(a);\nconsole.log(a);    // 1\n\n// 引用类型\nvar  a = {\n    name : \"张三\"\n};\nfunction voo(data)\n{\n    data.name = \"李四\";\n    console.log(data);   //  Object {name: \"李四\"}\n}\nvoo(a);\nconsole.log(a);         //  Object {name: \"李四\"}\n\n// 引用类型不会被基本类型覆盖\nvar  a = {\n    name : \"张三\"\n};\nfunction voo(data)\n{\n    data = 3；\n    console.log(data);   // 3\n}\nvoo(a);\nconsole.log(a);         //  Object {name: \"张三\"}\n\n// 为了解决引用类型的问题  引入深拷贝的概念  参考上面一个概念\n\n```\n\n---\n\n## 17. 函数作用域提升与预编译\n\n> 由于 js 没有其他强类型语言{}这类的块级作用域 只有函数作用域 函数的声明很随意导致各种问题出现\n>\n> > 变量预编译 > 函数预编译\n\n```\n// 第一条\n\na();\nvar a = c = function() {\n    console.log(2)\n};\na();\n\nfunction a() {\n    console.log(1)\n};\na();\n(function(b) {\n    b(), c()\n    var b = c = function a() {\n        console.log(3)\n    }\n    b();\n})(a);\nc();\n\n// 等价于：\nvar a;                      // 变量声明提升\nfunction a() {              // 函数声明提升\n    console.log(1)\n};\na();                        // 1\na = c = function() {\n    console.log(2)\n};\n\na();                        // 2\n\n(function(b) {\n    var b\n    b()                     // 2\n    c()                     // 本来以error\n    // 后来有人指正 原因就在于var b=c=xxx。\n    // c相当于没有加var 不会预编译，这里c直接查找到外部作用域的c\n    b = c = function a() {\n        console.log(3)\n    }\n    b();                    // 3\n})(a);\n\nc();                        // 3\n\n\n// 第二条\nfunction fn(){\n    function a(){console.log(1)}\n    return a;\n    function a(){console.log(2)}\n}\nfn()();                     //2 由于预编译 后面的a覆盖了前面的a\n\n// 第三条\nvar a=10;\nfunction fn(){\n    // 预编译a 赋值undefined，内部作用域存在a这个变量，\n    // 所以这里 !a 就是  !undefined，就是true，进入函数a=20;\n    if (!a) {\n        var a=20\n    }\n    console.log(a)          //  这里是20 ，\n}\nfn()\n\n// 第四条\n<script>\n    console.log(typeof a)   //undefined\n    var a='littlebear';\n    console.log(a)          //littlebear\n</script>\n<script>\n    console.log(typeof a)   //string  第二个<script>标签里的a但会往上查找。\n    var a=1;\n    console.log(a)//1\n</script>\n\n// 第五条\n<script>\n    console.log(typeof a)   //undefined\n    console.log(a)\n    // 报错，遇到<script>标签对时，会先对这一块进行预解析，\n    // 下面没预解析，所以找不到声明过的a，于是报错了\n</script>\n<script>\n    console.log(typeof a)   //undefined\n    var a=1;\n    console.log(a)          //1\n</script>\n\n// 第六条\n<script>\n    function fn(a,b){\n        console.log(a)      //容易上当 初始化a的时候已经赋值'容易上当'\n        var a=10;\n        console.log(a)      //10\n    }\n    fn('容易上当');\n</script>\n\n```\n\n---\n\n## 18. AMD 和 CMD 区别\n\n1. AMD 推崇依赖前置。 （requireJS）\n\n   CMD 推崇依赖就近， （seaJS）\n\n```\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a')\n    a.doSomething()         // 此处略去 100 行\n    var b = require('./b')  // 依赖可以就近书写\n    b.doSomething()         // ...\n\n})\n// AMD 默认推荐\ndefine(['./a', './b'], function(a, b) {\n    // 依赖必须一开始就写好\n    a.doSomething()    // 此处略去 100 行\n    b.doSomething()\n})\n```\n\n2.  对于依赖的模块，\n\n    AMD 是提前执行（预执行），\n\n    CMD 是延迟执行（懒执行）。\n\n> 不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.\n\n3.  AMD 的 API 默认是一个当多个用，\n\n    CMD 的 API 严格区分，推崇职责单一\n\n> 比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。\n\n---\n\n## 19. 常见服务器的状态码\n\n- 304\n\n  Not Modified\n\n  客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n\n- 400\n\n  Bad Request\n\n  表示该请求报文中存在语法错误，导致服务器无法理解该请求。\n\n- 403\n\n  Forbidden\n\n  该状态码表明对请求资源的访问被服务器拒绝了。\n\n- 500\n\n  Internal Server Error\n\n  该状态码表明服务器端在执行请求时发生了错误。\n\n- 502\n\n  上游网关错误\n\n- 301\n\n  永久重定向\n\n- 302\n\n  临时重定向 会出现 URL 劫持 体现在搜索引擎收录策略上 会改变原有请求方法\n\n- 307\n\n  临时重定向 与 302 区别 客户端应`保持请求方法`不变向新的地址发出请求\n\n---\n\n## 20. 事件冒泡和事件捕获\n\n    * 事件冒泡兼容写法\n\n    ```\n    if (event.cancelBubble) {\n        event.cancelBubble = true\n    } else {\n        event.stopPropagation()\n    }\n    ```\n    --------------------------\n\n## 21. 数组\n\n    1. push\n\n        向数组末尾添加指定元素\n\n    2. pop\n\n        移除数组末尾的一个元素 并返回移除的元素\n\n    3. shift\n\n        移除数组第一项 并返回该元素\n\n    4. unshift\n\n        给数组第一项加上一个元素 返回数组长度\n\n    5. join\n\n        数组按照指定的字符换转成字符串\n\n    6. sort\n\n        数组按照ASCII排序  所以要完全按照从小到大的顺序排序的话需要指定参数 1 -1 0\n\n    7. splice\n\n        从0开始\n\n    > 删除 ---------------------（**起始位置，截取个数**）\n\n    > 插入 ---------------------（**起始位置，截取个数为0，要插入的项**）\n\n    > 替换----------------------（**起始位置，截取个数为1，要插入的项**）\n\n    8. slice\n\n    9. concat\n\n    10. reverse\n\n    11. 遍历数组的方法\n\n        > forEach\n        > for in\n\n        两者区别 在于 for in 会遍历数组原型链的属性值\n\n        为了避免这样的情况 使用 hasOwnProperty 解决\n\n---\n\n## 22.正则\n\n- ()：小括号，叫做分组符。\n- \\s : 空格\n- \\S : 非空格\n- \\d : 数字\n- \\D : 非数字\n- \\w : 字符 ( 字母 ，数字，下划线\\_ )\n- \\W : 非字符\n- .（点）——任意字符\n- \\. : 真正的点\n- \\b : 独立的部分 （ 起始，结束，空格 ）\n- \\B : 非独立的部分\n- {n,m}：至少出现 n 次，最多 m 次\n- {n,} :至少 n 次\n- - :任意次 相当于{0,}\n- ？ ：零次或一次 相当于{0,1}\n- - ：一次或任意次相当于 {1,}\n- {n}： 正好 n 次\n- [] ： 表示某个集合中的任意一个 不能为空\n\n---\n\n> ### 字符串相关的正则方法\n\n- ### match()\n\n> 返回一个包含匹配内容的数组\n\n```\nvar str = 'abcdef';\n\nvar re = /B/i;\n\nstr.match(re) // [b]\n```\n\n例子 2：\n\n```\nurl = https://dimg.fws.qa.nt.ctripcorp.com/images/2d090m000000062hy59E5.jpg\"\nurl.match(/[^\\/]*$/) // 2d090m000000062hy59E5.jpg\nurl.match(/^[^\\/]*/) // https\n```\n\n- ### search()\n\n> 返回匹配到的第一个内容所在的位置\n\n```\nvar str = 'abcdef';\n\nvar re = /B/i;\n\nstr.search(re) // 1\n\n```\n\n- ### replace()\n\n> 查找符合正则的字符串并替换成==一个==对应的字符串。返回替换后的内容。\n\n```\nvar str = \"我爱北京天安门，天安门上太阳升。\";\nvar re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配\nvar str2 = str.replace(re,'*'); // 我爱**，*上太阳升。\n\n```\n\n并不能解决一个文字\\*的对应\n\n```\nvar str = \"我爱北京天安门，天安门上太阳升。\";\nvar re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配\nvar str2 = str.replace(re,function(str){\n            alert(str);\n            //用来测试：参数代表每次搜索到的符合正则的字符，\n            //所以第一次str指的是北京 第二次str是天安门 第三次str是天安门\n            var result = '';\n            for(var i=0;i<str.length;i++){\n                result += '*';\n            }\n            return result; //所以搜索到了几个字就返回几个*\n        });\nalert(str2)\n```\n\n    ```\n    var str = '2013-6-7';\n    var re = /(\\d+)(-)/g;\n\n    str = str.replace(re,function($0,$1,$2){\n            // replace()中如果有子项，\n            // 第一个参数 ：$0（匹配成功后的整体结果  2013-  6-）,\n            // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)\n            // 第三个参数 : $2(匹配成功的第二个分组，这里指的是-    - - )\n        return $1 + '.';  //分别返回2013.   6.\n    });\n\n    alert( str );   //2013.6.7\n    //整个过程就是利用子项把2013- 6- 分别替换成了2013. 6.  最终弹出2013.6.7\n    ```\n\n---\n\n### 正则两个方法\n\n- ### test()\n\n> 匹配到指定内容返回 true\n\n- ### ==exec()==\n\n> 返回第一匹配项信息的数组 若没有返回 null\n> 有两个属性 index input\n\n    ```\n    var text = 'mom and dad and baby'\n    var pattern = /mom( and dad( and baby)?)?/gi\n    var matches = pattern.exec(text)\n    mathes.index // 0\n    mathes.input // mom and dad and baby\n    mathes[0] // mom and dad and baby\n    mathes[1] //  and dad and baby\n    mathes[2] // and baby\n    ```\n\n## 23. 后退监听\n\n> history.back() history.forward() history.replace()触发 onpopstate 事件\n\n    ```\n    window.onpopstate = function () {\n        alert('2222')\n        history.pushState(null, null, document.URL)\n        return false\n    }\n    history.pushState(null, null, document.URL)\n    ```\n\n    onbeforeunload事件有坑 chrome51版本及以后不能自定义文字 并且 页面载入之后一定要有浏览器行为才能触发\n\n## 24. base64 图片及相关验证码\n\n> data:image/gif;base64, (base64 地址)\n\n    ```\n    if (result == null || result.length == 0) return\n    result = $.parseJSON(result)\n    var id = result['id']\n    var imgUrl = result['base64Buffer']\n    $('#js-code').attr('src', 'data:image/gif;base64,' + imgUrl)\n\n    ```\n\n## 26. from 包裹的元素 document 事件失效 必须给 from 加事件\n\n## 27. 进制转换\n\n> 十进制转十六进制\n\n    ```\n    var s = 255\n    s.toString(16) // ff\n    ```\n\n> 十六进制转十进制\n\n    ```\n    parseInt('0xFF')   // 255\n    ```\n\n## 28. label 绑定事件一定要让事件委托到触发里面的 input\n\n    所以事件委托的时候直接监听input\n\n## 29. 跨域 post 请求转为 options 类型\n\n## 30. Math\n\n    1. Math.floor 向下舍入；\n    2. Math.ceil  向上舍入;\n    3. Math.cos   余弦;\n    4. Math.round 四舍五入;\n    5. Math.sin   正弦；\n    6. Math.tan   正切；\n\n## 31. isNaN\n\n    首先需要知道 '' == 0   'abc' != 0   [] == 0  [1] != 0   null == 0  {} != 0  undefined != 0\n\n    ```\n    isNaN('')   // false\n    isNaN(' ')  // false\n    isNaN('abc') // true\n    isNaN(undefined) // true\n    isNaN([])   // false\n    isNaN({})   // true\n    isNaN(null) // false\n\n    ```\n\n## 32. Boolen\n\n    首先需要知道  0 == false    1 == true  '' == false   undefined != false != true    null != false != true\n\n    ```\n    Boolean('') // false\n    Boolean('ssss') // true\n    Boolean([])  // true\n    Boolean([1,2])  // true\n    Boolen({})      // true\n    Boolen(null)    // false\n    Boolen(undefined)   // false\n    ```\n\n## 33. 解决回调地狱 （多级回调）\n\n    1. Promise\n\n    2. aSync/await\n\n    3. generator\n\n## 34. 字符串\n\n    1. slice\n\n        在 不修改目标数组 的情况下返回截取的指定元素（ **起始位置，截止位置**）\n\n        从0开始 ==不包含最后一个数值==\n\n        负数情况下 将负数加上自身长度得到的数值作为参数\n\n    2. substr\n\n        subdtr接收的是 起始位置 和 所要返回的字符串长度\n\n        在负数情况下  将第一个参数与字符串长度相加后的数值作为第一个参数\n\n    3. substring\n\n        默认会将较小的参数作为第一个参数\n\n        在 不修改目标数组 的情况下返回截取的指定元素 （ **起始位置，截止位置**）\n\n        负数当做0处理\n\n```\nlet test = 'abcdef'\ntest.slice(0, -1)   // abcde\ntest.slice(2, -3)   => test.slice(2,3)  // c\n\ntest.substring(1, -2) => a\ntest.substring(2, -3) => ab\n```\n\n    4. split\n\n        字符串按照指定规则转换成数组\n\n## 35. let 与 var 区别\n\n    1. var存在变量提升， let不存在；\n    2. let不允许重复声明；\n    3. var挂载在window下，let挂载在块作用域下；\n\n## 36. 为什么 var 可以重复声明\n\n    因为js运行过程中，\n\n    引擎 负责整个代码编译和运行\n\n    编译器 负责词法分析、语法分析、代码生成等工作\n\n    编译器从左至右编译var a，如果a不存在则在作用域声明一个新的变量a，若存在a则忽略继续向下编译；\n\n    引擎遇到a = 2，按照作用域链向上查找 若存在变量a直接赋值，不存在则在作用域重新声明新的变量并赋值2\n\n## 37. CommonJS 中的 require/exports 和 ES6 的 import/export 有什么区别\n\n1.\n\n> CommomJS 模块 require 代码时候会立刻执行；\n\n> ES6 模块是动态引用，不会立刻执行，仅仅作为一个加载模块的对象引用；\n\n2.\n\n> CommonJs 模块输出的是一个值的拷贝， 输出后的对象会被缓存（即 如果发现一个模块被多次引用，会直接返回已经执行的部分）；\n\n```\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n```\n\n```\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n\n```\n\n> ES6 模块输出的是值的只读引用；\n\n- 接口输出的变量是只读的，重新赋值会报错；\n- export 通过接口输出的是同一个值，得到的都是同样的实例；\n- 如果需要 import 支持动态加载 提案建议引入 import() 返回一个 promise 对象；\n\n参考资料：\n\n1. [ES6 模块与 CommonJS 模块的差异 ](http://es6.ruanyifeng.com/#docs/module-loader)\n\n## 38. 浏览器缓存\n\n    浏览器缓存分为 强缓存 和 协商缓存\n\n    1. 客户端先根据资源的http header判断是否命中强缓存，如果命中直接从缓存中读取；\n\n    2. 强缓存未命中，客户端发出请求，服务端根据请求的request header验证资源是否命中协商缓存，这个过程成为http再验证。如果命中，服务器将请求返回，状态码304，但不返回资源，而是告诉客服端可以从缓存读取；\n\n    3. 当协商缓存也没有命中，直接服务端返回资源给客户端；\n\n\n    强缓存\n\n    1. Expires 代表缓存过期时间；\n\n    2. Cache-Control： max-age  代表缓存最大生命周期；\n\n    协商缓存\n\n    1. Last-Modified 代表资源最后更新时间；\n\n    2. If-Modified-Since 代表 判断两次请求之间是否有过修改 没有直接返回协商缓存；\n\n## 39. 处理 js 双精度问题\n\n    ```javascript\n        0.1 + 0.2 = 0.30000000000000004\n    ```\n\n由于计算机是做二进制运算\n\n0.1 => 0.0001 1001 1001 1001…（无限循环）\n\n0.2 => 0.0011 0011 0011 0011…（无限循环）\n\n双精度浮点数的小数部分最多支持 52 位\n\n处理方法：\n\n    1. toFixed  不够严谨；\n    2. 把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。\n\n    ```javascript\n    ;(0.1 * 10 + 0.2 * 10) / 10 == 0.3\n    ```\n\n1. [个人封装的处理双精度方法 第 7 点](https://github.com/Megan-TA/UtilsJS)\n\n2. [关于 js 浮点数计算精度不准确问题的解决办法](https://www.cnblogs.com/xinggood/p/6639022.html)\n\n## 40. postMessage\n\n1. window.postMessage() 可以安全进行跨域、跨页面通信；\n1. 页面加载完成后才能进行跨域通信；\n\n发起端可以是 open 一个新窗口 或者 创建一个 iframe 往新窗口里发送数据\n\n案例:\n\n    ```javascript\n\n<!-- 客户端两种方式 -->\n\n<!-- 当前页面地址 http://www.webhek.com -->\n<!-- open方式 -->\n\n//弹出一个新窗口\nvar domain = 'http://fanyi.youdao.com';\nvar myPopup = window.open(domain, 'myWindow');\n\n//周期性的发送消息\nsetInterval(function(){\nvar message = 'Hello! The time is: ' + (new Date().getTime());\nconsole.log('blog.local: sending message: ' + message);\n//send the message and target URI\nmyPopup.postMessage(message,domain);\n},6000);\n\n<!-- iframe方式 -->\n\n//捕获 iframe\nvar domain = \"http://fanyi.youdao.com\";\nvar iframe = document.getElementById('myIFrame').contentWindow;\n\n//发送消息\nsetInterval(function(){\nvar message = 'Hello! The time is: ' + (new Date().getTime());\nconsole.log('blog.local: sending message: ' + message);\n//send the message and target URI\niframe.postMessage(message,domain);\n},6000);\n\n<!-- 接收端 -->\n\n//监听消息反馈\nwindow.addEventListener('message',function(event) {\nif(event.origin !== 'http://www.webhek.com') return;\nconsole.log('received response: ',event.data);\n},false);\n\n    ```\n\n> 截图如下：\n\n![web骇客网站  接收端截图](https://wx4.sinaimg.cn/mw690/006ANKB8gy1fqhqrhftfmj30yu0objvr.jpg)\n![有道翻译网站 接收端截图](https://wx2.sinaimg.cn/mw690/006ANKB8gy1fqhqri8fjlj30zk0h4tbk.jpg)\n\n> 参考资料\n\n1. [用 HTML5 里的 window.postMessage 在两个网页间传递数据](http://www.webhek.com/post/window-postmessage-api.html)\n\n## 41. Service Worker\n\n> 背景\n\n为了解决 web 业务不断增加带来更多消耗资源、耗时等复杂运算带来性能问题，w3c 初期提出 Web Worker 的 API，目的为了解放主线程。原理是 将复杂 耗时的操作独立出来交给 Web Worker，完成后通过 postMessage 方法告诉主线程。\n\n缺点：临时存在，不能永久；为此提出 Service Worker，在 Web Worker 基础上增加持久缓存能力。\n\n在 Service Worker 之前有 APPCache 这个持久缓存的 API，不过存在更新机主不完善，二次更新，大小限制，回滚等问题，具体参考下方链接 1。\n\nService Worker 的特性如下：\n\n- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n\n- 一旦被 install，就永远存在，除非被 uninstall\n\n- 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\n\n- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n\n- 离线内容开发者可控\n\n- 能向客户端推送消息\n\n- 不能直接操作 DOM\n\n- 出于安全的考虑，必须在 HTTPS 环境下才能工作\n\n- 异步实现，内部大都是通过 Promise 实现\n\n- 只能运行在 HTTPS 协议下\n\n> 参考资料\n\n1. [为什么 app cache 没有得到大规模应用？它有哪些硬伤吗？](https://www.zhihu.com/question/29876535)\n2. [Service Worker 简介](https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction)\n3. [如何优雅的为 PWA 注册 Service Worker](https://zhuanlan.zhihu.com/p/28161855)\n\n## 42 加载更多/下拉刷新\n\n原理：\n\nscrollTop（滚动条滚动距离） + clientHeight（可见区域高度） == scrollHeight（元素实际高度）\n\n备注：\n\noffsetHeighgt = height + padding + border\n\nclientHeight = height + padding\n\n## 43. js 标签中`async`和`defer`的作用与区别\n\n作用：\n\n1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。\n\n2.async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。\n\n3.defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。\n\n区别：\n\ndefer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。\n在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。\n","slug":"js知识点总结","published":1,"updated":"2019-12-18T14:13:08.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5569840002agu1p84vmkvx1","content":"<h1><span id=\"js-知识点总结\">js 知识点总结</span></h1>\n<h2><span id=\"1-解码和编码\">1. 解码和编码</span></h2>\n<blockquote>\n<p>原因：因为链接里面会有中文或者特殊字符号无法跳转需要进行相关编码解码</p>\n</blockquote>\n<p><strong>编码</strong></p>\n<blockquote></blockquote>\n<pre><code>'encodeURI': 只对查询的参数做编码\n\n'encodeURIComponent': 对整个url做编码，包括? &amp; / #\n</code></pre>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">'www.baidu.com/test?name=\"zhangsan\"'</span></span><br><span class=\"line\"><span class=\"built_in\">encodeURI</span>(a) =&gt; <span class=\"string\">'www.baidu.com/test?name=%22zhangsan%22'</span></span><br><span class=\"line\"><span class=\"built_in\">encodeURIComponent</span>(a) =&gt; <span class=\"string\">'www.baidu.com%2Ftest%3Fname%3D%22zhangsan%22'</span></span><br></pre></td></tr></table></figure>\n<p><strong>解码</strong></p>\n<blockquote></blockquote>\n<pre><code>'decodeURI': 只对查询参数做解码\n'decodeURIComponent': 对整个URL做解码\n</code></pre>\n<hr>\n<h2><span id=\"2-序列化和反序列化\">2. 序列化和反序列化</span></h2>\n<blockquote></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify()        // 序列化</span><br><span class=\"line\">JSON.parse()            // 反序列化</span><br></pre></td></tr></table></figure>\n<p>使用 ajax 需要设置请求头部信息</p>\n<p>header: {‘Content-Type’: ‘application/json; charset=utf-8;’}</p>\n<blockquote>\n<p>JSON.stringify() 可以简单的用来迅速判断两个对象是否相等，但不严谨（比如：序列化失败）</p>\n</blockquote>\n<hr>\n<h2><span id=\"3-日期\">3. 日期</span></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Date().getTime()   // 单位  秒</span><br><span class=\"line\">// 获取当前时间   （存在兼容性）</span><br><span class=\"line\">new Date().toLocaleDateString() // 2017/7/24</span><br><span class=\"line\">new Date().toLocaleTimeString() // 下午5:07:33</span><br><span class=\"line\">new Date().toLocaleString()     // 2017/7/24 下午5:07:33</span><br><span class=\"line\">// 若要显示24进制 需要option选项</span><br><span class=\"line\">new Date().toLocaleTimeString(&quot;UTC&quot;,&#123; hour12: false &#125;)  // 17:20:16</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"4-回流重绘\">4. 回流/重绘</span></h2>\n<ol>\n<li>\n<p>回流：几何属性发生变化 比如：内容、结构、位置或尺寸发生变化，需要重新计算样式和渲染树；</p>\n</li>\n<li>\n<p>重绘：元素发生的改变只影响了节点的一些样式（背景色、边框色、文字颜色等）</p>\n</li>\n</ol>\n<blockquote>\n<p>回流比重绘要消耗更多的资源</p>\n</blockquote>\n<hr>\n<h2><span id=\"5-锚点定位-scrollintoview-无兼容问题\">5. 锚点定位 scrollIntoView （无兼容问题）</span></h2>\n<p>可以用来做一些 tab 定位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;xx&apos;).scrollIntoView()</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"6-typeof-和-instanceof\">6. typeof 和 instanceof</span></h2>\n<blockquote>\n<h3><span id=\"typeof\">typeof</span></h3>\n</blockquote>\n<p>会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,function；</p>\n<p>缺点：</p>\n<ul>\n<li>不适用于来判断数组，因为不管是数组还是对象，都会返回 object。</li>\n<li>判断不了 null null 也是对象</li>\n</ul>\n<blockquote></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof [1]      // Object</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h3><span id=\"instanceof\">instanceof</span></h3>\n</blockquote>\n<p>返回的是一个布尔值 只能用来判断对象和函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;&#125;;</span><br><span class=\"line\">alert(  a instanceof Object )     // true</span><br><span class=\"line\">var a  = [];</span><br><span class=\"line\">alert(  a instanceof Array )    // true</span><br></pre></td></tr></table></figure>\n<p>最靠谱也是最方便的办法使用<code>Object.prototype.toString.call()</code>来判断</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">types</span>(<span class=\"params\">target</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"7-requestanimationframe-raf-动画-api-兼容-ie-89\">7. requestAnimationFrame （RAF） 动画 api 兼容 Ie 8/9</span></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i = 0</span><br><span class=\"line\"></span><br><span class=\"line\">window.requestAnimFrame = (function()&#123;</span><br><span class=\"line\">  return  window.requestAnimationFrame       ||</span><br><span class=\"line\">          window.webkitRequestAnimationFrame ||</span><br><span class=\"line\">          window.mozRequestAnimationFrame    ||</span><br><span class=\"line\">          function( callback )&#123;</span><br><span class=\"line\">            window.setTimeout(callback, 1000 / 60);</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\">requestAnimFrame(animloop)</span><br><span class=\"line\"></span><br><span class=\"line\">function animloop () &#123;</span><br><span class=\"line\">    document.getElementById(&apos;test&apos;).style.top = i ++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"优点\">优点</span></h3>\n<pre><code>1. 解决毫秒的不精确性；\n2. 避免过渡渲染；\n3. 浏览器可以优化并行的动画动作，将合并的动作放入一个渲染周期；\n4. 过程可控；\n</code></pre>\n<blockquote>\n<p>动画效率之争</p>\n</blockquote>\n<pre><code>css3动画高效的原因有以下三点：\n\n    1. 强制使用硬件加速（GPU）；\n    2. 使用与RAF类似的机制；\n    3. 优化DOM操作 避免内存消耗来减少卡顿；\n\n同时因为采用GPU， 导致浏览器一直出于高负荷运转，移动端电量损耗和一定卡顿，\n而且css不能完全被js控制\npc上兼容性\n</code></pre>\n<p>js 动画库 （比如 Velocity.js 和 GSAP）</p>\n<hr>\n<h2><span id=\"8-跨域\">8. 跨域</span></h2>\n<ol>\n<li>\n<h3><span id=\"jsonp\">JSONP</span></h3>\n<blockquote>\n<p>通过 js 标签引入一个 js 文件 这个 js 文件载入成功之后会执行我们在 url 参数中指定的函数 并且会吧我们需要的 json 数据作为参数传入</p>\n<p>例如：url?item=1&amp;callback=filter</p>\n<p>== 原生 js 实现 jsonp 的话 定义好 callback 的函数名称,动态创建 js 标签 url 加上查询的参数写好 callback 的回调函数名称即可 ==</p>\n</blockquote>\n</li>\n<li>\n<h3><span id=\"利用-iframe-并修改-documentdomain-来跨子域\">利用 iframe 并修改 document.domain 来跨子域</span></h3>\n<p>两个不同域的页面引入 iframe 标签 同时将两个页面的主域设置成相同的域名</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox669ialYSHxewnD1B4L5UibVqhMnFEfibLhA8vUQu2s9rltB2HZ6UTQ19iag/0?wx_fmt=png\" alt=\"页面1\"><br>\n<img src=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6Kv2iaHanjIzQHDNeia2FsoHSz8AJPkxh0IqickdbPg0CPeFPhoQMpuv5w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"页面2\"></p>\n</li>\n<li>\n<h3><span id=\"windowname-可以配合-iframe\"> （可以配合 iframe）</span></h3>\n<p>同源窗口下 <a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 对所有页面都是共享的</p>\n<p>每个页面对 <a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 都有读写权限</p>\n<p><a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 的值并不会因为新页面而重置</p>\n</li>\n<li>\n<p>widnow.postMessage （存在兼容性 IE7/8 不支持）</p>\n<p>！<a href=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6z8ibxywKPEusvEA2xS8ialrQ1Oxd0jw0V8C6f7Gicy6Obsyt5bicibxdx5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"noopener\">页面 1</a></p>\n<p>！<a href=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6B9Fpsa9KmNAMibvfSqE8Qv2icpLzzFE6NfvEp8YxWW6JOMTacIzaQzxw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"noopener\">页面 2</a></p>\n</li>\n<li>\n<p>Nginx 反向代理</p>\n</li>\n</ol>\n<h2><span id=\"9-selection\">9. selection</span></h2>\n<blockquote>\n<p>获取鼠标划过文本的对象</p>\n</blockquote>\n<blockquote>\n<p><code>window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();</code></p>\n</blockquote>\n<hr>\n<h2><span id=\"10-正则表达式\">10. 正则表达式</span></h2>\n<blockquote>\n<p>常用规则</p>\n</blockquote>\n<ul>\n<li>\\n 回车</li>\n<li>\\t 制表符</li>\n<li>\\r 换行符</li>\n<li>\\s 空格</li>\n<li>\\u4e00-\\u9fa5 中文</li>\n<li>\\w 大小写字母_数字</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>{n, m} 至少出现 n 次 最多 m 次</li>\n<li>{n,} 至少 n 次</li>\n<li>\n<ul>\n<li>任意次</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>至少一次</li>\n</ul>\n</li>\n<li>{n} 至少 n 次</li>\n<li>() 分组符号</li>\n<li>[\\s\\S] 任意字符</li>\n<li>^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。</li>\n<li>正则的最后位置 , 就代表结束的意思</li>\n</ul>\n<p>匹配中文: [\\u4e00-\\u9fa5]</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-</span><br><span class=\"line\">var re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-</span><br><span class=\"line\">var re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------</span><br><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //replace()中如果有子项，</span><br><span class=\"line\">    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[] 表示某个集合中的任意一个</li>\n<li>[^a] 排除 a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var re = /\\bclassname\\b/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会</span><br><span class=\"line\">// 把classname当做一个字符串去匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">var re = new RegExp(&apos;\\\\b&apos;+classname+&apos;\\\\b&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配的时候，classname前面必须是起始或者空格，后面也是。</span><br><span class=\"line\"></span><br><span class=\"line\">默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"11-object\">11. Object</span></h2>\n<pre><code>1. constructor\n\n    实例的constructor 永远指向 构造函数 的 prototype.constructor\n\n    理解成 实例是基于构造函数原型链生成的对象\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function A(x)&#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newA = new A(name);</span><br><span class=\"line\"></span><br><span class=\"line\">此时：</span><br><span class=\"line\">newA.constructor == A.prototype.constructor;</span><br></pre></td></tr></table></figure>\n<pre><code>2. hasOwnProperty\n\n    判断对象上某个属性是否属于自身 属于自身为true, 原型链上为false\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a () &#123;</span><br><span class=\"line\">    this.show = &apos;x&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.prototype.hide = function () &#123;</span><br><span class=\"line\">    console.log(111111);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var z = new a();</span><br><span class=\"line\">z.hasOwnProperty(&apos;show&apos;);          // true</span><br><span class=\"line\">z.hasOwnProperty(&apos;hide&apos;);          // false</span><br></pre></td></tr></table></figure>\n<pre><code>3. isPrototypeOf\n\n    判断一个对象是否是另一个对象的原型\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var monkey = &#123;</span><br><span class=\"line\">    hair : true,</span><br><span class=\"line\">    breathes : function()&#123;</span><br><span class=\"line\">        alert(&apos;1&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Human(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Human的原型链绑定monkey对象</span><br><span class=\"line\">Human.prototype = monkey;</span><br><span class=\"line\"></span><br><span class=\"line\">var man = new Human(&apos;张三&apos;);</span><br><span class=\"line\">monkey.isPrototypeOf(man);      // true</span><br></pre></td></tr></table></figure>\n<pre><code>4. prototype和__proto__\n\n    prototype是一个函数的内置属性（每个函数都有一个prototype属性）\n\n    __proto__ 是一个实例对象的内置属性 实例化的对象在内部通过此属性寻找原型链\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Person = function () &#123;&#125;</span><br><span class=\"line\">var zhangsan = new Person ()</span><br><span class=\"line\"></span><br><span class=\"line\">zhansan.__prop__ = Person.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">new 的过程拆分成以下三步</span><br><span class=\"line\"></span><br><span class=\"line\">1. var p = &#123;&#125;</span><br><span class=\"line\">2. p.__proto__ = Person.prototype</span><br><span class=\"line\">3. Person.call(p)</span><br></pre></td></tr></table></figure>\n<pre><code>5. Object.getPrototypeOf\n\n    获取 实例化对象 原型链 的相关属性\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Test () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test.prototype.showName = function () &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj = new Test ()</span><br><span class=\"line\">Object.getPrototypeOf(obj) == obj.__proto__</span><br></pre></td></tr></table></figure>\n<pre><code>6. Object.keys\n\n    可以用来枚举可遍历的属性 返回一个数组\n\n7. Object.create\n\n    在原型链上创建对象属性\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 属性创建在原型链上 --&gt;</span><br><span class=\"line\">Object.create(&#123;</span><br><span class=\"line\">    name: &apos;张三&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 字面量方式创建的对象属性挂在自身 --&gt;</span><br><span class=\"line\">let test = &#123;</span><br><span class=\"line\">    name: &apos;张三&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>8. Object.isExtensible\n\n    判断对象是否可以新增属性\n\n9. Object.preventExtension\n\n    锁住对象 使其不能新增属性 但是原来的属性可以修改删除\n\n10. Object.seal\n\n    密封对象 不能增加新属性 也不能删除旧属性  但是能修改原来的属性\n\n11. Object.isSealed\n\n    判断对象是否密封\n\n12. Object.freeze\n\n    冻结对象 不能新增 不能修改 不能删除\n\n13. Object.isFrozen\n\n    判断对象是否完全被冻结\n\n14. Object.getOwnPropertyNames\n\n    获取自身属性名字 返回一个数组\n\n15. Object.getOwnPropertyDescriptor\n\n    判断某个对象上某个属性的状态描述\n\n16. Object.defineProperty\n\n\n\n\n-----------\n</code></pre>\n<h2><span id=\"12-继承\">12. 继承</span></h2>\n<blockquote>\n<p><strong>调用另一个对象的方法，以另一个对象替换当前对象的上下文</strong></p>\n<blockquote>\n<p>缺点</p>\n<blockquote>\n<p>只能继承父级本身属性，原型链的属性无法继承</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li><strong>call</strong>\n<blockquote>\n<p>第二个参数可以省略</p>\n</blockquote>\n</li>\n<li><strong>apply</strong>\n<blockquote>\n<p>第二个参数必须是数组或者用 arguments 代替</p>\n</blockquote>\n</li>\n<li><strong>bind</strong>\n<blockquote>\n<p>bind 与 call 和 apply 的区别在于 bind 是一个函数 不会立即执行 必须在后面再加上一对括号去立即执行</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子1：</span><br><span class=\"line\"></span><br><span class=\"line\">function Add(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.add = function(a,b)&#123;</span><br><span class=\"line\">        alert(a+b)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.xx = 333;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.sub = &apos;张三&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // call方法</span><br><span class=\"line\">    Add.call(this); // call继承Add所有方法(不包含原型链上的方法)</span><br><span class=\"line\"></span><br><span class=\"line\">    // apply方法  参数不能指定的时候用[]或者arguments代替</span><br><span class=\"line\">    Add.apply(this, [])</span><br><span class=\"line\">    // 又可以写成</span><br><span class=\"line\">    Add.apply(this, arguments)</span><br><span class=\"line\"></span><br><span class=\"line\">    // bind方法</span><br><span class=\"line\">    Add.bind(this)();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">x = new Sub();</span><br><span class=\"line\">x.add(5,7)                  // 11</span><br><span class=\"line\"></span><br><span class=\"line\">=====================================</span><br><span class=\"line\"></span><br><span class=\"line\">例子2：</span><br><span class=\"line\"></span><br><span class=\"line\">若只想继承父级构造函数某一个具体方法</span><br><span class=\"line\">需要先将父子对象都实例化后 调用父级的具体方法call</span><br><span class=\"line\"></span><br><span class=\"line\">function Add(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.add = function(a,b)&#123;</span><br><span class=\"line\">        alert(a+b)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.xx = 333;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.sub = &apos;张三&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">newAdd = new Add(7,8);</span><br><span class=\"line\">newSub = new Sub();</span><br><span class=\"line\"></span><br><span class=\"line\">// Sub只继承了Add的add方法并执行相关方法</span><br><span class=\"line\"></span><br><span class=\"line\">call方法：</span><br><span class=\"line\">newAdd.add.call(newSub, 10, 4);      // 14</span><br><span class=\"line\"></span><br><span class=\"line\">apply方法：</span><br><span class=\"line\">newAdd.add.apply(newSub, [10, 4]);   // 14</span><br><span class=\"line\"></span><br><span class=\"line\">bind方法：</span><br><span class=\"line\">newAdd.add.bind(newSub, 10, 4)();   // 14</span><br></pre></td></tr></table></figure>\n<blockquote></blockquote>\n<blockquote>\n<blockquote>\n<p><strong>注意</strong></p>\n<blockquote>\n<p>若想要全部继承父级所有相关属性 得采用==原型链继承==的方式</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function person()&#123;</span><br><span class=\"line\">    this.hair = &apos;black&apos;;</span><br><span class=\"line\">    this.eye = &apos;black&apos;;</span><br><span class=\"line\">    this.skin = &apos;yellow&apos;;</span><br><span class=\"line\">    this.view = function()&#123;</span><br><span class=\"line\">        return this.hair + &apos;,&apos; + this.eye + &apos;,&apos; + this.skin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function man()&#123;</span><br><span class=\"line\">    this.feature = [&apos;beard&apos;,&apos;strong&apos;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">man.prototype = new person();</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"13-cookie-sessionstorage-localstorage\">13. cookie sessionStorage localStorage</span></h2>\n<pre><code>1. cookie\n    * 4k的限制；\n    * 服务端和客户端传递时都会带上cookie；\n    * 本质上是对字符串的读取 存储内容过多消耗内存空间 导致页面变卡顿；\n    * 不能被爬虫读取；\n    * 设置时间之前一直有效，到时间就清除；\n2. sessionStorage\n    * 临时存储：引入“浏览器窗口”的概念，同源同窗口数据不会销毁，不同标签页中数据不能共享，关闭浏览器时候销毁；\n    * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n    * 性能更好，即本地读取数据比服务器获取快多了；\n    * 不能跨tab标签页传值；\n3. localStorage\n    * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n    * 体积更大 5M；\n    * 持久存储在本地，直到手动清除；\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(&apos;sss&apos;,1111);</span><br><span class=\"line\">localStorage.getItem(&apos;sss&apos;);</span><br><span class=\"line\">localStorage.removeItem(&apos;sss&apos;);</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"14-闭包\">14. 闭包</span></h2>\n<pre><code>简单回答闭包就是 一个函数返回自身内部函数的调用\n\n为什么使用？\n\n因为js是链式的 一层一层向上级查找 所以外部函数无法访问内部函数;\n</code></pre>\n<blockquote>\n<blockquote>\n<p>优点</p>\n</blockquote>\n<ul>\n<li>可以读取函数内部的变量，外部无法访问到里面变量;</li>\n<li>函数在执行完毕不会被销毁 而是一直存在内存中;</li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>缺点</p>\n</blockquote>\n<ul>\n<li>不会被内存回收 容易出现性能问题</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function bar()&#123;</span><br><span class=\"line\">        console.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newFoo = foo();</span><br><span class=\"line\">newFoo();               // a</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"15-深拷贝和浅拷贝\">15. 深拷贝和浅拷贝</span></h2>\n<ul>\n<li><strong>浅拷贝</strong>\n<blockquote>\n<p><strong>复制对象的副本 指向同一内存区域 对副本的操作会影响父级对象</strong></p>\n</blockquote>\n</li>\n</ul>\n<p>浅拷贝方式：</p>\n<ol>\n<li>直接赋值；</li>\n<li>Object.assign();</li>\n<li>JSON 序列化；</li>\n</ol>\n<ul>\n<li><strong>深拷贝</strong>\n<blockquote>\n<p><strong>复制对象的副本 指向不同的内存区域 与父级对象独立</strong></p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 浅拷贝</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name : &apos;zhangsan&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a;</span><br><span class=\"line\">b.name = &apos;lisi&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.name);    // &quot;lisi&quot;</span><br><span class=\"line\">console.log(b.name);    // &quot;lisi&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 深拷贝  (更完整的深拷贝还需要再详细优化)</span><br><span class=\"line\">function deepCopy(p, c)&#123;</span><br><span class=\"line\">    var c = c || &#123;&#125;;</span><br><span class=\"line\">    for(var i in p )&#123;</span><br><span class=\"line\">        // 数组和对象的时候再处理</span><br><span class=\"line\">        if(typeof p[i] === &apos;object&apos;)&#123;</span><br><span class=\"line\">            c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class=\"line\">            deepCopy(p[i], c[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            // 基本类型直接赋值</span><br><span class=\"line\">            c[i] = p[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var parent = &#123;</span><br><span class=\"line\">    number: [1, 2, 3],</span><br><span class=\"line\">    obj: &#123;</span><br><span class=\"line\">        prop: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var copyParent = deepCopy(parent);</span><br><span class=\"line\">copyParent.number.push(4)</span><br><span class=\"line\">copyParent.number                   // 1,2,3,4</span><br><span class=\"line\">parent.number                       // 1,2,3</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"16-传值类型和引用类型\">16. 传值类型和引用类型</span></h2>\n<ul>\n<li><strong>传值类型（基本类型）</strong>\n<blockquote>\n<p>值为基本类型时候为深拷贝</p>\n<blockquote>\n<p>基本类型就是 null，undefined，Boolean，string，number</p>\n<blockquote>\n<p>==独立不干扰==</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li><strong>引用类型</strong>\n<blockquote>\n<p>值为对象类型时候为浅拷贝</p>\n<blockquote>\n<p>值都是对对象的引用，即一个指向对象的指针</p>\n<blockquote>\n<p>==对副本的操作会影响父级对象==</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 传值类型</span><br><span class=\"line\">var  a = 1;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data = 2;</span><br><span class=\"line\">    console.log(data);   // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);    // 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 引用类型</span><br><span class=\"line\">var  a = &#123;</span><br><span class=\"line\">    name : &quot;张三&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data.name = &quot;李四&quot;;</span><br><span class=\"line\">    console.log(data);   //  Object &#123;name: &quot;李四&quot;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);         //  Object &#123;name: &quot;李四&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 引用类型不会被基本类型覆盖</span><br><span class=\"line\">var  a = &#123;</span><br><span class=\"line\">    name : &quot;张三&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data = 3；</span><br><span class=\"line\">    console.log(data);   // 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);         //  Object &#123;name: &quot;张三&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 为了解决引用类型的问题  引入深拷贝的概念  参考上面一个概念</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"17-函数作用域提升与预编译\">17. 函数作用域提升与预编译</span></h2>\n<blockquote>\n<p>由于 js 没有其他强类型语言{}这类的块级作用域 只有函数作用域 函数的声明很随意导致各种问题出现</p>\n<blockquote>\n<p>变量预编译 &gt; 函数预编译</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一条</span><br><span class=\"line\"></span><br><span class=\"line\">a();</span><br><span class=\"line\">var a = c = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();</span><br><span class=\"line\"></span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();</span><br><span class=\"line\">(function(b) &#123;</span><br><span class=\"line\">    b(), c()</span><br><span class=\"line\">    var b = c = function a() &#123;</span><br><span class=\"line\">        console.log(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b();</span><br><span class=\"line\">&#125;)(a);</span><br><span class=\"line\">c();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等价于：</span><br><span class=\"line\">var a;                      // 变量声明提升</span><br><span class=\"line\">function a() &#123;              // 函数声明提升</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();                        // 1</span><br><span class=\"line\">a = c = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a();                        // 2</span><br><span class=\"line\"></span><br><span class=\"line\">(function(b) &#123;</span><br><span class=\"line\">    var b</span><br><span class=\"line\">    b()                     // 2</span><br><span class=\"line\">    c()                     // 本来以error</span><br><span class=\"line\">    // 后来有人指正 原因就在于var b=c=xxx。</span><br><span class=\"line\">    // c相当于没有加var 不会预编译，这里c直接查找到外部作用域的c</span><br><span class=\"line\">    b = c = function a() &#123;</span><br><span class=\"line\">        console.log(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b();                    // 3</span><br><span class=\"line\">&#125;)(a);</span><br><span class=\"line\"></span><br><span class=\"line\">c();                        // 3</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 第二条</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">    function a()&#123;console.log(1)&#125;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">    function a()&#123;console.log(2)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()();                     //2 由于预编译 后面的a覆盖了前面的a</span><br><span class=\"line\"></span><br><span class=\"line\">// 第三条</span><br><span class=\"line\">var a=10;</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">    // 预编译a 赋值undefined，内部作用域存在a这个变量，</span><br><span class=\"line\">    // 所以这里 !a 就是  !undefined，就是true，进入函数a=20;</span><br><span class=\"line\">    if (!a) &#123;</span><br><span class=\"line\">        var a=20</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(a)          //  这里是20 ，</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()</span><br><span class=\"line\"></span><br><span class=\"line\">// 第四条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    var a=&apos;littlebear&apos;;</span><br><span class=\"line\">    console.log(a)          //littlebear</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //string  第二个&lt;script&gt;标签里的a但会往上查找。</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    console.log(a)//1</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第五条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">    // 报错，遇到&lt;script&gt;标签对时，会先对这一块进行预解析，</span><br><span class=\"line\">    // 下面没预解析，所以找不到声明过的a，于是报错了</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    console.log(a)          //1</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第六条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    function fn(a,b)&#123;</span><br><span class=\"line\">        console.log(a)      //容易上当 初始化a的时候已经赋值&apos;容易上当&apos;</span><br><span class=\"line\">        var a=10;</span><br><span class=\"line\">        console.log(a)      //10</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn(&apos;容易上当&apos;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"18-amd-和-cmd-区别\">18. AMD 和 CMD 区别</span></h2>\n<ol>\n<li>\n<p>AMD 推崇依赖前置。 （requireJS）</p>\n<p>CMD 推崇依赖就近， （seaJS）</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">    var a = require(&apos;./a&apos;)</span><br><span class=\"line\">    a.doSomething()         // 此处略去 100 行</span><br><span class=\"line\">    var b = require(&apos;./b&apos;)  // 依赖可以就近书写</span><br><span class=\"line\">    b.doSomething()         // ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123;</span><br><span class=\"line\">    // 依赖必须一开始就写好</span><br><span class=\"line\">    a.doSomething()    // 此处略去 100 行</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>对于依赖的模块，</p>\n<p>AMD 是提前执行（预执行），</p>\n<p>CMD 是延迟执行（懒执行）。</p>\n</li>\n</ol>\n<blockquote>\n<p>不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>AMD 的 API 默认是一个当多个用，</p>\n<p>CMD 的 API 严格区分，推崇职责单一</p>\n</li>\n</ol>\n<blockquote>\n<p>比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</p>\n</blockquote>\n<hr>\n<h2><span id=\"19-常见服务器的状态码\">19. 常见服务器的状态码</span></h2>\n<ul>\n<li>\n<p>304</p>\n<p>Not Modified</p>\n<p>客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</p>\n</li>\n<li>\n<p>400</p>\n<p>Bad Request</p>\n<p>表示该请求报文中存在语法错误，导致服务器无法理解该请求。</p>\n</li>\n<li>\n<p>403</p>\n<p>Forbidden</p>\n<p>该状态码表明对请求资源的访问被服务器拒绝了。</p>\n</li>\n<li>\n<p>500</p>\n<p>Internal Server Error</p>\n<p>该状态码表明服务器端在执行请求时发生了错误。</p>\n</li>\n<li>\n<p>502</p>\n<p>上游网关错误</p>\n</li>\n<li>\n<p>301</p>\n<p>永久重定向</p>\n</li>\n<li>\n<p>302</p>\n<p>临时重定向 会出现 URL 劫持 体现在搜索引擎收录策略上 会改变原有请求方法</p>\n</li>\n<li>\n<p>307</p>\n<p>临时重定向 与 302 区别 客户端应<code>保持请求方法</code>不变向新的地址发出请求</p>\n</li>\n</ul>\n<hr>\n<h2><span id=\"20-事件冒泡和事件捕获\">20. 事件冒泡和事件捕获</span></h2>\n<pre><code>* 事件冒泡兼容写法\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (event.cancelBubble) &#123;</span><br><span class=\"line\">    event.cancelBubble = true</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    event.stopPropagation()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n--------------------------\n</code></pre>\n<h2><span id=\"21-数组\">21. 数组</span></h2>\n<pre><code>1. push\n\n    向数组末尾添加指定元素\n\n2. pop\n\n    移除数组末尾的一个元素 并返回移除的元素\n\n3. shift\n\n    移除数组第一项 并返回该元素\n\n4. unshift\n\n    给数组第一项加上一个元素 返回数组长度\n\n5. join\n\n    数组按照指定的字符换转成字符串\n\n6. sort\n\n    数组按照ASCII排序  所以要完全按照从小到大的顺序排序的话需要指定参数 1 -1 0\n\n7. splice\n\n    从0开始\n\n&gt; 删除 ---------------------（**起始位置，截取个数**）\n\n&gt; 插入 ---------------------（**起始位置，截取个数为0，要插入的项**）\n\n&gt; 替换----------------------（**起始位置，截取个数为1，要插入的项**）\n\n8. slice\n\n9. concat\n\n10. reverse\n\n11. 遍历数组的方法\n\n    &gt; forEach\n    &gt; for in\n\n    两者区别 在于 for in 会遍历数组原型链的属性值\n\n    为了避免这样的情况 使用 hasOwnProperty 解决\n</code></pre>\n<hr>\n<h2><span id=\"22正则\">22.正则</span></h2>\n<ul>\n<li>()：小括号，叫做分组符。</li>\n<li>\\s : 空格</li>\n<li>\\S : 非空格</li>\n<li>\\d : 数字</li>\n<li>\\D : 非数字</li>\n<li>\\w : 字符 ( 字母 ，数字，下划线_ )</li>\n<li>\\W : 非字符</li>\n<li>.（点）——任意字符</li>\n<li>. : 真正的点</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>\\B : 非独立的部分</li>\n<li>{n,m}：至少出现 n 次，最多 m 次</li>\n<li>{n,} :至少 n 次</li>\n<li>\n<ul>\n<li>:任意次 相当于{0,}</li>\n</ul>\n</li>\n<li>？ ：零次或一次 相当于{0,1}</li>\n<li>\n<ul>\n<li>：一次或任意次相当于 {1,}</li>\n</ul>\n</li>\n<li>{n}： 正好 n 次</li>\n<li>[] ： 表示某个集合中的任意一个 不能为空</li>\n</ul>\n<hr>\n<blockquote>\n<h3><span id=\"字符串相关的正则方法\">字符串相关的正则方法</span></h3>\n</blockquote>\n<ul>\n<li>\n<h3><span id=\"match\">match()</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>返回一个包含匹配内容的数组</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;abcdef&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var re = /B/i;</span><br><span class=\"line\"></span><br><span class=\"line\">str.match(re) // [b]</span><br></pre></td></tr></table></figure>\n<p>例子 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url = https://dimg.fws.qa.nt.ctripcorp.com/images/2d090m000000062hy59E5.jpg&quot;</span><br><span class=\"line\">url.match(/[^\\/]*$/) // 2d090m000000062hy59E5.jpg</span><br><span class=\"line\">url.match(/^[^\\/]*/) // https</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<h3><span id=\"search\">search()</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>返回匹配到的第一个内容所在的位置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;abcdef&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var re = /B/i;</span><br><span class=\"line\"></span><br><span class=\"line\">str.search(re) // 1</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<h3><span id=\"replace\">replace()</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>查找符合正则的字符串并替换成==一个==对应的字符串。返回替换后的内容。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;</span><br><span class=\"line\">var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配</span><br><span class=\"line\">var str2 = str.replace(re,&apos;*&apos;); // 我爱**，*上太阳升。</span><br></pre></td></tr></table></figure>\n<p>并不能解决一个文字*的对应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;</span><br><span class=\"line\">var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配</span><br><span class=\"line\">var str2 = str.replace(re,function(str)&#123;</span><br><span class=\"line\">            alert(str);</span><br><span class=\"line\">            //用来测试：参数代表每次搜索到的符合正则的字符，</span><br><span class=\"line\">            //所以第一次str指的是北京 第二次str是天安门 第三次str是天安门</span><br><span class=\"line\">            var result = &apos;&apos;;</span><br><span class=\"line\">            for(var i=0;i&lt;str.length;i++)&#123;</span><br><span class=\"line\">                result += &apos;*&apos;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return result; //所以搜索到了几个字就返回几个*</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">alert(str2)</span><br></pre></td></tr></table></figure>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\">        // replace()中如果有子项，</span><br><span class=\"line\">        // 第一个参数 ：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">        // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">        // 第三个参数 : $2(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">alert( str );   //2013.6.7</span><br><span class=\"line\">//整个过程就是利用子项把2013- 6- 分别替换成了2013. 6.  最终弹出2013.6.7</span><br></pre></td></tr></table></figure>\n</code></pre>\n<hr>\n<h3><span id=\"正则两个方法\">正则两个方法</span></h3>\n<ul>\n<li>\n<h3><span id=\"test\">test()</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>匹配到指定内容返回 true</p>\n</blockquote>\n<ul>\n<li>\n<h3><span id=\"exec\">==exec()==</span></h3>\n</li>\n</ul>\n<blockquote>\n<p>返回第一匹配项信息的数组 若没有返回 null<br>\n有两个属性 index input</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var text = &apos;mom and dad and baby&apos;</span><br><span class=\"line\">var pattern = /mom( and dad( and baby)?)?/gi</span><br><span class=\"line\">var matches = pattern.exec(text)</span><br><span class=\"line\">mathes.index // 0</span><br><span class=\"line\">mathes.input // mom and dad and baby</span><br><span class=\"line\">mathes[0] // mom and dad and baby</span><br><span class=\"line\">mathes[1] //  and dad and baby</span><br><span class=\"line\">mathes[2] // and baby</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"23-后退监听\">23. 后退监听</span></h2>\n<blockquote>\n<p>history.back() history.forward() history.replace()触发 onpopstate 事件</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onpopstate = function () &#123;</span><br><span class=\"line\">    alert(&apos;2222&apos;)</span><br><span class=\"line\">    history.pushState(null, null, document.URL)</span><br><span class=\"line\">    return false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">history.pushState(null, null, document.URL)</span><br></pre></td></tr></table></figure>\n\nonbeforeunload事件有坑 chrome51版本及以后不能自定义文字 并且 页面载入之后一定要有浏览器行为才能触发\n</code></pre>\n<h2><span id=\"24-base64-图片及相关验证码\">24. base64 图片及相关验证码</span></h2>\n<blockquote>\n<p>data:image/gif;base64, (base64 地址)</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (result == null || result.length == 0) return</span><br><span class=\"line\">result = $.parseJSON(result)</span><br><span class=\"line\">var id = result[&apos;id&apos;]</span><br><span class=\"line\">var imgUrl = result[&apos;base64Buffer&apos;]</span><br><span class=\"line\">$(&apos;#js-code&apos;).attr(&apos;src&apos;, &apos;data:image/gif;base64,&apos; + imgUrl)</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"26-from-包裹的元素-document-事件失效-必须给-from-加事件\">26. from 包裹的元素 document 事件失效 必须给 from 加事件</span></h2>\n<h2><span id=\"27-进制转换\">27. 进制转换</span></h2>\n<blockquote>\n<p>十进制转十六进制</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = 255</span><br><span class=\"line\">s.toString(16) // ff</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n<p>十六进制转十进制</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;0xFF&apos;)   // 255</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"28-label-绑定事件一定要让事件委托到触发里面的-input\">28. label 绑定事件一定要让事件委托到触发里面的 input</span></h2>\n<pre><code>所以事件委托的时候直接监听input\n</code></pre>\n<h2><span id=\"29-跨域-post-请求转为-options-类型\">29. 跨域 post 请求转为 options 类型</span></h2>\n<h2><span id=\"30-math\">30. Math</span></h2>\n<pre><code>1. Math.floor 向下舍入；\n2. Math.ceil  向上舍入;\n3. Math.cos   余弦;\n4. Math.round 四舍五入;\n5. Math.sin   正弦；\n6. Math.tan   正切；\n</code></pre>\n<h2><span id=\"31-isnan\">31. isNaN</span></h2>\n<pre><code>首先需要知道 '' == 0   'abc' != 0   [] == 0  [1] != 0   null == 0  {} != 0  undefined != 0\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNaN(&apos;&apos;)   // false</span><br><span class=\"line\">isNaN(&apos; &apos;)  // false</span><br><span class=\"line\">isNaN(&apos;abc&apos;) // true</span><br><span class=\"line\">isNaN(undefined) // true</span><br><span class=\"line\">isNaN([])   // false</span><br><span class=\"line\">isNaN(&#123;&#125;)   // true</span><br><span class=\"line\">isNaN(null) // false</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"32-boolen\">32. Boolen</span></h2>\n<pre><code>首先需要知道  0 == false    1 == true  '' == false   undefined != false != true    null != false != true\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean(&apos;&apos;) // false</span><br><span class=\"line\">Boolean(&apos;ssss&apos;) // true</span><br><span class=\"line\">Boolean([])  // true</span><br><span class=\"line\">Boolean([1,2])  // true</span><br><span class=\"line\">Boolen(&#123;&#125;)      // true</span><br><span class=\"line\">Boolen(null)    // false</span><br><span class=\"line\">Boolen(undefined)   // false</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"33-解决回调地狱-多级回调\">33. 解决回调地狱 （多级回调）</span></h2>\n<pre><code>1. Promise\n\n2. aSync/await\n\n3. generator\n</code></pre>\n<h2><span id=\"34-字符串\">34. 字符串</span></h2>\n<pre><code>1. slice\n\n    在 不修改目标数组 的情况下返回截取的指定元素（ **起始位置，截止位置**）\n\n    从0开始 ==不包含最后一个数值==\n\n    负数情况下 将负数加上自身长度得到的数值作为参数\n\n2. substr\n\n    subdtr接收的是 起始位置 和 所要返回的字符串长度\n\n    在负数情况下  将第一个参数与字符串长度相加后的数值作为第一个参数\n\n3. substring\n\n    默认会将较小的参数作为第一个参数\n\n    在 不修改目标数组 的情况下返回截取的指定元素 （ **起始位置，截止位置**）\n\n    负数当做0处理\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let test = &apos;abcdef&apos;</span><br><span class=\"line\">test.slice(0, -1)   // abcde</span><br><span class=\"line\">test.slice(2, -3)   =&gt; test.slice(2,3)  // c</span><br><span class=\"line\"></span><br><span class=\"line\">test.substring(1, -2) =&gt; a</span><br><span class=\"line\">test.substring(2, -3) =&gt; ab</span><br></pre></td></tr></table></figure>\n<pre><code>4. split\n\n    字符串按照指定规则转换成数组\n</code></pre>\n<h2><span id=\"35-let-与-var-区别\">35. let 与 var 区别</span></h2>\n<pre><code>1. var存在变量提升， let不存在；\n2. let不允许重复声明；\n3. var挂载在window下，let挂载在块作用域下；\n</code></pre>\n<h2><span id=\"36-为什么-var-可以重复声明\">36. 为什么 var 可以重复声明</span></h2>\n<pre><code>因为js运行过程中，\n\n引擎 负责整个代码编译和运行\n\n编译器 负责词法分析、语法分析、代码生成等工作\n\n编译器从左至右编译var a，如果a不存在则在作用域声明一个新的变量a，若存在a则忽略继续向下编译；\n\n引擎遇到a = 2，按照作用域链向上查找 若存在变量a直接赋值，不存在则在作用域重新声明新的变量并赋值2\n</code></pre>\n<h2><span id=\"37-commonjs-中的-requireexports-和-es6-的-importexport-有什么区别\">37. CommonJS 中的 require/exports 和 ES6 的 import/export 有什么区别</span></h2>\n<ol>\n<li></li>\n</ol>\n<blockquote>\n<p>CommomJS 模块 require 代码时候会立刻执行；</p>\n</blockquote>\n<blockquote>\n<p>ES6 模块是动态引用，不会立刻执行，仅仅作为一个加载模块的对象引用；</p>\n</blockquote>\n<ol start=\"2\">\n<li></li>\n</ol>\n<blockquote>\n<p>CommonJs 模块输出的是一个值的拷贝， 输出后的对象会被缓存（即 如果发现一个模块被多次引用，会直接返回已经执行的部分）；</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// lib.js</span><br><span class=\"line\">var counter = 3;</span><br><span class=\"line\">function incCounter() &#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main.js</span><br><span class=\"line\">var mod = require(&apos;./lib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(mod.counter);  // 3</span><br><span class=\"line\">mod.incCounter();</span><br><span class=\"line\">console.log(mod.counter); // 3</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ES6 模块输出的是值的只读引用；</p>\n</blockquote>\n<ul>\n<li>接口输出的变量是只读的，重新赋值会报错；</li>\n<li>export 通过接口输出的是同一个值，得到的都是同样的实例；</li>\n<li>如果需要 import 支持动态加载 提案建议引入 import() 返回一个 promise 对象；</li>\n</ul>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/module-loader\" target=\"_blank\" rel=\"noopener\">ES6 模块与 CommonJS 模块的差异 </a></li>\n</ol>\n<h2><span id=\"38-浏览器缓存\">38. 浏览器缓存</span></h2>\n<pre><code>浏览器缓存分为 强缓存 和 协商缓存\n\n1. 客户端先根据资源的http header判断是否命中强缓存，如果命中直接从缓存中读取；\n\n2. 强缓存未命中，客户端发出请求，服务端根据请求的request header验证资源是否命中协商缓存，这个过程成为http再验证。如果命中，服务器将请求返回，状态码304，但不返回资源，而是告诉客服端可以从缓存读取；\n\n3. 当协商缓存也没有命中，直接服务端返回资源给客户端；\n\n\n强缓存\n\n1. Expires 代表缓存过期时间；\n\n2. Cache-Control： max-age  代表缓存最大生命周期；\n\n协商缓存\n\n1. Last-Modified 代表资源最后更新时间；\n\n2. If-Modified-Since 代表 判断两次请求之间是否有过修改 没有直接返回协商缓存；\n</code></pre>\n<h2><span id=\"39-处理-js-双精度问题\">39. 处理 js 双精度问题</span></h2>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> = <span class=\"number\">0.30000000000000004</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>由于计算机是做二进制运算</p>\n<p>0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）</p>\n<p>0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）</p>\n<p>双精度浮点数的小数部分最多支持 52 位</p>\n<p>处理方法：</p>\n<pre><code>1. toFixed  不够严谨；\n2. 把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(<span class=\"number\">0.1</span> * <span class=\"number\">10</span> + <span class=\"number\">0.2</span> * <span class=\"number\">10</span>) / <span class=\"number\">10</span> == <span class=\"number\">0.3</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<ol>\n<li>\n<p><a href=\"https://github.com/Megan-TA/UtilsJS\" target=\"_blank\" rel=\"noopener\">个人封装的处理双精度方法 第 7 点</a></p>\n</li>\n<li>\n<p><a href=\"https://www.cnblogs.com/xinggood/p/6639022.html\" target=\"_blank\" rel=\"noopener\">关于 js 浮点数计算精度不准确问题的解决办法</a></p>\n</li>\n</ol>\n<h2><span id=\"40-postmessage\">40. postMessage</span></h2>\n<ol>\n<li>window.postMessage() 可以安全进行跨域、跨页面通信；</li>\n<li>页面加载完成后才能进行跨域通信；</li>\n</ol>\n<p>发起端可以是 open 一个新窗口 或者 创建一个 iframe 往新窗口里发送数据</p>\n<p>案例:</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 客户端两种方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 当前页面地址 http:<span class=\"comment\">//www.webhek.com --&gt;</span></span><br><span class=\"line\">&lt;!-- open方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//弹出一个新窗口</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> domain = <span class=\"string\">'http://fanyi.youdao.com'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myPopup = <span class=\"built_in\">window</span>.open(domain, <span class=\"string\">'myWindow'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//周期性的发送消息</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'Hello! The time is: '</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'blog.local: sending message: '</span> + message);</span><br><span class=\"line\"><span class=\"comment\">//send the message and target URI</span></span><br><span class=\"line\">myPopup.postMessage(message,domain);</span><br><span class=\"line\">&#125;,<span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- iframe方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//捕获 iframe</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> domain = <span class=\"string\">\"http://fanyi.youdao.com\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myIFrame'</span>).contentWindow;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'Hello! The time is: '</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'blog.local: sending message: '</span> + message);</span><br><span class=\"line\"><span class=\"comment\">//send the message and target URI</span></span><br><span class=\"line\">iframe.postMessage(message,domain);</span><br><span class=\"line\">&#125;,<span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 接收端 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//监听消息反馈</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(event.origin !== <span class=\"string\">'http://www.webhek.com'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'received response: '</span>,event.data);</span><br><span class=\"line\">&#125;,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n<p>截图如下：</p>\n</blockquote>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006ANKB8gy1fqhqrhftfmj30yu0objvr.jpg\" alt=\"web骇客网站  接收端截图\"><br>\n<img src=\"https://wx2.sinaimg.cn/mw690/006ANKB8gy1fqhqri8fjlj30zk0h4tbk.jpg\" alt=\"有道翻译网站 接收端截图\"></p>\n<blockquote>\n<p>参考资料</p>\n</blockquote>\n<ol>\n<li><a href=\"http://www.webhek.com/post/window-postmessage-api.html\" target=\"_blank\" rel=\"noopener\">用 HTML5 里的 window.postMessage 在两个网页间传递数据</a></li>\n</ol>\n<h2><span id=\"41-service-worker\">41. Service Worker</span></h2>\n<blockquote>\n<p>背景</p>\n</blockquote>\n<p>为了解决 web 业务不断增加带来更多消耗资源、耗时等复杂运算带来性能问题，w3c 初期提出 Web Worker 的 API，目的为了解放主线程。原理是 将复杂 耗时的操作独立出来交给 Web Worker，完成后通过 postMessage 方法告诉主线程。</p>\n<p>缺点：临时存在，不能永久；为此提出 Service Worker，在 Web Worker 基础上增加持久缓存能力。</p>\n<p>在 Service Worker 之前有 APPCache 这个持久缓存的 API，不过存在更新机主不完善，二次更新，大小限制，回滚等问题，具体参考下方链接 1。</p>\n<p>Service Worker 的特性如下：</p>\n<ul>\n<li>\n<p>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</p>\n</li>\n<li>\n<p>一旦被 install，就永远存在，除非被 uninstall</p>\n</li>\n<li>\n<p>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）</p>\n</li>\n<li>\n<p>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</p>\n</li>\n<li>\n<p>离线内容开发者可控</p>\n</li>\n<li>\n<p>能向客户端推送消息</p>\n</li>\n<li>\n<p>不能直接操作 DOM</p>\n</li>\n<li>\n<p>出于安全的考虑，必须在 HTTPS 环境下才能工作</p>\n</li>\n<li>\n<p>异步实现，内部大都是通过 Promise 实现</p>\n</li>\n<li>\n<p>只能运行在 HTTPS 协议下</p>\n</li>\n</ul>\n<blockquote>\n<p>参考资料</p>\n</blockquote>\n<ol>\n<li><a href=\"https://www.zhihu.com/question/29876535\" target=\"_blank\" rel=\"noopener\">为什么 app cache 没有得到大规模应用？它有哪些硬伤吗？</a></li>\n<li><a href=\"https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction\" target=\"_blank\" rel=\"noopener\">Service Worker 简介</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28161855\" target=\"_blank\" rel=\"noopener\">如何优雅的为 PWA 注册 Service Worker</a></li>\n</ol>\n<h2><span id=\"42-加载更多下拉刷新\">42 加载更多/下拉刷新</span></h2>\n<p>原理：</p>\n<p>scrollTop（滚动条滚动距离） + clientHeight（可见区域高度） == scrollHeight（元素实际高度）</p>\n<p>备注：</p>\n<p>offsetHeighgt = height + padding + border</p>\n<p>clientHeight = height + padding</p>\n<h2><span id=\"43-js-标签中async和defer的作用与区别\">43. js 标签中<code>async</code>和<code>defer</code>的作用与区别</span></h2>\n<p>作用：</p>\n<p>1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>\n<p>2.async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p>\n<p>3.defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p>\n<p>区别：</p>\n<p>defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。<br>\n在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>js 知识点总结</h1>\n<h2>1. 解码和编码</h2>\n<blockquote>\n<p>原因：因为链接里面会有中文或者特殊字符号无法跳转需要进行相关编码解码</p>\n</blockquote>\n<p><strong>编码</strong></p>\n<blockquote></blockquote>\n<pre><code>'encodeURI': 只对查询的参数做编码\n\n'encodeURIComponent': 对整个url做编码，包括? &amp; / #\n</code></pre>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">'www.baidu.com/test?name=\"zhangsan\"'</span></span><br><span class=\"line\"><span class=\"built_in\">encodeURI</span>(a) =&gt; <span class=\"string\">'www.baidu.com/test?name=%22zhangsan%22'</span></span><br><span class=\"line\"><span class=\"built_in\">encodeURIComponent</span>(a) =&gt; <span class=\"string\">'www.baidu.com%2Ftest%3Fname%3D%22zhangsan%22'</span></span><br></pre></td></tr></table></figure>\n<p><strong>解码</strong></p>\n<blockquote></blockquote>\n<pre><code>'decodeURI': 只对查询参数做解码\n'decodeURIComponent': 对整个URL做解码\n</code></pre>\n<hr>\n<h2>2. 序列化和反序列化</h2>\n<blockquote></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify()        // 序列化</span><br><span class=\"line\">JSON.parse()            // 反序列化</span><br></pre></td></tr></table></figure>\n<p>使用 ajax 需要设置请求头部信息</p>\n<p>header: {‘Content-Type’: ‘application/json; charset=utf-8;’}</p>\n<blockquote>\n<p>JSON.stringify() 可以简单的用来迅速判断两个对象是否相等，但不严谨（比如：序列化失败）</p>\n</blockquote>\n<hr>\n<h2>3. 日期</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Date().getTime()   // 单位  秒</span><br><span class=\"line\">// 获取当前时间   （存在兼容性）</span><br><span class=\"line\">new Date().toLocaleDateString() // 2017/7/24</span><br><span class=\"line\">new Date().toLocaleTimeString() // 下午5:07:33</span><br><span class=\"line\">new Date().toLocaleString()     // 2017/7/24 下午5:07:33</span><br><span class=\"line\">// 若要显示24进制 需要option选项</span><br><span class=\"line\">new Date().toLocaleTimeString(&quot;UTC&quot;,&#123; hour12: false &#125;)  // 17:20:16</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>4. 回流/重绘</h2>\n<ol>\n<li>\n<p>回流：几何属性发生变化 比如：内容、结构、位置或尺寸发生变化，需要重新计算样式和渲染树；</p>\n</li>\n<li>\n<p>重绘：元素发生的改变只影响了节点的一些样式（背景色、边框色、文字颜色等）</p>\n</li>\n</ol>\n<blockquote>\n<p>回流比重绘要消耗更多的资源</p>\n</blockquote>\n<hr>\n<h2>5. 锚点定位 scrollIntoView （无兼容问题）</h2>\n<p>可以用来做一些 tab 定位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&apos;xx&apos;).scrollIntoView()</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>6. typeof 和 instanceof</h2>\n<blockquote>\n<h3>typeof</h3>\n</blockquote>\n<p>会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,function；</p>\n<p>缺点：</p>\n<ul>\n<li>不适用于来判断数组，因为不管是数组还是对象，都会返回 object。</li>\n<li>判断不了 null null 也是对象</li>\n</ul>\n<blockquote></blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof [1]      // Object</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h3>instanceof</h3>\n</blockquote>\n<p>返回的是一个布尔值 只能用来判断对象和函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123;&#125;;</span><br><span class=\"line\">alert(  a instanceof Object )     // true</span><br><span class=\"line\">var a  = [];</span><br><span class=\"line\">alert(  a instanceof Array )    // true</span><br></pre></td></tr></table></figure>\n<p>最靠谱也是最方便的办法使用<code>Object.prototype.toString.call()</code>来判断</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">types</span>(<span class=\"params\">target</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>7. requestAnimationFrame （RAF） 动画 api 兼容 Ie 8/9</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i = 0</span><br><span class=\"line\"></span><br><span class=\"line\">window.requestAnimFrame = (function()&#123;</span><br><span class=\"line\">  return  window.requestAnimationFrame       ||</span><br><span class=\"line\">          window.webkitRequestAnimationFrame ||</span><br><span class=\"line\">          window.mozRequestAnimationFrame    ||</span><br><span class=\"line\">          function( callback )&#123;</span><br><span class=\"line\">            window.setTimeout(callback, 1000 / 60);</span><br><span class=\"line\">          &#125;;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\">requestAnimFrame(animloop)</span><br><span class=\"line\"></span><br><span class=\"line\">function animloop () &#123;</span><br><span class=\"line\">    document.getElementById(&apos;test&apos;).style.top = i ++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>优点</h3>\n<pre><code>1. 解决毫秒的不精确性；\n2. 避免过渡渲染；\n3. 浏览器可以优化并行的动画动作，将合并的动作放入一个渲染周期；\n4. 过程可控；\n</code></pre>\n<blockquote>\n<p>动画效率之争</p>\n</blockquote>\n<pre><code>css3动画高效的原因有以下三点：\n\n    1. 强制使用硬件加速（GPU）；\n    2. 使用与RAF类似的机制；\n    3. 优化DOM操作 避免内存消耗来减少卡顿；\n\n同时因为采用GPU， 导致浏览器一直出于高负荷运转，移动端电量损耗和一定卡顿，\n而且css不能完全被js控制\npc上兼容性\n</code></pre>\n<p>js 动画库 （比如 Velocity.js 和 GSAP）</p>\n<hr>\n<h2>8. 跨域</h2>\n<ol>\n<li>\n<h3>JSONP</h3>\n<blockquote>\n<p>通过 js 标签引入一个 js 文件 这个 js 文件载入成功之后会执行我们在 url 参数中指定的函数 并且会吧我们需要的 json 数据作为参数传入</p>\n<p>例如：url?item=1&amp;callback=filter</p>\n<p>== 原生 js 实现 jsonp 的话 定义好 callback 的函数名称,动态创建 js 标签 url 加上查询的参数写好 callback 的回调函数名称即可 ==</p>\n</blockquote>\n</li>\n<li>\n<h3>利用 iframe 并修改 document.domain 来跨子域</h3>\n<p>两个不同域的页面引入 iframe 标签 同时将两个页面的主域设置成相同的域名</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox669ialYSHxewnD1B4L5UibVqhMnFEfibLhA8vUQu2s9rltB2HZ6UTQ19iag/0?wx_fmt=png\" alt=\"页面1\"><br>\n<img src=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6Kv2iaHanjIzQHDNeia2FsoHSz8AJPkxh0IqickdbPg0CPeFPhoQMpuv5w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"页面2\"></p>\n</li>\n<li>\n<h3><a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> （可以配合 iframe）</h3>\n<p>同源窗口下 <a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 对所有页面都是共享的</p>\n<p>每个页面对 <a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 都有读写权限</p>\n<p><a href=\"http://window.name\" target=\"_blank\" rel=\"noopener\">window.name</a> 的值并不会因为新页面而重置</p>\n</li>\n<li>\n<p>widnow.postMessage （存在兼容性 IE7/8 不支持）</p>\n<p>！<a href=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6z8ibxywKPEusvEA2xS8ialrQ1Oxd0jw0V8C6f7Gicy6Obsyt5bicibxdx5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"noopener\">页面 1</a></p>\n<p>！<a href=\"http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib3G96tn5N9s0grjcDZD0Ox6B9Fpsa9KmNAMibvfSqE8Qv2icpLzzFE6NfvEp8YxWW6JOMTacIzaQzxw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" target=\"_blank\" rel=\"noopener\">页面 2</a></p>\n</li>\n<li>\n<p>Nginx 反向代理</p>\n</li>\n</ol>\n<h2>9. selection</h2>\n<blockquote>\n<p>获取鼠标划过文本的对象</p>\n</blockquote>\n<blockquote>\n<p><code>window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();</code></p>\n</blockquote>\n<hr>\n<h2>10. 正则表达式</h2>\n<blockquote>\n<p>常用规则</p>\n</blockquote>\n<ul>\n<li>\\n 回车</li>\n<li>\\t 制表符</li>\n<li>\\r 换行符</li>\n<li>\\s 空格</li>\n<li>\\u4e00-\\u9fa5 中文</li>\n<li>\\w 大小写字母_数字</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>{n, m} 至少出现 n 次 最多 m 次</li>\n<li>{n,} 至少 n 次</li>\n<li>\n<ul>\n<li>任意次</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>至少一次</li>\n</ul>\n</li>\n<li>{n} 至少 n 次</li>\n<li>() 分组符号</li>\n<li>[\\s\\S] 任意字符</li>\n<li>^ 放在正则的最开始位置，就代表起始的意思，注意 /[^a] / 和 /^[a]/是不一样的，前者是排除的意思，后者是代表首位。</li>\n<li>正则的最后位置 , 就代表结束的意思</li>\n</ul>\n<p>匹配中文: [\\u4e00-\\u9fa5]</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re1 = /\\d-+/g;        // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为：  3- 6-</span><br><span class=\"line\">var re1 = /(\\d-）+/g;     // 全局匹配数字，横杠，数字和横杠整体数量至少为1   3-6-</span><br><span class=\"line\">var re2  = /(\\d+)(-)/g;   // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------</span><br><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //replace()中如果有子项，</span><br><span class=\"line\">    //第一个参数：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">    // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">    //第三个参数 : $1(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[] 表示某个集合中的任意一个</li>\n<li>[^a] 排除 a</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// var re = /\\bclassname\\b/;</span><br><span class=\"line\"></span><br><span class=\"line\">// 不能这样写，当正则需要用到参数时候，一定要用全称的写法，简写方式会</span><br><span class=\"line\">// 把classname当做一个字符串去匹配。</span><br><span class=\"line\"></span><br><span class=\"line\">var re = new RegExp(&apos;\\\\b&apos;+classname+&apos;\\\\b&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 匹配的时候，classname前面必须是起始或者空格，后面也是。</span><br><span class=\"line\"></span><br><span class=\"line\">默认匹配成功就停止，所以就算有重复的也不会再匹配进去了。</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>11. Object</h2>\n<pre><code>1. constructor\n\n    实例的constructor 永远指向 构造函数 的 prototype.constructor\n\n    理解成 实例是基于构造函数原型链生成的对象\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function A(x)&#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newA = new A(name);</span><br><span class=\"line\"></span><br><span class=\"line\">此时：</span><br><span class=\"line\">newA.constructor == A.prototype.constructor;</span><br></pre></td></tr></table></figure>\n<pre><code>2. hasOwnProperty\n\n    判断对象上某个属性是否属于自身 属于自身为true, 原型链上为false\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a () &#123;</span><br><span class=\"line\">    this.show = &apos;x&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.prototype.hide = function () &#123;</span><br><span class=\"line\">    console.log(111111);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var z = new a();</span><br><span class=\"line\">z.hasOwnProperty(&apos;show&apos;);          // true</span><br><span class=\"line\">z.hasOwnProperty(&apos;hide&apos;);          // false</span><br></pre></td></tr></table></figure>\n<pre><code>3. isPrototypeOf\n\n    判断一个对象是否是另一个对象的原型\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var monkey = &#123;</span><br><span class=\"line\">    hair : true,</span><br><span class=\"line\">    breathes : function()&#123;</span><br><span class=\"line\">        alert(&apos;1&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Human(name)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Human的原型链绑定monkey对象</span><br><span class=\"line\">Human.prototype = monkey;</span><br><span class=\"line\"></span><br><span class=\"line\">var man = new Human(&apos;张三&apos;);</span><br><span class=\"line\">monkey.isPrototypeOf(man);      // true</span><br></pre></td></tr></table></figure>\n<pre><code>4. prototype和__proto__\n\n    prototype是一个函数的内置属性（每个函数都有一个prototype属性）\n\n    __proto__ 是一个实例对象的内置属性 实例化的对象在内部通过此属性寻找原型链\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Person = function () &#123;&#125;</span><br><span class=\"line\">var zhangsan = new Person ()</span><br><span class=\"line\"></span><br><span class=\"line\">zhansan.__prop__ = Person.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">new 的过程拆分成以下三步</span><br><span class=\"line\"></span><br><span class=\"line\">1. var p = &#123;&#125;</span><br><span class=\"line\">2. p.__proto__ = Person.prototype</span><br><span class=\"line\">3. Person.call(p)</span><br></pre></td></tr></table></figure>\n<pre><code>5. Object.getPrototypeOf\n\n    获取 实例化对象 原型链 的相关属性\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Test () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test.prototype.showName = function () &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj = new Test ()</span><br><span class=\"line\">Object.getPrototypeOf(obj) == obj.__proto__</span><br></pre></td></tr></table></figure>\n<pre><code>6. Object.keys\n\n    可以用来枚举可遍历的属性 返回一个数组\n\n7. Object.create\n\n    在原型链上创建对象属性\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 属性创建在原型链上 --&gt;</span><br><span class=\"line\">Object.create(&#123;</span><br><span class=\"line\">    name: &apos;张三&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 字面量方式创建的对象属性挂在自身 --&gt;</span><br><span class=\"line\">let test = &#123;</span><br><span class=\"line\">    name: &apos;张三&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>8. Object.isExtensible\n\n    判断对象是否可以新增属性\n\n9. Object.preventExtension\n\n    锁住对象 使其不能新增属性 但是原来的属性可以修改删除\n\n10. Object.seal\n\n    密封对象 不能增加新属性 也不能删除旧属性  但是能修改原来的属性\n\n11. Object.isSealed\n\n    判断对象是否密封\n\n12. Object.freeze\n\n    冻结对象 不能新增 不能修改 不能删除\n\n13. Object.isFrozen\n\n    判断对象是否完全被冻结\n\n14. Object.getOwnPropertyNames\n\n    获取自身属性名字 返回一个数组\n\n15. Object.getOwnPropertyDescriptor\n\n    判断某个对象上某个属性的状态描述\n\n16. Object.defineProperty\n\n\n\n\n-----------\n</code></pre>\n<h2>12. 继承</h2>\n<blockquote>\n<p><strong>调用另一个对象的方法，以另一个对象替换当前对象的上下文</strong></p>\n<blockquote>\n<p>缺点</p>\n<blockquote>\n<p>只能继承父级本身属性，原型链的属性无法继承</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li><strong>call</strong>\n<blockquote>\n<p>第二个参数可以省略</p>\n</blockquote>\n</li>\n<li><strong>apply</strong>\n<blockquote>\n<p>第二个参数必须是数组或者用 arguments 代替</p>\n</blockquote>\n</li>\n<li><strong>bind</strong>\n<blockquote>\n<p>bind 与 call 和 apply 的区别在于 bind 是一个函数 不会立即执行 必须在后面再加上一对括号去立即执行</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例子1：</span><br><span class=\"line\"></span><br><span class=\"line\">function Add(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.add = function(a,b)&#123;</span><br><span class=\"line\">        alert(a+b)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.xx = 333;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.sub = &apos;张三&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // call方法</span><br><span class=\"line\">    Add.call(this); // call继承Add所有方法(不包含原型链上的方法)</span><br><span class=\"line\"></span><br><span class=\"line\">    // apply方法  参数不能指定的时候用[]或者arguments代替</span><br><span class=\"line\">    Add.apply(this, [])</span><br><span class=\"line\">    // 又可以写成</span><br><span class=\"line\">    Add.apply(this, arguments)</span><br><span class=\"line\"></span><br><span class=\"line\">    // bind方法</span><br><span class=\"line\">    Add.bind(this)();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">x = new Sub();</span><br><span class=\"line\">x.add(5,7)                  // 11</span><br><span class=\"line\"></span><br><span class=\"line\">=====================================</span><br><span class=\"line\"></span><br><span class=\"line\">例子2：</span><br><span class=\"line\"></span><br><span class=\"line\">若只想继承父级构造函数某一个具体方法</span><br><span class=\"line\">需要先将父子对象都实例化后 调用父级的具体方法call</span><br><span class=\"line\"></span><br><span class=\"line\">function Add(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.add = function(a,b)&#123;</span><br><span class=\"line\">        alert(a+b)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    this.xx = 333;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Sub()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.sub = &apos;张三&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">newAdd = new Add(7,8);</span><br><span class=\"line\">newSub = new Sub();</span><br><span class=\"line\"></span><br><span class=\"line\">// Sub只继承了Add的add方法并执行相关方法</span><br><span class=\"line\"></span><br><span class=\"line\">call方法：</span><br><span class=\"line\">newAdd.add.call(newSub, 10, 4);      // 14</span><br><span class=\"line\"></span><br><span class=\"line\">apply方法：</span><br><span class=\"line\">newAdd.add.apply(newSub, [10, 4]);   // 14</span><br><span class=\"line\"></span><br><span class=\"line\">bind方法：</span><br><span class=\"line\">newAdd.add.bind(newSub, 10, 4)();   // 14</span><br></pre></td></tr></table></figure>\n<blockquote></blockquote>\n<blockquote>\n<blockquote>\n<p><strong>注意</strong></p>\n<blockquote>\n<p>若想要全部继承父级所有相关属性 得采用==原型链继承==的方式</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function person()&#123;</span><br><span class=\"line\">    this.hair = &apos;black&apos;;</span><br><span class=\"line\">    this.eye = &apos;black&apos;;</span><br><span class=\"line\">    this.skin = &apos;yellow&apos;;</span><br><span class=\"line\">    this.view = function()&#123;</span><br><span class=\"line\">        return this.hair + &apos;,&apos; + this.eye + &apos;,&apos; + this.skin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function man()&#123;</span><br><span class=\"line\">    this.feature = [&apos;beard&apos;,&apos;strong&apos;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">man.prototype = new person();</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>13. cookie sessionStorage localStorage</h2>\n<pre><code>1. cookie\n    * 4k的限制；\n    * 服务端和客户端传递时都会带上cookie；\n    * 本质上是对字符串的读取 存储内容过多消耗内存空间 导致页面变卡顿；\n    * 不能被爬虫读取；\n    * 设置时间之前一直有效，到时间就清除；\n2. sessionStorage\n    * 临时存储：引入“浏览器窗口”的概念，同源同窗口数据不会销毁，不同标签页中数据不能共享，关闭浏览器时候销毁；\n    * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n    * 性能更好，即本地读取数据比服务器获取快多了；\n    * 不能跨tab标签页传值；\n3. localStorage\n    * 减少网络流量，即减少数据在服务端和客户端之间的传递；\n    * 体积更大 5M；\n    * 持久存储在本地，直到手动清除；\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(&apos;sss&apos;,1111);</span><br><span class=\"line\">localStorage.getItem(&apos;sss&apos;);</span><br><span class=\"line\">localStorage.removeItem(&apos;sss&apos;);</span><br><span class=\"line\">localStorage.clear();</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>14. 闭包</h2>\n<pre><code>简单回答闭包就是 一个函数返回自身内部函数的调用\n\n为什么使用？\n\n因为js是链式的 一层一层向上级查找 所以外部函数无法访问内部函数;\n</code></pre>\n<blockquote>\n<blockquote>\n<p>优点</p>\n</blockquote>\n<ul>\n<li>可以读取函数内部的变量，外部无法访问到里面变量;</li>\n<li>函数在执行完毕不会被销毁 而是一直存在内存中;</li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>缺点</p>\n</blockquote>\n<ul>\n<li>不会被内存回收 容易出现性能问题</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">    var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function bar()&#123;</span><br><span class=\"line\">        console.log(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newFoo = foo();</span><br><span class=\"line\">newFoo();               // a</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>15. 深拷贝和浅拷贝</h2>\n<ul>\n<li><strong>浅拷贝</strong>\n<blockquote>\n<p><strong>复制对象的副本 指向同一内存区域 对副本的操作会影响父级对象</strong></p>\n</blockquote>\n</li>\n</ul>\n<p>浅拷贝方式：</p>\n<ol>\n<li>直接赋值；</li>\n<li>Object.assign();</li>\n<li>JSON 序列化；</li>\n</ol>\n<ul>\n<li><strong>深拷贝</strong>\n<blockquote>\n<p><strong>复制对象的副本 指向不同的内存区域 与父级对象独立</strong></p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 浅拷贝</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name : &apos;zhangsan&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a;</span><br><span class=\"line\">b.name = &apos;lisi&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a.name);    // &quot;lisi&quot;</span><br><span class=\"line\">console.log(b.name);    // &quot;lisi&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 深拷贝  (更完整的深拷贝还需要再详细优化)</span><br><span class=\"line\">function deepCopy(p, c)&#123;</span><br><span class=\"line\">    var c = c || &#123;&#125;;</span><br><span class=\"line\">    for(var i in p )&#123;</span><br><span class=\"line\">        // 数组和对象的时候再处理</span><br><span class=\"line\">        if(typeof p[i] === &apos;object&apos;)&#123;</span><br><span class=\"line\">            c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class=\"line\">            deepCopy(p[i], c[i]);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            // 基本类型直接赋值</span><br><span class=\"line\">            c[i] = p[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var parent = &#123;</span><br><span class=\"line\">    number: [1, 2, 3],</span><br><span class=\"line\">    obj: &#123;</span><br><span class=\"line\">        prop: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var copyParent = deepCopy(parent);</span><br><span class=\"line\">copyParent.number.push(4)</span><br><span class=\"line\">copyParent.number                   // 1,2,3,4</span><br><span class=\"line\">parent.number                       // 1,2,3</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>16. 传值类型和引用类型</h2>\n<ul>\n<li><strong>传值类型（基本类型）</strong>\n<blockquote>\n<p>值为基本类型时候为深拷贝</p>\n<blockquote>\n<p>基本类型就是 null，undefined，Boolean，string，number</p>\n<blockquote>\n<p>==独立不干扰==</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n<li><strong>引用类型</strong>\n<blockquote>\n<p>值为对象类型时候为浅拷贝</p>\n<blockquote>\n<p>值都是对对象的引用，即一个指向对象的指针</p>\n<blockquote>\n<p>==对副本的操作会影响父级对象==</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 传值类型</span><br><span class=\"line\">var  a = 1;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data = 2;</span><br><span class=\"line\">    console.log(data);   // 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);    // 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 引用类型</span><br><span class=\"line\">var  a = &#123;</span><br><span class=\"line\">    name : &quot;张三&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data.name = &quot;李四&quot;;</span><br><span class=\"line\">    console.log(data);   //  Object &#123;name: &quot;李四&quot;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);         //  Object &#123;name: &quot;李四&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 引用类型不会被基本类型覆盖</span><br><span class=\"line\">var  a = &#123;</span><br><span class=\"line\">    name : &quot;张三&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function voo(data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    data = 3；</span><br><span class=\"line\">    console.log(data);   // 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">voo(a);</span><br><span class=\"line\">console.log(a);         //  Object &#123;name: &quot;张三&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 为了解决引用类型的问题  引入深拷贝的概念  参考上面一个概念</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>17. 函数作用域提升与预编译</h2>\n<blockquote>\n<p>由于 js 没有其他强类型语言{}这类的块级作用域 只有函数作用域 函数的声明很随意导致各种问题出现</p>\n<blockquote>\n<p>变量预编译 &gt; 函数预编译</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一条</span><br><span class=\"line\"></span><br><span class=\"line\">a();</span><br><span class=\"line\">var a = c = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();</span><br><span class=\"line\"></span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();</span><br><span class=\"line\">(function(b) &#123;</span><br><span class=\"line\">    b(), c()</span><br><span class=\"line\">    var b = c = function a() &#123;</span><br><span class=\"line\">        console.log(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b();</span><br><span class=\"line\">&#125;)(a);</span><br><span class=\"line\">c();</span><br><span class=\"line\"></span><br><span class=\"line\">// 等价于：</span><br><span class=\"line\">var a;                      // 变量声明提升</span><br><span class=\"line\">function a() &#123;              // 函数声明提升</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a();                        // 1</span><br><span class=\"line\">a = c = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a();                        // 2</span><br><span class=\"line\"></span><br><span class=\"line\">(function(b) &#123;</span><br><span class=\"line\">    var b</span><br><span class=\"line\">    b()                     // 2</span><br><span class=\"line\">    c()                     // 本来以error</span><br><span class=\"line\">    // 后来有人指正 原因就在于var b=c=xxx。</span><br><span class=\"line\">    // c相当于没有加var 不会预编译，这里c直接查找到外部作用域的c</span><br><span class=\"line\">    b = c = function a() &#123;</span><br><span class=\"line\">        console.log(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b();                    // 3</span><br><span class=\"line\">&#125;)(a);</span><br><span class=\"line\"></span><br><span class=\"line\">c();                        // 3</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 第二条</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">    function a()&#123;console.log(1)&#125;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">    function a()&#123;console.log(2)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()();                     //2 由于预编译 后面的a覆盖了前面的a</span><br><span class=\"line\"></span><br><span class=\"line\">// 第三条</span><br><span class=\"line\">var a=10;</span><br><span class=\"line\">function fn()&#123;</span><br><span class=\"line\">    // 预编译a 赋值undefined，内部作用域存在a这个变量，</span><br><span class=\"line\">    // 所以这里 !a 就是  !undefined，就是true，进入函数a=20;</span><br><span class=\"line\">    if (!a) &#123;</span><br><span class=\"line\">        var a=20</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(a)          //  这里是20 ，</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn()</span><br><span class=\"line\"></span><br><span class=\"line\">// 第四条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    var a=&apos;littlebear&apos;;</span><br><span class=\"line\">    console.log(a)          //littlebear</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //string  第二个&lt;script&gt;标签里的a但会往上查找。</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    console.log(a)//1</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第五条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">    // 报错，遇到&lt;script&gt;标签对时，会先对这一块进行预解析，</span><br><span class=\"line\">    // 下面没预解析，所以找不到声明过的a，于是报错了</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    console.log(typeof a)   //undefined</span><br><span class=\"line\">    var a=1;</span><br><span class=\"line\">    console.log(a)          //1</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第六条</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    function fn(a,b)&#123;</span><br><span class=\"line\">        console.log(a)      //容易上当 初始化a的时候已经赋值&apos;容易上当&apos;</span><br><span class=\"line\">        var a=10;</span><br><span class=\"line\">        console.log(a)      //10</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fn(&apos;容易上当&apos;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h2>18. AMD 和 CMD 区别</h2>\n<ol>\n<li>\n<p>AMD 推崇依赖前置。 （requireJS）</p>\n<p>CMD 推崇依赖就近， （seaJS）</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// CMD</span><br><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">    var a = require(&apos;./a&apos;)</span><br><span class=\"line\">    a.doSomething()         // 此处略去 100 行</span><br><span class=\"line\">    var b = require(&apos;./b&apos;)  // 依赖可以就近书写</span><br><span class=\"line\">    b.doSomething()         // ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// AMD 默认推荐</span><br><span class=\"line\">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123;</span><br><span class=\"line\">    // 依赖必须一开始就写好</span><br><span class=\"line\">    a.doSomething()    // 此处略去 100 行</span><br><span class=\"line\">    b.doSomething()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>\n<p>对于依赖的模块，</p>\n<p>AMD 是提前执行（预执行），</p>\n<p>CMD 是延迟执行（懒执行）。</p>\n</li>\n</ol>\n<blockquote>\n<p>不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</p>\n</blockquote>\n<ol start=\"3\">\n<li>\n<p>AMD 的 API 默认是一个当多个用，</p>\n<p>CMD 的 API 严格区分，推崇职责单一</p>\n</li>\n</ol>\n<blockquote>\n<p>比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</p>\n</blockquote>\n<hr>\n<h2>19. 常见服务器的状态码</h2>\n<ul>\n<li>\n<p>304</p>\n<p>Not Modified</p>\n<p>客户端有缓冲的文档并发出了一个条件性的请求（一般是提供 If-Modified-Since 头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</p>\n</li>\n<li>\n<p>400</p>\n<p>Bad Request</p>\n<p>表示该请求报文中存在语法错误，导致服务器无法理解该请求。</p>\n</li>\n<li>\n<p>403</p>\n<p>Forbidden</p>\n<p>该状态码表明对请求资源的访问被服务器拒绝了。</p>\n</li>\n<li>\n<p>500</p>\n<p>Internal Server Error</p>\n<p>该状态码表明服务器端在执行请求时发生了错误。</p>\n</li>\n<li>\n<p>502</p>\n<p>上游网关错误</p>\n</li>\n<li>\n<p>301</p>\n<p>永久重定向</p>\n</li>\n<li>\n<p>302</p>\n<p>临时重定向 会出现 URL 劫持 体现在搜索引擎收录策略上 会改变原有请求方法</p>\n</li>\n<li>\n<p>307</p>\n<p>临时重定向 与 302 区别 客户端应<code>保持请求方法</code>不变向新的地址发出请求</p>\n</li>\n</ul>\n<hr>\n<h2>20. 事件冒泡和事件捕获</h2>\n<pre><code>* 事件冒泡兼容写法\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (event.cancelBubble) &#123;</span><br><span class=\"line\">    event.cancelBubble = true</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    event.stopPropagation()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n--------------------------\n</code></pre>\n<h2>21. 数组</h2>\n<pre><code>1. push\n\n    向数组末尾添加指定元素\n\n2. pop\n\n    移除数组末尾的一个元素 并返回移除的元素\n\n3. shift\n\n    移除数组第一项 并返回该元素\n\n4. unshift\n\n    给数组第一项加上一个元素 返回数组长度\n\n5. join\n\n    数组按照指定的字符换转成字符串\n\n6. sort\n\n    数组按照ASCII排序  所以要完全按照从小到大的顺序排序的话需要指定参数 1 -1 0\n\n7. splice\n\n    从0开始\n\n&gt; 删除 ---------------------（**起始位置，截取个数**）\n\n&gt; 插入 ---------------------（**起始位置，截取个数为0，要插入的项**）\n\n&gt; 替换----------------------（**起始位置，截取个数为1，要插入的项**）\n\n8. slice\n\n9. concat\n\n10. reverse\n\n11. 遍历数组的方法\n\n    &gt; forEach\n    &gt; for in\n\n    两者区别 在于 for in 会遍历数组原型链的属性值\n\n    为了避免这样的情况 使用 hasOwnProperty 解决\n</code></pre>\n<hr>\n<h2>22.正则</h2>\n<ul>\n<li>()：小括号，叫做分组符。</li>\n<li>\\s : 空格</li>\n<li>\\S : 非空格</li>\n<li>\\d : 数字</li>\n<li>\\D : 非数字</li>\n<li>\\w : 字符 ( 字母 ，数字，下划线_ )</li>\n<li>\\W : 非字符</li>\n<li>.（点）——任意字符</li>\n<li>. : 真正的点</li>\n<li>\\b : 独立的部分 （ 起始，结束，空格 ）</li>\n<li>\\B : 非独立的部分</li>\n<li>{n,m}：至少出现 n 次，最多 m 次</li>\n<li>{n,} :至少 n 次</li>\n<li>\n<ul>\n<li>:任意次 相当于{0,}</li>\n</ul>\n</li>\n<li>？ ：零次或一次 相当于{0,1}</li>\n<li>\n<ul>\n<li>：一次或任意次相当于 {1,}</li>\n</ul>\n</li>\n<li>{n}： 正好 n 次</li>\n<li>[] ： 表示某个集合中的任意一个 不能为空</li>\n</ul>\n<hr>\n<blockquote>\n<h3>字符串相关的正则方法</h3>\n</blockquote>\n<ul>\n<li>\n<h3>match()</h3>\n</li>\n</ul>\n<blockquote>\n<p>返回一个包含匹配内容的数组</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;abcdef&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var re = /B/i;</span><br><span class=\"line\"></span><br><span class=\"line\">str.match(re) // [b]</span><br></pre></td></tr></table></figure>\n<p>例子 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url = https://dimg.fws.qa.nt.ctripcorp.com/images/2d090m000000062hy59E5.jpg&quot;</span><br><span class=\"line\">url.match(/[^\\/]*$/) // 2d090m000000062hy59E5.jpg</span><br><span class=\"line\">url.match(/^[^\\/]*/) // https</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<h3>search()</h3>\n</li>\n</ul>\n<blockquote>\n<p>返回匹配到的第一个内容所在的位置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;abcdef&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var re = /B/i;</span><br><span class=\"line\"></span><br><span class=\"line\">str.search(re) // 1</span><br></pre></td></tr></table></figure>\n<ul>\n<li>\n<h3>replace()</h3>\n</li>\n</ul>\n<blockquote>\n<p>查找符合正则的字符串并替换成==一个==对应的字符串。返回替换后的内容。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;</span><br><span class=\"line\">var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配</span><br><span class=\"line\">var str2 = str.replace(re,&apos;*&apos;); // 我爱**，*上太阳升。</span><br></pre></td></tr></table></figure>\n<p>并不能解决一个文字*的对应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;</span><br><span class=\"line\">var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配</span><br><span class=\"line\">var str2 = str.replace(re,function(str)&#123;</span><br><span class=\"line\">            alert(str);</span><br><span class=\"line\">            //用来测试：参数代表每次搜索到的符合正则的字符，</span><br><span class=\"line\">            //所以第一次str指的是北京 第二次str是天安门 第三次str是天安门</span><br><span class=\"line\">            var result = &apos;&apos;;</span><br><span class=\"line\">            for(var i=0;i&lt;str.length;i++)&#123;</span><br><span class=\"line\">                result += &apos;*&apos;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return result; //所以搜索到了几个字就返回几个*</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">alert(str2)</span><br></pre></td></tr></table></figure>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &apos;2013-6-7&apos;;</span><br><span class=\"line\">var re = /(\\d+)(-)/g;</span><br><span class=\"line\"></span><br><span class=\"line\">str = str.replace(re,function($0,$1,$2)&#123;</span><br><span class=\"line\">        // replace()中如果有子项，</span><br><span class=\"line\">        // 第一个参数 ：$0（匹配成功后的整体结果  2013-  6-）,</span><br><span class=\"line\">        // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\\d   2013, 6)</span><br><span class=\"line\">        // 第三个参数 : $2(匹配成功的第二个分组，这里指的是-    - - )</span><br><span class=\"line\">    return $1 + &apos;.&apos;;  //分别返回2013.   6.</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">alert( str );   //2013.6.7</span><br><span class=\"line\">//整个过程就是利用子项把2013- 6- 分别替换成了2013. 6.  最终弹出2013.6.7</span><br></pre></td></tr></table></figure>\n</code></pre>\n<hr>\n<h3>正则两个方法</h3>\n<ul>\n<li>\n<h3>test()</h3>\n</li>\n</ul>\n<blockquote>\n<p>匹配到指定内容返回 true</p>\n</blockquote>\n<ul>\n<li>\n<h3>==exec()==</h3>\n</li>\n</ul>\n<blockquote>\n<p>返回第一匹配项信息的数组 若没有返回 null<br>\n有两个属性 index input</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var text = &apos;mom and dad and baby&apos;</span><br><span class=\"line\">var pattern = /mom( and dad( and baby)?)?/gi</span><br><span class=\"line\">var matches = pattern.exec(text)</span><br><span class=\"line\">mathes.index // 0</span><br><span class=\"line\">mathes.input // mom and dad and baby</span><br><span class=\"line\">mathes[0] // mom and dad and baby</span><br><span class=\"line\">mathes[1] //  and dad and baby</span><br><span class=\"line\">mathes[2] // and baby</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>23. 后退监听</h2>\n<blockquote>\n<p>history.back() history.forward() history.replace()触发 onpopstate 事件</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onpopstate = function () &#123;</span><br><span class=\"line\">    alert(&apos;2222&apos;)</span><br><span class=\"line\">    history.pushState(null, null, document.URL)</span><br><span class=\"line\">    return false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">history.pushState(null, null, document.URL)</span><br></pre></td></tr></table></figure>\n\nonbeforeunload事件有坑 chrome51版本及以后不能自定义文字 并且 页面载入之后一定要有浏览器行为才能触发\n</code></pre>\n<h2>24. base64 图片及相关验证码</h2>\n<blockquote>\n<p>data:image/gif;base64, (base64 地址)</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (result == null || result.length == 0) return</span><br><span class=\"line\">result = $.parseJSON(result)</span><br><span class=\"line\">var id = result[&apos;id&apos;]</span><br><span class=\"line\">var imgUrl = result[&apos;base64Buffer&apos;]</span><br><span class=\"line\">$(&apos;#js-code&apos;).attr(&apos;src&apos;, &apos;data:image/gif;base64,&apos; + imgUrl)</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>26. from 包裹的元素 document 事件失效 必须给 from 加事件</h2>\n<h2>27. 进制转换</h2>\n<blockquote>\n<p>十进制转十六进制</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = 255</span><br><span class=\"line\">s.toString(16) // ff</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n<p>十六进制转十进制</p>\n</blockquote>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;0xFF&apos;)   // 255</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>28. label 绑定事件一定要让事件委托到触发里面的 input</h2>\n<pre><code>所以事件委托的时候直接监听input\n</code></pre>\n<h2>29. 跨域 post 请求转为 options 类型</h2>\n<h2>30. Math</h2>\n<pre><code>1. Math.floor 向下舍入；\n2. Math.ceil  向上舍入;\n3. Math.cos   余弦;\n4. Math.round 四舍五入;\n5. Math.sin   正弦；\n6. Math.tan   正切；\n</code></pre>\n<h2>31. isNaN</h2>\n<pre><code>首先需要知道 '' == 0   'abc' != 0   [] == 0  [1] != 0   null == 0  {} != 0  undefined != 0\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNaN(&apos;&apos;)   // false</span><br><span class=\"line\">isNaN(&apos; &apos;)  // false</span><br><span class=\"line\">isNaN(&apos;abc&apos;) // true</span><br><span class=\"line\">isNaN(undefined) // true</span><br><span class=\"line\">isNaN([])   // false</span><br><span class=\"line\">isNaN(&#123;&#125;)   // true</span><br><span class=\"line\">isNaN(null) // false</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>32. Boolen</h2>\n<pre><code>首先需要知道  0 == false    1 == true  '' == false   undefined != false != true    null != false != true\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean(&apos;&apos;) // false</span><br><span class=\"line\">Boolean(&apos;ssss&apos;) // true</span><br><span class=\"line\">Boolean([])  // true</span><br><span class=\"line\">Boolean([1,2])  // true</span><br><span class=\"line\">Boolen(&#123;&#125;)      // true</span><br><span class=\"line\">Boolen(null)    // false</span><br><span class=\"line\">Boolen(undefined)   // false</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>33. 解决回调地狱 （多级回调）</h2>\n<pre><code>1. Promise\n\n2. aSync/await\n\n3. generator\n</code></pre>\n<h2>34. 字符串</h2>\n<pre><code>1. slice\n\n    在 不修改目标数组 的情况下返回截取的指定元素（ **起始位置，截止位置**）\n\n    从0开始 ==不包含最后一个数值==\n\n    负数情况下 将负数加上自身长度得到的数值作为参数\n\n2. substr\n\n    subdtr接收的是 起始位置 和 所要返回的字符串长度\n\n    在负数情况下  将第一个参数与字符串长度相加后的数值作为第一个参数\n\n3. substring\n\n    默认会将较小的参数作为第一个参数\n\n    在 不修改目标数组 的情况下返回截取的指定元素 （ **起始位置，截止位置**）\n\n    负数当做0处理\n</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let test = &apos;abcdef&apos;</span><br><span class=\"line\">test.slice(0, -1)   // abcde</span><br><span class=\"line\">test.slice(2, -3)   =&gt; test.slice(2,3)  // c</span><br><span class=\"line\"></span><br><span class=\"line\">test.substring(1, -2) =&gt; a</span><br><span class=\"line\">test.substring(2, -3) =&gt; ab</span><br></pre></td></tr></table></figure>\n<pre><code>4. split\n\n    字符串按照指定规则转换成数组\n</code></pre>\n<h2>35. let 与 var 区别</h2>\n<pre><code>1. var存在变量提升， let不存在；\n2. let不允许重复声明；\n3. var挂载在window下，let挂载在块作用域下；\n</code></pre>\n<h2>36. 为什么 var 可以重复声明</h2>\n<pre><code>因为js运行过程中，\n\n引擎 负责整个代码编译和运行\n\n编译器 负责词法分析、语法分析、代码生成等工作\n\n编译器从左至右编译var a，如果a不存在则在作用域声明一个新的变量a，若存在a则忽略继续向下编译；\n\n引擎遇到a = 2，按照作用域链向上查找 若存在变量a直接赋值，不存在则在作用域重新声明新的变量并赋值2\n</code></pre>\n<h2>37. CommonJS 中的 require/exports 和 ES6 的 import/export 有什么区别</h2>\n<ol>\n<li></li>\n</ol>\n<blockquote>\n<p>CommomJS 模块 require 代码时候会立刻执行；</p>\n</blockquote>\n<blockquote>\n<p>ES6 模块是动态引用，不会立刻执行，仅仅作为一个加载模块的对象引用；</p>\n</blockquote>\n<ol start=\"2\">\n<li></li>\n</ol>\n<blockquote>\n<p>CommonJs 模块输出的是一个值的拷贝， 输出后的对象会被缓存（即 如果发现一个模块被多次引用，会直接返回已经执行的部分）；</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// lib.js</span><br><span class=\"line\">var counter = 3;</span><br><span class=\"line\">function incCounter() &#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// main.js</span><br><span class=\"line\">var mod = require(&apos;./lib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(mod.counter);  // 3</span><br><span class=\"line\">mod.incCounter();</span><br><span class=\"line\">console.log(mod.counter); // 3</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ES6 模块输出的是值的只读引用；</p>\n</blockquote>\n<ul>\n<li>接口输出的变量是只读的，重新赋值会报错；</li>\n<li>export 通过接口输出的是同一个值，得到的都是同样的实例；</li>\n<li>如果需要 import 支持动态加载 提案建议引入 import() 返回一个 promise 对象；</li>\n</ul>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/module-loader\" target=\"_blank\" rel=\"noopener\">ES6 模块与 CommonJS 模块的差异 </a></li>\n</ol>\n<h2>38. 浏览器缓存</h2>\n<pre><code>浏览器缓存分为 强缓存 和 协商缓存\n\n1. 客户端先根据资源的http header判断是否命中强缓存，如果命中直接从缓存中读取；\n\n2. 强缓存未命中，客户端发出请求，服务端根据请求的request header验证资源是否命中协商缓存，这个过程成为http再验证。如果命中，服务器将请求返回，状态码304，但不返回资源，而是告诉客服端可以从缓存读取；\n\n3. 当协商缓存也没有命中，直接服务端返回资源给客户端；\n\n\n强缓存\n\n1. Expires 代表缓存过期时间；\n\n2. Cache-Control： max-age  代表缓存最大生命周期；\n\n协商缓存\n\n1. Last-Modified 代表资源最后更新时间；\n\n2. If-Modified-Since 代表 判断两次请求之间是否有过修改 没有直接返回协商缓存；\n</code></pre>\n<h2>39. 处理 js 双精度问题</h2>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> = <span class=\"number\">0.30000000000000004</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>由于计算机是做二进制运算</p>\n<p>0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）</p>\n<p>0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）</p>\n<p>双精度浮点数的小数部分最多支持 52 位</p>\n<p>处理方法：</p>\n<pre><code>1. toFixed  不够严谨；\n2. 把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;(<span class=\"number\">0.1</span> * <span class=\"number\">10</span> + <span class=\"number\">0.2</span> * <span class=\"number\">10</span>) / <span class=\"number\">10</span> == <span class=\"number\">0.3</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<ol>\n<li>\n<p><a href=\"https://github.com/Megan-TA/UtilsJS\" target=\"_blank\" rel=\"noopener\">个人封装的处理双精度方法 第 7 点</a></p>\n</li>\n<li>\n<p><a href=\"https://www.cnblogs.com/xinggood/p/6639022.html\" target=\"_blank\" rel=\"noopener\">关于 js 浮点数计算精度不准确问题的解决办法</a></p>\n</li>\n</ol>\n<h2>40. postMessage</h2>\n<ol>\n<li>window.postMessage() 可以安全进行跨域、跨页面通信；</li>\n<li>页面加载完成后才能进行跨域通信；</li>\n</ol>\n<p>发起端可以是 open 一个新窗口 或者 创建一个 iframe 往新窗口里发送数据</p>\n<p>案例:</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 客户端两种方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 当前页面地址 http:<span class=\"comment\">//www.webhek.com --&gt;</span></span><br><span class=\"line\">&lt;!-- open方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//弹出一个新窗口</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> domain = <span class=\"string\">'http://fanyi.youdao.com'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myPopup = <span class=\"built_in\">window</span>.open(domain, <span class=\"string\">'myWindow'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//周期性的发送消息</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'Hello! The time is: '</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'blog.local: sending message: '</span> + message);</span><br><span class=\"line\"><span class=\"comment\">//send the message and target URI</span></span><br><span class=\"line\">myPopup.postMessage(message,domain);</span><br><span class=\"line\">&#125;,<span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- iframe方式 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//捕获 iframe</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> domain = <span class=\"string\">\"http://fanyi.youdao.com\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myIFrame'</span>).contentWindow;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//发送消息</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'Hello! The time is: '</span> + (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'blog.local: sending message: '</span> + message);</span><br><span class=\"line\"><span class=\"comment\">//send the message and target URI</span></span><br><span class=\"line\">iframe.postMessage(message,domain);</span><br><span class=\"line\">&#125;,<span class=\"number\">6000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 接收端 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//监听消息反馈</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(event.origin !== <span class=\"string\">'http://www.webhek.com'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'received response: '</span>,event.data);</span><br><span class=\"line\">&#125;,<span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n</code></pre>\n<blockquote>\n<p>截图如下：</p>\n</blockquote>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006ANKB8gy1fqhqrhftfmj30yu0objvr.jpg\" alt=\"web骇客网站  接收端截图\"><br>\n<img src=\"https://wx2.sinaimg.cn/mw690/006ANKB8gy1fqhqri8fjlj30zk0h4tbk.jpg\" alt=\"有道翻译网站 接收端截图\"></p>\n<blockquote>\n<p>参考资料</p>\n</blockquote>\n<ol>\n<li><a href=\"http://www.webhek.com/post/window-postmessage-api.html\" target=\"_blank\" rel=\"noopener\">用 HTML5 里的 window.postMessage 在两个网页间传递数据</a></li>\n</ol>\n<h2>41. Service Worker</h2>\n<blockquote>\n<p>背景</p>\n</blockquote>\n<p>为了解决 web 业务不断增加带来更多消耗资源、耗时等复杂运算带来性能问题，w3c 初期提出 Web Worker 的 API，目的为了解放主线程。原理是 将复杂 耗时的操作独立出来交给 Web Worker，完成后通过 postMessage 方法告诉主线程。</p>\n<p>缺点：临时存在，不能永久；为此提出 Service Worker，在 Web Worker 基础上增加持久缓存能力。</p>\n<p>在 Service Worker 之前有 APPCache 这个持久缓存的 API，不过存在更新机主不完善，二次更新，大小限制，回滚等问题，具体参考下方链接 1。</p>\n<p>Service Worker 的特性如下：</p>\n<ul>\n<li>\n<p>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</p>\n</li>\n<li>\n<p>一旦被 install，就永远存在，除非被 uninstall</p>\n</li>\n<li>\n<p>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）</p>\n</li>\n<li>\n<p>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</p>\n</li>\n<li>\n<p>离线内容开发者可控</p>\n</li>\n<li>\n<p>能向客户端推送消息</p>\n</li>\n<li>\n<p>不能直接操作 DOM</p>\n</li>\n<li>\n<p>出于安全的考虑，必须在 HTTPS 环境下才能工作</p>\n</li>\n<li>\n<p>异步实现，内部大都是通过 Promise 实现</p>\n</li>\n<li>\n<p>只能运行在 HTTPS 协议下</p>\n</li>\n</ul>\n<blockquote>\n<p>参考资料</p>\n</blockquote>\n<ol>\n<li><a href=\"https://www.zhihu.com/question/29876535\" target=\"_blank\" rel=\"noopener\">为什么 app cache 没有得到大规模应用？它有哪些硬伤吗？</a></li>\n<li><a href=\"https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction\" target=\"_blank\" rel=\"noopener\">Service Worker 简介</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28161855\" target=\"_blank\" rel=\"noopener\">如何优雅的为 PWA 注册 Service Worker</a></li>\n</ol>\n<h2>42 加载更多/下拉刷新</h2>\n<p>原理：</p>\n<p>scrollTop（滚动条滚动距离） + clientHeight（可见区域高度） == scrollHeight（元素实际高度）</p>\n<p>备注：</p>\n<p>offsetHeighgt = height + padding + border</p>\n<p>clientHeight = height + padding</p>\n<h2>43. js 标签中<code>async</code>和<code>defer</code>的作用与区别</h2>\n<p>作用：</p>\n<p>1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>\n<p>2.async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p>\n<p>3.defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。</p>\n<p>区别：</p>\n<p>defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。<br>\n在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。</p>\n"}],"PostAsset":[{"_id":"source/_posts/centos下开机自动重启服务和脚本/WX20190708-113220.png","slug":"WX20190708-113220.png","post":"ck55698220004gu1pgd8w178j","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ck556981y0002gu1paq5qa6l2","tag_id":"ck55698240005gu1pvj41n7qe","_id":"ck556982c000bgu1p7v8rcs4z"},{"post_id":"ck55698220004gu1pgd8w178j","tag_id":"ck55698240005gu1pvj41n7qe","_id":"ck556982g000fgu1p2dmg3e4n"},{"post_id":"ck55698260007gu1p8zqdkbl2","tag_id":"ck556982f000egu1ph6jwlajh","_id":"ck556982i000kgu1psfmccxqy"},{"post_id":"ck556982i000jgu1p0fvyr643","tag_id":"ck55698240005gu1pvj41n7qe","_id":"ck556982k000ngu1p1jrcd7wv"},{"post_id":"ck55698270008gu1ppxvz6b43","tag_id":"ck556982h000igu1pvsbukk4e","_id":"ck556982k000pgu1poeen23zh"},{"post_id":"ck55698290009gu1p5uauto9w","tag_id":"ck556982j000mgu1p5vsr91sl","_id":"ck556982m000tgu1pzdrtxlk6"},{"post_id":"ck556982m000ugu1pgpp8x07p","tag_id":"ck556982l000rgu1pebpzi8qv","_id":"ck556982o000xgu1pm12j3cd6"},{"post_id":"ck556982c000cgu1pci28w7z4","tag_id":"ck556982l000rgu1pebpzi8qv","_id":"ck556982p000zgu1prgfdab7j"},{"post_id":"ck556982n000vgu1p8oelpkta","tag_id":"ck556982l000rgu1pebpzi8qv","_id":"ck556982q0012gu1p7wx8qmzu"},{"post_id":"ck556982f000dgu1pagjtj6zq","tag_id":"ck556982l000rgu1pebpzi8qv","_id":"ck556982r0014gu1pc3xca0z2"},{"post_id":"ck556982q0013gu1p5b855drh","tag_id":"ck556982h000igu1pvsbukk4e","_id":"ck556982s0017gu1pz8r3e8j3"},{"post_id":"ck556982g000ggu1psga119ya","tag_id":"ck556982q0011gu1p89to2lri","_id":"ck556982t0019gu1pqy33t504"},{"post_id":"ck556982h000hgu1puv0l5d3b","tag_id":"ck556982q0011gu1p89to2lri","_id":"ck556982u001dgu1p4hyth7tq"},{"post_id":"ck556982t001agu1p0bhgq2ly","tag_id":"ck556982l000rgu1pebpzi8qv","_id":"ck556982v001fgu1p0huu7ng0"},{"post_id":"ck556982j000lgu1p27wy9otl","tag_id":"ck556982t001bgu1pl8eotzct","_id":"ck556982w001igu1pu0h3wxev"},{"post_id":"ck556982v001egu1pruwlesbc","tag_id":"ck556982l000rgu1pebpzi8qv","_id":"ck556982x001kgu1pt0f0wlh3"},{"post_id":"ck556982w001hgu1pug4wjyf5","tag_id":"ck556982q0011gu1p89to2lri","_id":"ck556982z001ngu1phhp4n48s"},{"post_id":"ck556982k000ogu1pybk4e0zu","tag_id":"ck556982v001ggu1pknp40hfl","_id":"ck5569830001pgu1prxkufnph"},{"post_id":"ck556982z001ogu1ptnh9vjgl","tag_id":"ck556982q0011gu1p89to2lri","_id":"ck5569830001rgu1pc6gfesyp"},{"post_id":"ck556982l000qgu1p2tsxafsm","tag_id":"ck556982y001lgu1p2prvbrc7","_id":"ck5569830001sgu1p92jnie3d"},{"post_id":"ck556982l000sgu1pawj0bmqh","tag_id":"ck5569830001qgu1pyjsdhzvh","_id":"ck5569831001ugu1pdrpuydp0"},{"post_id":"ck556982p0010gu1p7r8isdqy","tag_id":"ck5569830001tgu1pcpn7nm1e","_id":"ck5569831001wgu1pt1f22w3a"},{"post_id":"ck556982r0015gu1pkx4v13c8","tag_id":"ck5569831001vgu1pfkq13vjk","_id":"ck5569831001ygu1pvff80v8h"},{"post_id":"ck556982u001cgu1pnsffwpaa","tag_id":"ck5569831001xgu1pmv1skvna","_id":"ck55698320020gu1pdut226qd"},{"post_id":"ck556982x001jgu1p7x6l7u6c","tag_id":"ck5569831001zgu1p93xajht8","_id":"ck55698320022gu1ppkeu6a8i"},{"post_id":"ck556982y001mgu1p5t57ugyx","tag_id":"ck55698320021gu1p132l7r1j","_id":"ck55698320023gu1pyfop64tq"},{"post_id":"ck556983h0025gu1pb8b3ylxc","tag_id":"ck5569831001zgu1p93xajht8","_id":"ck556983j0028gu1pahm6zqtv"},{"post_id":"ck556983g0024gu1pmgj9ffyt","tag_id":"ck556983i0026gu1prn0c9s8r","_id":"ck556983j0029gu1pq4ixkkir"},{"post_id":"ck5569840002agu1p84vmkvx1","tag_id":"ck556982l000rgu1pebpzi8qv","_id":"ck5569841002bgu1pvua0snrc"}],"Tag":[{"name":"linux","_id":"ck55698240005gu1pvj41n7qe"},{"name":"docker","_id":"ck556982f000egu1ph6jwlajh"},{"name":"web","_id":"ck556982h000igu1pvsbukk4e"},{"name":"git","_id":"ck556982j000mgu1p5vsr91sl"},{"name":"javascript","_id":"ck556982l000rgu1pebpzi8qv"},{"name":"node","_id":"ck556982q0011gu1p89to2lri"},{"name":"react","_id":"ck556982t001bgu1pl8eotzct"},{"name":"python","_id":"ck556982v001ggu1pknp40hfl"},{"name":"vue react","_id":"ck556982y001lgu1p2prvbrc7"},{"name":"监控","_id":"ck5569830001qgu1pyjsdhzvh"},{"name":"IDE","_id":"ck5569830001tgu1pcpn7nm1e"},{"name":"npm","_id":"ck5569831001vgu1pfkq13vjk"},{"name":"随笔","_id":"ck5569831001xgu1pmv1skvna"},{"name":"前端","_id":"ck5569831001zgu1p93xajht8"},{"name":"jenkins","_id":"ck55698320021gu1p132l7r1j"},{"name":"nginx","_id":"ck556983i0026gu1prn0c9s8r"}]}}